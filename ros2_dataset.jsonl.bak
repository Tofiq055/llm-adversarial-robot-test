{"instruction": "Write a ROS2 Python node named reset.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "import rclpy\nfrom rclpy.node import Node\nfrom pymoveit2 import MoveIt2\nfrom rcl_interfaces.srv import GetParameters\nimport xml.etree.ElementTree as ET\nimport time\nimport numpy as np\n\nARM_GROUP_NAME = 'arm34'\nGRIPPER_GROUP_NAME = 'gripper34'\nPOSE_NAME = 'rest'\nVELOCITY_FACTOR = 0.1\nACCELERATION_FACTOR = 0.1\nPLANNING_TIME = 5.0\nPLANNING_ATTEMPTS = 10\n\n\nclass Moveit:\n    def __init__(self):\n        self.moveit_node = Node('reset_moveit_node')\n        self.get_param_cli = None\n\n    def setup_get_move_group_params(self, get_parameters='/move_group/get_parameters'):\n        self.get_param_cli = self.moveit_node.create_client(GetParameters, get_parameters)\n        while not self.get_param_cli.wait_for_service(timeout_sec=1.0):\n            self.moveit_node.get_logger().info('[Env] [Moveit] service not available, waiting again...')\n        self.req = GetParameters.Request()\n        return\n\n    def get_move_group_params(self, param):\n        if self.get_param_cli is None: self.setup_get_move_group_params()\n        self.req.names = [param]\n        itreation = 0\n        while True:\n            itreation += 1\n            self.future = self.get_param_cli.call_async(self.req)\n            rclpy.spin_until_future_complete(self.moveit_node, self.future, timeout_sec=1.0)\n            if self.future.result() is not None:\n                return self.future.result().values[0]\n            elif itreation > 10:\n                return False\n            else:\n                print(\"Service call failed %r\" % (self.future.exception(),))\n                time.sleep(1)\n                continue\n\n    def moveit_extract_joint_info(self):\n        semantic_description = self.get_move_group_params('robot_description_semantic')\n        self.moveit_info = ET.fromstring(semantic_description.string_value)\n        self.moveit_group_poses, self.moveit_arms_joint_names, self.moveit_hand_joint_names = {}, [], []\n        for child in self.moveit_info:\n            if child.tag == 'group_state' and child.attrib['group'] == ARM_GROUP_NAME:\n                if ARM_GROUP_NAME not in self.moveit_group_poses:\n                    self.moveit_group_poses[ARM_GROUP_NAME] = {}\n                self.moveit_group_poses[ARM_GROUP_NAME][child.attrib['name']] = []\n                for joint in child:\n                    self.moveit_group_poses[ARM_GROUP_NAME][child.attrib['name']].append(\n                        float(joint.attrib['value']))\n                if len(self.moveit_arms_joint_names) == 0:\n                    self.moveit_arms_joint_names = [joint.attrib['name'] for joint in child]\n            elif child.tag == 'group_state' and child.attrib['group'] == GRIPPER_GROUP_NAME:\n                if GRIPPER_GROUP_NAME not in self.moveit_group_poses:\n                    self.moveit_group_poses[GRIPPER_GROUP_NAME] = {}\n                self.moveit_group_poses[GRIPPER_GROUP_NAME][child.attrib['name']] = []\n                for joint in child:\n                    self.moveit_group_poses[GRIPPER_GROUP_NAME][child.attrib['name']].append(\n                        float(joint.attrib['value']))\n                if len(self.moveit_hand_joint_names) == 0:\n                    self.moveit_hand_joint_names = [joint.attrib['name'] for joint in child]\n        return\n\n    def setup_moveit(self):\n        self.moveit_extract_joint_info()\n        self.arms_group = MoveIt2(node=self.moveit_node, joint_names=self.moveit_arms_joint_names,\n                                  base_link_name='', end_effector_name='',\n                                  group_name=ARM_GROUP_NAME,\n                                  use_move_group_action=True)\n        self.arms_group.num_planning_attempts = PLANNING_ATTEMPTS\n        self.arms_group.allowed_planning_time = PLANNING_TIME\n        self.arms_group.max_velocity = VELOCITY_FACTOR\n        self.arms_group.max_acceleration = ACCELERATION_FACTOR\n\n        self.arms_group.move_to_configuration(self.moveit_group_poses[ARM_GROUP_NAME][POSE_NAME])\n        self.arms_group.wait_until_executed()\n\n        if self.moveit_hand_joint_names:\n            self.hand_group = MoveIt2(node=self.moveit_node, joint_names=self.moveit_hand_joint_names,\n                                      base_link_name='', end_effector_name='',\n                                      group_name=GRIPPER_GROUP_NAME, use_move_group_action=True)\n            self.hand_group.num_planning_attempts = PLANNING_ATTEMPTS\n            self.hand_group.allowed_planning_time = PLANNING_TIME\n            self.hand_group.max_velocity = VELOCITY_FACTOR\n            self.hand_group.max_acceleration = ACCELERATION_FACTOR\n            if POSE_NAME in self.moveit_group_poses[GRIPPER_GROUP_NAME]:\n                self.hand_group.move_to_configuration(\n                    self.moveit_group_poses[GRIPPER_GROUP_NAME][POSE_NAME])\n            else:\n                self.hand_group.move_to_configuration(self.moveit_group_poses[GRIPPER_GROUP_NAME]['init'])\n            self.hand_group.wait_until_executed()\n        return\n\nif __name__ == '__main__':\n    rclpy.init()\n    moveit = Moveit()\n    moveit.setup_moveit()\n    print(\"MoveIt setup complete.\")\n    rclpy.shutdown()\n\n"}\n{"instruction": "Write a ROS2 Python node named moveit_ik.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "import rclpy\nfrom rclpy.node import Node\n\nfrom sensor_msgs.msg import JointState\nfrom tf2_ros import TransformException\nfrom tf2_ros.buffer import Buffer\nfrom tf2_ros.transform_listener import TransformListener\nfrom moveit_msgs.srv import GetPositionIK\n\nimport numpy as np\n\ntarget_angles = None\nglobal_joint_states = None\ntf_base_link_P = None\n\n\nclass MinimalClientAsync:\n    def __init__(self, node):\n        self.logger = node.get_logger()\n        self.clock = node.get_clock()\n        self.node = node\n\n        self.tf_buffer = Buffer()\n        self.tf_listener = TransformListener(self.tf_buffer, node)\n        self.timer = node.create_timer(1.0, self.on_timer)\n        node.create_subscription(JointState, \"/joint_states\", self.joint_states_cb, 1)\n\n        self.cli = node.create_client(GetPositionIK, \"/compute_ik\")\n        while not self.cli.wait_for_service(timeout_sec=1.0):\n            self.logger.info(\"service not available, waiting again...\")\n\n    def on_timer(self):\n        global tf_base_link_P\n        # Look up for the transformation between target_frame and turtle2 frames\n        # and send velocity commands for turtle2 to reach target_frame\n        try:\n            t = self.tf_buffer.lookup_transform(\n                \"base_link\", \"P\", rclpy.time.Time(), rclpy.duration.Duration(seconds=1)\n            )\n\n            tf_base_link_P = [\n                t.transform.translation.x,\n                t.transform.translation.y,\n                t.transform.translation.z,\n                t.transform.rotation.x,\n                t.transform.rotation.y,\n                t.transform.rotation.z,\n                t.transform.rotation.w,\n            ]\n            self.tf_base_link_P = tf_base_link_P\n        except TransformException as ex:\n            self.logger.info(f\"Could not transform base_link to P: {ex}\")\n            return\n\n    def joint_states_cb(self, joint_state):\n        global global_joint_states\n        global_joint_states = joint_state\n        self.joint_state = joint_state\n\n    def moveit_ik(self):\n        group_name = \"spot_arm\"\n        self.req.ik_request.group_name = group_name\n        self.req.ik_request.robot_state.joint_state = self.joint_state\n        self.req.ik_request.avoid_collisions = True\n\n        self.req.ik_request.pose_stamped.header.stamp = self.clock.now().to_msg()\n        self.req.ik_request.pose_stamped.header.frame_id = \"base_link\"\n\n        self.req.ik_request.pose_stamped.pose.position.x = self.tf_base_link_P[0]\n        self.req.ik_request.pose_stamped.pose.position.y = self.tf_base_link_P[1]\n        self.req.ik_request.pose_stamped.pose.position.z = self.tf_base_link_P[2] + 0.05\n\n        self.req.ik_request.pose_stamped.pose.orientation.x = self.tf_base_link_P[3]\n        self.req.ik_request.pose_stamped.pose.orientation.y = self.tf_base_link_P[4]\n        self.req.ik_request.pose_stamped.pose.orientation.z = self.tf_base_link_P[5]\n        self.req.ik_request.pose_stamped.pose.orientation.w = self.tf_base_link_P[6]\n\n        self.req.ik_request.timeout.sec = 5\n\n        return self.req.ik_request\n\n    def send_request(self):\n        self.req = GetPositionIK.Request()\n        self.req.ik_request = self.moveit_ik()\n\n        self.future = self.cli.call_async(self.req)\n        rclpy.spin_until_future_complete(self.node, self.future)\n        return self.future.result()\n\n\ndef main():\n    rclpy.init()\n    node = Node(\"moveit_ik_python\")\n\n    minimal_client = MinimalClientAsync(node)\n    while global_joint_states is None or tf_base_link_P is None:\n        rclpy.spin_once(node)\n    response = minimal_client.send_request()\n    print(response.solution.joint_state.name[:7])\n    target_angles = list(response.solution.joint_state.position)[:7]\n\n    if not len(target_angles):\n        print(\"No IK solution found\")\n        node.destroy_node()\n        rclpy.shutdown()\n        return\n    print([round(np.rad2deg(ta)) for ta in target_angles])\n\n\nif __name__ == \"__main__\":\n    main()\n"}\n{"instruction": "Write a ROS2 Python node named follow_aruco.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "#!/usr/bin/env python3\n\nimport rclpy\nfrom rclpy.node import Node\nfrom rclpy.executors import MultiThreadedExecutor\n\nfrom cv_bridge import CvBridge\nimport cv2\nimport numpy as np\nfrom sensor_msgs.msg import Image, CameraInfo\nfrom std_msgs.msg import Header\nfrom geometry_msgs.msg import Pose, PoseStamped, TransformStamped, Twist, TwistStamped, Quaternion\nimport tf2_ros\nimport tf2_py\nimport transforms3d as t3d\nfrom transforms3d.euler import quat2euler\nfrom geometry_msgs.msg import Vector3\nfrom tf2_geometry_msgs import do_transform_pose\nimport tf2_geometry_msgs\nfrom tf2_ros import StaticTransformBroadcaster\n\nfrom moveit_msgs.msg import ServoStatus\n\nimport time\nimport math\nfrom scipy.spatial.transform import Rotation as R\n\nfrom world_info_msgs.msg import BoundingPolygon, BoundingPolygonArray\nfrom geometry_msgs.msg import Point32\n\nimport rclpy\nfrom rclpy.node import Node\n\nfrom sensor_msgs.msg import JointState\nfrom moveit_msgs.srv import GetPositionIK\n\nfrom geometry_msgs.msg import Pose, Quaternion, TransformStamped, Twist\n\nimport numpy as np\nimport time\n\nfrom tf2_geometry_msgs.tf2_geometry_msgs import do_transform_pose\n\nfrom rclpy.action import ActionClient\nfrom rclpy.node import Node\n\nfrom moveit_msgs.msg import MotionPlanRequest\nfrom moveit_msgs.msg import JointConstraint\nfrom moveit_msgs.msg import Constraints\nfrom moveit_msgs.msg import PlanningOptions\nfrom moveit_msgs.action import MoveGroup\n\nfrom copy import deepcopy\n\nARUCO_ID = 21\nARUCO_SIZE = 0.04\nDISTANCE_TO_ARUCO = 0.28\n\n\nclass Moveit(Node):\n    def __init__(self):\n        super().__init__(\"moveit_plan_execute_python\")\n\n        self._action_client = ActionClient(self, MoveGroup, \"/move_action\")\n\n    def send_goal(self, target_angles):\n        self.joint_state = None\n        self.goal_done = False\n\n        motion_plan_request = MotionPlanRequest()\n\n        motion_plan_request.workspace_parameters.header.stamp = (\n            self.get_clock().now().to_msg()\n        )\n        motion_plan_request.workspace_parameters.header.frame_id = \"gen3_base_link\"\n        motion_plan_request.workspace_parameters.min_corner.x = -1.0\n        motion_plan_request.workspace_parameters.min_corner.y = -1.0\n        motion_plan_request.workspace_parameters.min_corner.z = -1.0\n        motion_plan_request.workspace_parameters.max_corner.x = 1.0\n        motion_plan_request.workspace_parameters.max_corner.y = 1.0\n        motion_plan_request.workspace_parameters.max_corner.z = 1.0\n        motion_plan_request.start_state.is_diff = True\n\n        jc = JointConstraint()\n        jc.tolerance_above = 0.01\n        jc.tolerance_below = 0.01\n        jc.weight = 1.0\n\n        joints = {}\n        joints[\"joint_1\"] = target_angles[0]\n        joints[\"joint_2\"] = target_angles[1]\n        joints[\"joint_3\"] = target_angles[2]\n        joints[\"joint_4\"] = target_angles[3]\n        joints[\"joint_5\"] = target_angles[4]\n        joints[\"joint_6\"] = target_angles[5]\n\n        constraints = Constraints()\n        for joint, angle in joints.items():\n            jc.joint_name = joint\n            jc.position = angle\n            constraints.joint_constraints.append(deepcopy(jc))\n\n        motion_plan_request.goal_constraints.append(constraints)\n\n        motion_plan_request.pipeline_id = \"ompl\"\n        # motion_plan_request.planner_id = \"STOMP\"\n        motion_plan_request.group_name = \"manipulator\"\n        motion_plan_request.num_planning_attempts = 10\n        motion_plan_request.allowed_planning_time = 10.0\n        motion_plan_request.max_velocity_scaling_factor = 0.5\n        motion_plan_request.max_acceleration_scaling_factor = 0.5\n        motion_plan_request.max_cartesian_speed = 0.0\n\n        planning_options = PlanningOptions()\n        planning_options.plan_only = False\n        planning_options.look_around = False\n        planning_options.look_around_attempts = 0\n        planning_options.max_safe_execution_cost = 0.0\n        planning_options.replan = True\n        planning_options.replan_attempts = 10\n        planning_options.replan_delay = 0.1\n\n        goal_msg = MoveGroup.Goal()\n        goal_msg.request = motion_plan_request\n        goal_msg.planning_options = planning_options\n\n        self._action_client.wait_for_server()\n        self._send_goal_future = self._action_client.send_goal_async(\n            goal_msg, feedback_callback=self.feedback_callback\n        )\n        self._send_goal_future.add_done_callback(self.goal_response_callback)\n\n    def goal_response_callback(self, future):\n        goal_handle = future.result()\n        if not goal_handle.accepted:\n            self.get_logger().info(\"Goal rejected :(\")\n            self.goal_done = True\n            return\n\n        self.get_logger().info(\"Goal accepted :)\")\n\n        self._get_result_future = goal_handle.get_result_async()\n        self._get_result_future.add_done_callback(self.get_result_callback)\n\n    def get_result_callback(self, future):\n        # self.get_logger().info(str(future))\n        self.goal_done = True\n\n    def feedback_callback(self, feedback_msg):\n        # self.get_logger().info(str(feedback_msg))\n        pass\n\n\nrelative_points = np.array(\n    [\n        [-ARUCO_SIZE / 2, ARUCO_SIZE / 2, 0],\n        [ARUCO_SIZE / 2, ARUCO_SIZE / 2, 0],\n        [ARUCO_SIZE / 2, -ARUCO_SIZE / 2, 0],\n        [-ARUCO_SIZE / 2, -ARUCO_SIZE / 2, 0],\n    ],\n    dtype=np.float32,\n)\n\n\nclass IK(Node):\n    def __init__(self):\n        super().__init__(\"moveit_ik\")\n\n        self.create_subscription(JointState, \"/joint_states\", self.joint_states_cb, 1)\n\n        self.cli = self.create_client(GetPositionIK, \"/compute_ik\")\n\n        while not self.cli.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info(\"service not available, waiting again...\")\n            rclpy.spin_once(self)\n\n    def joint_states_cb(self, joint_state):\n        self.joint_state = joint_state\n\n    def send_request(self, pose):\n        self.joint_state = None\n\n        while self.joint_state is None:\n            rclpy.spin_once(self)\n\n        req = GetPositionIK.Request()\n        \n        req.ik_request.group_name = \"manipulator\"\n        req.ik_request.robot_state.joint_state = self.joint_state\n        req.ik_request.avoid_collisions = True\n\n        req.ik_request.pose_stamped.header.stamp = self.get_clock().now().to_msg()\n        req.ik_request.pose_stamped.header.frame_id = \"gen3_base_link\"\n\n        req.ik_request.pose_stamped.pose = pose\n        req.ik_request.timeout.sec = 10\n\n        self.future = self.cli.call_async(req)\n        rclpy.spin_until_future_complete(self, self.future)\n\n        target_angles = list(self.future.result().solution.joint_state.position)[:6]\n\n        if len(target_angles) > 0:\n            return target_angles\n\n        self.get_logger().warn(\"No ik soln found\")\n        return None\n\n\ndef moveit_motion(pose):\n    ik = IK()\n    moveit = Moveit()\n    target_angles = ik.send_request(pose)\n    ik.destroy_node()\n    if target_angles != None:\n        moveit.send_goal(target_angles)\n        while not moveit.goal_done:\n            rclpy.spin_once(moveit)\n        moveit.destroy_node()\n        return target_angles\n    moveit.destroy_node()\n    return target_angles\n\n\ndef compute_end_effector_twist(body_twist, body_to_ee_transform, ee_to_body_transform):\n    # Convert Quaternion to Rotation Matrix for both transformations\n    quat_ab = [body_to_ee_transform.transform.rotation.x,\n               body_to_ee_transform.transform.rotation.y,\n               body_to_ee_transform.transform.rotation.z,\n               body_to_ee_transform.transform.rotation.w]\n    r_ab = R.from_quat(quat_ab)\n    rotation_matrix_ab = r_ab.as_matrix()\n\n    quat_ba = [ee_to_body_transform.transform.rotation.x,\n               ee_to_body_transform.transform.rotation.y,\n               ee_to_body_transform.transform.rotation.z,\n               ee_to_body_transform.transform.rotation.w]\n    r_ba = R.from_quat(quat_ba)\n    rotation_matrix_ba = r_ba.as_matrix()\n\n    # Calculate translation for both transformations\n    translation_ab = np.array([body_to_ee_transform.transform.translation.x,\n                                body_to_ee_transform.transform.translation.y,\n                                body_to_ee_transform.transform.translation.z])\n\n\nclass CameraLinkPose:\n    def __init__(self, tf_buffer, logger):\n        self.logger = logger\n        self.tf_buffer = tf_buffer\n\n        self.nominal_x_position = 0.617\n        self.min_x_position = 0.61\n        self.max_x_position = 0.8\n\n        self.nominal_y_position = 0.0\n        self.min_y_position = self.nominal_y_position - 0.15\n        self.max_y_position = self.nominal_y_position + 0.15\n\n        self.nominal_z_position = 0.6\n        self.min_z_position = self.nominal_z_position - 0.1\n        self.max_z_position = self.nominal_z_position + 0.1\n\n        self.source = \"camera_link\"\n        self.target = \"body\"\n\n        self.height_source = \"camera_link\"\n        self.height_target = \"gpe\"\n\n        self.current_spot_height = 0.0\n        self.new_spot_height = 0.0\n\n    def is_ee_within_xyz_limit(self):\n        SPOT_SPEED_TR = 0.16\n        SPOT_SPEED_ROT = 0.16\n\n        change_height = False\n\n        try:\n            t = self.tf_buffer.lookup_transform(\n                self.target, self.source, rclpy.time.Time()\n            )\n\n            x = 0.0\n            if t.transform.translation.x < self.min_x_position:\n                x = -SPOT_SPEED_TR\n            elif t.transform.translation.x > self.max_x_position:\n                x = SPOT_SPEED_TR\n\n            y = 0.0\n            if t.transform.translation.y < self.min_y_position:\n                y = -SPOT_SPEED_ROT\n            elif t.transform.translation.y > self.max_y_position:\n                y = SPOT_SPEED_ROT\n\n            DELTA_HEIGHT = 0.005\n            if t.transform.translation.z < self.min_z_position:\n                self.new_spot_height -= DELTA_HEIGHT\n            elif t.transform.translation.z > self.max_z_position:\n                self.new_spot_height += DELTA_HEIGHT\n            \n            # self.logger.info(f\"{self.new_spot_height}\")\n\n            MIN_SPOT_HEIGHT = -0.05\n            MAX_SPOT_HEIGHT = 0.05\n            self.new_spot_height = np.clip(self.new_spot_height, MIN_SPOT_HEIGHT, MAX_SPOT_HEIGHT)\n\n            t1 = self.tf_buffer.lookup_transform(\n                self.source, self.target, rclpy.time.Time()\n            )\n\n            if x != 0 or y != 0 or self.current_spot_height != self.new_spot_height:\n                if self.current_spot_height != self.new_spot_height:\n                    self.current_spot_height = self.new_spot_height\n                    change_height = True\n                return False, change_height, x, y, self.current_spot_height, [t1, t]\n\n            return True, change_height, 0.0, 0.0, self.current_spot_height, [t1, t]\n\n        except tf2_ros.TransformException as ex:\n            # self.get_logger().info(f\"Could not transform {self.source} to {self.target}: {ex}\")\n            pass\n\n        return False, change_height, 0.0, 0.0, self.current_spot_height, None\n\n\nclass ArucoDetectorNode(Node):\n    def __init__(self):\n        super().__init__('aruco_detector_node')\n\n        static_broadcaster = StaticTransformBroadcaster(self)\n\n        transform1 = TransformStamped()\n        transform1.header.frame_id = 'aruco_21'\n        transform1.child_frame_id = 'camera_link_target'\n        transform1.transform.translation.z = DISTANCE_TO_ARUCO\n        transform1.transform.rotation.y = 1.0\n        transform1.transform.rotation.w = 0.0\n\n        transform2 = TransformStamped()\n        transform2.header.frame_id = 'camera_link_target'\n        transform2.child_frame_id = 'tool_frame_target'\n        transform2.transform.translation.y = 0.056\n        transform2.transform.translation.z = 0.203\n        transform2.transform.rotation.z = 1.0\n        transform2.transform.rotation.w = 0.0\n\n        static_broadcaster.sendTransform([transform1, transform2])\n\n        self.bridge = CvBridge()\n\n        self.tf_broadcaster = tf2_ros.TransformBroadcaster(self)\n        self.tf_buffer = tf2_ros.Buffer()\n        self.tf_listener = tf2_ros.TransformListener(self.tf_buffer, self)\n\n        self.image_sub = self.create_subscription(\n            Image, '/kinova_color', self.image_callback, 1)\n        self.camera_info_sub = self.create_subscription(\n            CameraInfo, '/kinova_color/camera_info', self.camera_info_callback, 1)\n\n        self.servo_status_sub = self.create_subscription(ServoStatus, '/servo_node/status', self.servo_status_cb, 1)\n\n        # self.create_timer(1/50, self.step)\n        self.ee_twist_pub = self.create_publisher(TwistStamped, \"/twist_controller/commands\", 1)\n        self.spot_twist_pub = self.create_publisher(Twist, \"/cmd_vel\", 1)\n        self.spot_body_pose_pub = self.create_publisher(Pose, \"/body_pose\", 1)\n\n        self.bounding_polygon_pub = self.create_publisher(BoundingPolygonArray, \"/kinova_color/bp\", 1)\n\n        ar_dict = cv2.aruco.getPredefinedDictionary(cv2.aruco.DICT_6X6_50)\n        self.aruco_detector = cv2.aruco.ArucoDetector(ar_dict)\n\n        self.source = 'tool_frame_target'\n        self.target = 'gen3_base_link'\n\n        # Initialize previous values for smoothing\n        self.prev_linear = np.zeros(3)\n        self.prev_angular = np.zeros(3)\n        self.alpha = 0.2  # Smoothing factor (tune this value)\n\n        self.target_goal_reached = False\n\n        self.camera_pose = CameraLinkPose(self.tf_buffer, self.get_logger())\n\n        self.pause = False\n\n        # self.logger = get_logger(\"moveit_py.pose_goal\")\n\n        # instantiate MoveItPy instance and get planning component\n        # self.panda = MoveItPy(node_name=\"moveit_py\")\n        # self.panda_arm = self.panda.get_planning_component(\"manipulator\")\n        # self.logger.info(\"MoveItPy instance created\")\n\n    def servo_status_cb(self, msg):\n        status = msg.code\n        if status == 0:\n            self.pause = False\n            return\n\n        self.pause = True\n        self.get_logger().warn(f\"{status}\")\n        time.sleep(0.1)\n\n    def image_callback(self, msg):\n        if not hasattr(self, 'dist_coeff'):\n            return\n\n        cv_image = self.bridge.imgmsg_to_cv2(msg, 'bgr8')\n        gray = cv2.cvtColor(cv_image, cv2.COLOR_BGR2GRAY)\n\n        (corners, ids, rejected) = self.aruco_detector.detectMarkers(gray)\n\n        if ids is not None:\n            for i in range(len(ids)):\n                if ids[i] == ARUCO_ID:\n                    bounding_polygon_msg = BoundingPolygonArray()\n                    bounding_polygon_msg.header = msg.header\n                    bounding_polygon_msg.type = \"aruco\"\n\n                    bounding_polygon = BoundingPolygon()\n                    bounding_polygon.name = \"aruco_21\"\n\n                    for corner in corners[i][0]:\n                        point = Point32()\n                        point.x = float(corner[0])\n                        point.y = float(corner[1])\n                        bounding_polygon.array.append(point)\n\n                    bounding_polygon_msg.array.append(bounding_polygon)\n\n                    self.bounding_polygon_pub.publish(bounding_polygon_msg)\n\n                    _, rvec, tvec = cv2.solvePnP(\n                        relative_points, corners[i], self.camera_matrix, self.dist_coeff\n                    )\n                    transform = self.calculate_transform(rvec, tvec)\n                    self.publish_transform(transform, msg.header, ARUCO_ID)\n\n        self.step()\n\n    def camera_info_callback(self, msg):\n        if hasattr(self, 'dist_coeff'):\n            return\n        self.camera_matrix = np.array(msg.k).reshape((3, 3))\n        self.dist_coeff = np.array(msg.d)\n\n    def calculate_transform(self, rvec, tvec):\n        rotation_matrix, _ = cv2.Rodrigues(rvec)\n        translation_vector = np.array(tvec).reshape((3, 1))\n\n        transform = np.eye(4)\n        transform[:3, :3] = rotation_matrix\n        transform[:3, 3] = translation_vector.flatten()\n\n        return transform\n\n    def publish_transform(self, transform, header, aruco_id):\n        tf_msg = TransformStamped()\n        tf_msg.header = header\n        tf_msg.child_frame_id = f'aruco_{aruco_id}'\n        tf_msg.transform.translation.x = transform[0, 3]\n        tf_msg.transform.translation.y = transform[1, 3]\n        tf_msg.transform.translation.z = transform[2, 3]\n\n        rotation_matrix = transform[:3, :3]\n        rotation_quaternion = t3d.quaternions.mat2quat(rotation_matrix)\n        tf_msg.transform.rotation.x = -rotation_quaternion[2]\n        tf_msg.transform.rotation.y = rotation_quaternion[1]\n        tf_msg.transform.rotation.z = -rotation_quaternion[0]\n        tf_msg.transform.rotation.w = rotation_quaternion[3]\n\n        self.tf_broadcaster.sendTransform(tf_msg)\n\n    def step(self):\n        GOAL_DISTANCE_TOLERANCE = 0.05\n        GOAL_ANGULAR_TOLERANCE = 0.12\n\n        ee_twist_msg = None\n\n        ee_within_xyz_limit, change_height, spot_speed_x, spot_yaw, spot_height, t_body_camera_link = self.camera_pose.is_ee_within_xyz_limit()\n        # self.get_logger().info(f\"{ee_within_xyz_limit}, {x}\")\n        ee_within_xyz_limit = True\n        if not ee_within_xyz_limit:\n            if spot_speed_x != 0 or spot_yaw != 0 or change_height:\n                spot_twist_msg = Twist()\n                spot_twist_msg.linear.x = spot_speed_x\n                spot_twist_msg.angular.z = spot_yaw\n                # spot_twist_msg.linear.y = spot_yaw\n\n                body_pose_msg = Pose()\n                # self.get_logger().info(f\"{spot_height}\")\n                body_pose_msg.position.z = spot_height\n\n                if not self.pause:\n                    # self.spot_body_pose_pub.publish(body_pose_msg)\n                    self.spot_twist_pub.publish(spot_twist_msg)\n\n                    ee_twist_msg = TwistStamped()\n                    ee_twist_msg.header.frame_id = \"body\"\n                    ee_twist_msg.header.stamp = self.get_clock().now().to_msg()\n\n                    ee_twist_msg.twist.linear.x = -1.2*spot_twist_msg.linear.x\n                    ee_twist_msg.twist.linear.y = -1.2*spot_twist_msg.angular.z\n\n                    if t_body_camera_link is not None:\n                        t_body_camera_link, t_camera_link_body = t_body_camera_link\n                        # ee_twist_msg.twist = compute_end_effector_twist(spot_twist_msg, t_body_camera_link, t_camera_link_body)\n\n                        # print(spot_twist_msg, ee_twist_msg)\n\n        try:\n            t = self.tf_buffer.lookup_transform(\n                self.target, self.source, rclpy.time.Time()\n            )\n\n            within_distance_tolerance = False\n            if abs(t.transform.translation.x) < GOAL_DISTANCE_TOLERANCE and \\\n            abs(t.transform.translation.y) < GOAL_DISTANCE_TOLERANCE and \\\n            abs(t.transform.translation.z) < GOAL_DISTANCE_TOLERANCE:\n                within_distance_tolerance = True\n\n            # within_angular_tolerance = False\n            # if abs(euler_angles[0]) < GOAL_ANGULAR_TOLERANCE and \\\n            # abs(euler_angles[1]) < GOAL_ANGULAR_TOLERANCE and \\\n            # abs(euler_angles[2]) < GOAL_ANGULAR_TOLERANCE:\n            #     within_angular_tolerance = True\n\n            # if within_distance_tolerance:# and within_angular_tolerance:\n            #     self.tf_buffer.clear()\n            #     return\n\n            # set plan start state to current state\n            # self.panda_arm.set_start_state_to_current_state()\n\n            if not within_distance_tolerance:\n                pose_goal = Pose()\n                pose_goal.position.x = t.transform.translation.x\n                pose_goal.position.y = t.transform.translation.y \n                pose_goal.position.z = t.transform.translation.z \n                pose_goal.orientation.x = t.transform.rotation.x\n                pose_goal.orientation.y = t.transform.rotation.y\n                pose_goal.orientation.z = t.transform.rotation.z\n                pose_goal.orientation.w = t.transform.rotation.w\n\n                moveit_motion(pose_goal)\n            self.tf_buffer.clear()\n\n            # self.panda_arm.set_goal_state(pose_stamped_msg=pose_goal, pose_link=\"camera_link\")\n\n            # plan to goal\n            # plan_and_execute(self.panda, self.panda_arm, self.logger, sleep_time=0.1)\n\n        #     # Apply low-pass filter to angular components\n        #     euler_angles = quat2euler([\n        #         t.transform.rotation.w,\n        #         t.transform.rotation.x,\n        #         t.transform.rotation.y,\n        #         t.transform.rotation.z\n        #     ])\n\n        #     within_angular_tolerance = False\n        #     if abs(euler_angles[0]) < GOAL_ANGULAR_TOLERANCE and \\\n        #     abs(euler_angles[1]) < GOAL_ANGULAR_TOLERANCE and \\\n        #     abs(euler_angles[2]) < GOAL_ANGULAR_TOLERANCE:\n        #         within_angular_tolerance = True\n                \n        #     if ee_twist_msg is None:\n        #         ee_twist_msg = TwistStamped()\n        #         ee_twist_msg.header = t.header\n\n        #         if not within_distance_tolerance:\n        #             # Apply low-pass filter to linear components\n        #             ee_twist_msg.twist.linear.x = 1.5 * self.alpha * t.transform.translation.x + (1 - self.alpha) * self.prev_linear[0]\n        #             ee_twist_msg.twist.linear.y = 1.5 * self.alpha * t.transform.translation.y + (1 - self.alpha) * self.prev_linear[1]\n        #             ee_twist_msg.twist.linear.z = 1.5 * self.alpha * t.transform.translation.z + (1 - self.alpha) * self.prev_linear[2]\n                    \n        #             linear_max = 0.2\n        #             ee_twist_msg.twist.linear.x = np.clip(ee_twist_msg.twist.linear.x, -linear_max, linear_max)\n        #             ee_twist_msg.twist.linear.y = np.clip(ee_twist_msg.twist.linear.y, -linear_max, linear_max)\n        #             ee_twist_msg.twist.linear.z = np.clip(ee_twist_msg.twist.linear.z, -linear_max, linear_max)\n\n        #         if not within_angular_tolerance:\n        #             ee_twist_msg.twist.angular.x = 1.5 * self.alpha * euler_angles[0] + (1 - self.alpha) * self.prev_angular[0]\n        #             ee_twist_msg.twist.angular.y = 1.5 * self.alpha * euler_angles[1] + (1 - self.alpha) * self.prev_angular[1]\n        #             ee_twist_msg.twist.angular.z = 1.5 * self.alpha * euler_angles[2] + (1 - self.alpha) * self.prev_angular[2]\n\n        #             angular_max = 0.8\n\n        #             ee_twist_msg.twist.angular.x = np.clip(ee_twist_msg.twist.angular.x, -angular_max, angular_max)\n        #             ee_twist_msg.twist.angular.y = np.clip(ee_twist_msg.twist.angular.y, -angular_max, angular_max)\n        #             ee_twist_msg.twist.angular.z = np.clip(ee_twist_msg.twist.angular.z, -angular_max, angular_max)\n\n        #     # self.get_logger().info(f\"{within_distance_tolerance}, {within_angular_tolerance}\")\n        #     if within_distance_tolerance and within_angular_tolerance:\n        #         self.target_goal_reached = True\n        #     else:\n        #         self.target_goal_reached = False\n\n        except tf2_ros.TransformException as ex:\n            pass\n            self.get_logger().info(f\"Could not transform {self.source} to {self.target}: {ex}\")\n\n        #     if ee_twist_msg is None:\n        #         # Initialize ee_twist_msg with previous decayed values when transform is not available\n        #         ee_twist_msg = TwistStamped()\n        #         ee_twist_msg.header.frame_id = \"camera_link\"\n        #         ee_twist_msg.header.stamp = self.get_clock().now().to_msg()\n        #         ee_twist_msg.twist.linear.x = self.prev_linear[0] * 0.5  # Adjust the decay rate as needed\n        #         ee_twist_msg.twist.linear.y = self.prev_linear[1] * 0.5  # Adjust the decay rate as needed\n        #         ee_twist_msg.twist.linear.z = self.prev_linear[2] * 0.5  # Adjust the decay rate as needed\n        #         ee_twist_msg.twist.angular.x = self.prev_angular[0] * 0.5  # Adjust the decay rate as needed\n        #         ee_twist_msg.twist.angular.y = self.prev_angular[1] * 0.5  # Adjust the decay rate as needed\n        #         ee_twist_msg.twist.angular.z = self.prev_angular[2] * 0.5  # Adjust the decay rate as needed\n\n        # # Publish the result\n        # if not self.target_goal_reached:\n        #     # Update previous values for the next iteration\n        #     self.prev_linear = np.array([ee_twist_msg.twist.linear.x, ee_twist_msg.twist.linear.y, ee_twist_msg.twist.linear.z])\n        #     self.prev_angular = np.array([ee_twist_msg.twist.angular.x, ee_twist_msg.twist.angular.y, ee_twist_msg.twist.angular.z])\n\n        # self.ee_twist_pub.publish(ee_twist_msg)\n        # self.tf_buffer.clear()\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = ArucoDetectorNode()\n\n    # executor = MultiThreadedExecutor()\n    # executor.add_node(node)\n    # executor.spin()\n\n    rclpy.spin(node)\n\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"}\n{"instruction": "Write a ROS2 Python node named moveit_servo.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "# Copyright 2024 The HuggingFace Inc. team. All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport logging\n\nfrom geometry_msgs.msg import TwistStamped\nfrom moveit_msgs.srv import ServoCommandType\nfrom rclpy import qos\nfrom rclpy.callback_groups import CallbackGroup\nfrom rclpy.node import Node\nfrom std_srvs.srv import SetBool\n\nlogger = logging.getLogger(__name__)\n\n\nclass MoveIt2Servo:\n    \"\"\"\n    Python interface for MoveIt2 Servo.\n    \"\"\"\n\n    def __init__(\n        self,\n        node: \"Node\",\n        frame_id: str,\n        callback_group: \"CallbackGroup\",\n    ):\n        self._node = node\n        self._frame_id = frame_id\n        self._enabled = False\n\n        self._twist_pub = node.create_publisher(\n            TwistStamped,\n            \"/servo_node/delta_twist_cmds\",\n            qos.QoSProfile(\n                durability=qos.QoSDurabilityPolicy.VOLATILE,\n                reliability=qos.QoSReliabilityPolicy.RELIABLE,\n                history=qos.QoSHistoryPolicy.KEEP_ALL,\n            ),\n            callback_group=callback_group,\n        )\n        self._pause_srv = node.create_client(\n            SetBool, \"/servo_node/pause_servo\", callback_group=callback_group\n        )\n        self._cmd_type_srv = node.create_client(\n            ServoCommandType, \"/servo_node/switch_command_type\", callback_group=callback_group\n        )\n        self._twist_msg = TwistStamped()\n        self._enable_req = SetBool.Request(data=False)\n        self._disable_req = SetBool.Request(data=True)\n        self._twist_type_req = ServoCommandType.Request(command_type=ServoCommandType.Request.TWIST)\n\n    def enable(self, wait_for_server_timeout_sec=1.0) -> bool:\n        if not self._pause_srv.wait_for_service(timeout_sec=wait_for_server_timeout_sec):\n            logger.warning(\"Pause service not available.\")\n            return False\n        if not self._cmd_type_srv.wait_for_service(timeout_sec=wait_for_server_timeout_sec):\n            logger.warning(\"Command type service not available.\")\n            return False\n        result = self._pause_srv.call(self._enable_req)\n        if not result or not result.success:\n            logger.error(f\"Enable failed: {getattr(result, 'message', '')}\")\n            self._enabled = False\n            return False\n        cmd_result = self._cmd_type_srv.call(self._twist_type_req)\n        if not cmd_result or not cmd_result.success:\n            logger.error(\"Switch to TWIST command type failed.\")\n            self._enabled = False\n            return False\n        logger.info(\"MoveIt Servo enabled.\")\n        self._enabled = True\n        return True\n\n    def disable(self, wait_for_server_timeout_sec=1.0) -> bool:\n        if not self._pause_srv.wait_for_service(timeout_sec=wait_for_server_timeout_sec):\n            logger.warning(\"Pause service not available.\")\n            return False\n        result = self._pause_srv.call(self._disable_req)\n        self._enabled = not (result and result.success)\n        return bool(result and result.success)\n\n    def servo(self, linear=(0.0, 0.0, 0.0), angular=(0.0, 0.0, 0.0), enable_if_disabled=True):\n        if not self._enabled and enable_if_disabled and not self.enable():\n            logger.warning(\"Dropping servo command because MoveIt2 Servo is not enabled.\")\n            return\n\n        self._twist_msg.header.frame_id = self._frame_id\n        self._twist_msg.header.stamp = self._node.get_clock().now().to_msg()\n        self._twist_msg.twist.linear.x = float(linear[0])\n        self._twist_msg.twist.linear.y = float(linear[1])\n        self._twist_msg.twist.linear.z = float(linear[2])\n        self._twist_msg.twist.angular.x = float(angular[0])\n        self._twist_msg.twist.angular.y = float(angular[1])\n        self._twist_msg.twist.angular.z = float(angular[2])\n        self._twist_pub.publish(self._twist_msg)\n"}\n{"instruction": "Write a ROS2 Python node named moveit_py.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "\nimport rclpy\nimport time\nfrom rclpy.node import Node\nfrom rclpy.logging import get_logger\nfrom moveit.planning import (MoveItPy,MultiPipelinePlanRequestParameters)\nfrom moveit.core.planning_scene import PlanningScene\nfrom geometry_msgs.msg import Pose\n\ndef plan_and_execute(\n    robot,\n    planning_component,\n    logger,\n    single_plan_parameters=None,\n    multi_plan_parameters=None,\n    sleep_time=0.0,\n):\n    \"\"\"Helper function to plan and execute a motion.\"\"\"\n    # plan to goal\n    logger.info(\"Planning trajectory\")\n    if multi_plan_parameters is not None:\n        plan_result = planning_component.plan(\n            multi_plan_parameters=multi_plan_parameters\n        )\n    elif single_plan_parameters is not None:\n        plan_result = planning_component.plan(\n            single_plan_parameters=single_plan_parameters\n        )\n    else:\n        plan_result = planning_component.plan()\n\n    # execute the plan\n    if plan_result:\n        logger.info(\"Executing plan\")\n        robot_trajectory = plan_result.trajectory\n        robot.execute(robot_trajectory, controllers=[])\n    else:\n        logger.error(\"Planning failed\")\n\n    time.sleep(sleep_time)\n\n\ndef main():\n    rclpy.init()\n    logger = get_logger(\"moveit_example\")\n    node = rclpy.create_node('moveit_example')\n\n    # Initialize MoveItPy\n    panda = MoveItPy(node_name=\"moveit_py\")\n    panda_arm = panda.get_planning_component(\"panda_arm\")\n    logger.info(\"MoveItPy instance created\")\n\n    # set plan start state to current state\n    panda_arm.set_start_state_to_current_state()\n\n    # set pose goal with PoseStamped message\n    from geometry_msgs.msg import PoseStamped\n\n    pose_goal = PoseStamped()\n    pose_goal.header.frame_id = \"panda_link0\"\n    pose_goal.pose.orientation.w = 1.0\n    pose_goal.pose.position.x = 0.28\n    pose_goal.pose.position.y = -0.2\n    pose_goal.pose.position.z = 1.0\n    panda_arm.set_goal_state(pose_stamped_msg=pose_goal, pose_link=\"panda_link8\")\n\n    time.sleep(5.0)\n\n    # plan to goal\n    plan_and_execute(panda, panda_arm, logger, sleep_time=3.0)\n\nif __name__ == '__main__':\n    main()\n"}\n{"instruction": "Write a ROS2 Python node named simple_moveit_controller.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "#!/usr/bin/env python3\n# 基础版：订阅手动发布的 PoseStamped，调用 MoveIt 规划并用 RealMan SDK 执行（静态目标）\nimport argparse\nimport math\nimport sys\nfrom typing import List, Optional\n\nimport numpy as np\nimport rclpy\nfrom geometry_msgs.msg import PoseStamped\nfrom moveit.planning import MoveItPy\nfrom moveit.core.robot_model import RobotModel\nfrom moveit.core.robot_state import RobotState\nfrom moveit_configs_utils import MoveItConfigsBuilder\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState\nfrom moveit_msgs.msg import RobotTrajectory as RobotTrajectoryMsg\n\ntry:\n    from realman.RealMan import RM_controller\n    from Robotic_Arm.rm_robot_interface import rm_thread_mode_e\nexcept Exception as exc:\n    print(f\"导入 RealMan SDK 失败: {exc}\", file=sys.stderr)\n    sys.exit(1)\n\n# 角度转弧度\ndef _deg2rad_list(vals: List[float]) -> List[float]:\n    return [v * math.pi / 180.0 for v in vals]\n\n\n# 弧度转角度\ndef _rad2deg_list(vals: List[float]) -> List[float]:\n    return [v * 180.0 / math.pi for v in vals]\n\n\nclass SimpleMoveItController(Node):\n    def __init__(\n        self,\n        robot_ip: str,\n        pose_topic: str,\n        group_name: str,\n        eef_link: str,\n        joint_names: Optional[List[str]] = None,\n        joint_state_hz: float = 10.0,\n    ):\n        \"\"\"\n        初始化 SimpleMoveItController 控制器\n        \n        Args:\n            robot_ip (str): 机器人控制器的IP地址\n            pose_topic (str): 订阅目标位姿的话题名称\n            group_name (str): MoveIt中使用的规划组名称\n            eef_link (str): 机器人末端执行器链接名称\n            joint_names (Optional[List[str]]): 关节名称列表，默认为None时会从JointModelGroup获取\n            joint_state_hz (float): 关节状态发布的频率，默认为10.0Hz\n        \"\"\"\n        super().__init__(\"simple_moveit_controller\")\n\n        # 连接硬件\n        self.get_logger().info(f\"连接机械臂: {robot_ip}\")\n        self.rm_controller = RM_controller(robot_ip, rm_thread_mode_e.RM_TRIPLE_MODE_E)\n        self.get_logger().info(f\"连接成功，当前关节: {self.rm_controller.get_state()}\")\n\n        # MoveIt 初始化\n        self.get_logger().info(\"初始化 MoveIt...\")\n        moveit_config = (\n            MoveItConfigsBuilder(\n                robot_name=\"rm_robot\",\n                package_name=\"rm_moveit2\",\n            )\n            .robot_description(file_path=\"config/rm_75_6f_description.urdf.xacro\")\n            .trajectory_execution(file_path=\"config/moveit_controllers.yaml\")\n            .moveit_cpp(file_path=\"config/motion_planning_python_api_tutorial.yaml\")\n            .to_moveit_configs()\n        )\n        self.moveit = MoveItPy(node_name=\"moveit_py_node\", config_dict=moveit_config.to_dict())\n        self.group_name = group_name\n        self.eef_link = eef_link\n        self.arm = self.moveit.get_planning_component(self.group_name)\n        self.robot_model: RobotModel = self.moveit.get_robot_model()\n        self.jmg = self.robot_model.get_joint_model_group(self.group_name)\n        self.joint_names = joint_names or self.jmg.active_joint_model_names\n        if not self.joint_names:\n            raise RuntimeError(f\"无法从 JointModelGroup({self.group_name}) 获取关节名\")\n\n        # 关节状态发布（给 RViz / MoveIt 起始状态）\n        self.joint_state_pub = self.create_publisher(JointState, \"/joint_states\", 10)\n        self.create_timer(1.0 / max(joint_state_hz, 0.1), self._publish_joint_state)\n\n        # 订阅目标位姿\n        self.pose_sub = self.create_subscription(PoseStamped, pose_topic, self._on_pose, 10)\n        self.currently_executing = False\n        self.last_goal = None\n\n        self.get_logger().info(f\"监听位姿话题: {pose_topic}\")\n        self.get_logger().info(f\"规划组: {self.group_name}, 末端链接: {self.eef_link}\")\n\n    # 检查角度值是否疑似为度\n    def _looks_like_degree(self, joints: List[float]) -> bool:\n        return any(abs(v) > 10.0 for v in joints)\n\n    # 获取硬件关节值（自动检测度/弧度）\n    def _get_hardware_joints_rad(self) -> List[float]:\n        raw = list(self.rm_controller.get_state())\n        if self._looks_like_degree(raw):\n            if not hasattr(self, \"_warned_deg\"):\n                self._warned_deg = True\n                self.get_logger().info(\"检测到关节值疑似“度”，自动转弧度\")\n            return _deg2rad_list(raw)\n        return raw\n\n    # 发布关节状态\n    \"\"\"\n    实时同步机械臂关节状态：从硬件控制器获取当前关节角度，发布到 /joint_states 话题\n    更新MoveIt起始状态：将获取的关节状态同步到MoveIt规划器中作为规划的起始状态\n    \"\"\"\n    def _publish_joint_state(self):\n        joints_rad = self._get_hardware_joints_rad()\n        size = min(len(joints_rad), len(self.joint_names))\n        msg = JointState()\n        msg.header.stamp = self.get_clock().now().to_msg()\n        msg.name = self.joint_names[:size]\n        msg.position = joints_rad[:size]\n        self.joint_state_pub.publish(msg)\n\n        # 同步 MoveIt start_state\n        try:\n            robot_state = RobotState(self.robot_model)\n            robot_state.set_joint_group_active_positions(\n                self.group_name, np.asarray(joints_rad[:size], dtype=float)\n            )\n            robot_state.update()\n            # robot_state.enforce_bounds() # 强制关节限位（当前MoveIt2 Python API好像没有这个方法）\n            ok = self.arm.set_start_state(robot_state=robot_state)\n            if not ok:\n                self.get_logger().warn(\"set_start_state 返回 False，请检查关节名/范围\")\n        except Exception as exc:\n            self.get_logger().warn(f\"同步 start_state 失败: {exc}\")\n\n    # ---- 回调、规划与执行 ----\n    # 检查目标位姿是否改变\n    \"\"\"\n    避免重复规划相同的目标位置（阈值设置为1mm）\n    \"\"\"\n    def _pose_changed(self, pose: PoseStamped) -> bool:\n        p = pose.pose.position\n        q = pose.pose.orientation\n        current = (p.x, p.y, p.z, q.x, q.y, q.z, q.w)\n        if self.last_goal is None:\n            self.last_goal = current\n            return True\n        pos_eps = 1e-3\n        ori_eps = 1e-3\n        pos_changed = any(abs(a - b) > pos_eps for a, b in zip(current[:3], self.last_goal[:3]))\n        ori_changed = any(abs(a - b) > ori_eps for a, b in zip(current[3:], self.last_goal[3:]))\n        if pos_changed or ori_changed:\n            self.last_goal = current\n            return True\n        return False\n\n    # 目标位姿回调\n    \"\"\"\n    主控制流程：接收目标位姿消息，进行规划和执行的主循环\n    执行状态管理：防止在执行过程中接收新指令（串行执行）\n    \"\"\"\n    def _on_pose(self, msg: PoseStamped):\n        if self.currently_executing:\n            return\n        if not self._pose_changed(msg):\n            return\n        self.currently_executing = True\n        self.get_logger().info(\n            f\"收到目标位姿，frame={msg.header.frame_id} -> 规划并执行\"\n        )\n        try:\n            plan = self._plan_to_pose(msg)\n            if plan:\n                if self._execute_plan(plan):\n                    self.get_logger().info(\"执行完成\")\n                else:\n                    self.get_logger().error(\"执行失败\")\n            else:\n                self.get_logger().error(\"规划失败\")\n        finally:\n            self.currently_executing = False\n\n    # 规划到指定位姿\n    def _plan_to_pose(self, pose: PoseStamped):\n        try:\n            self._publish_joint_state()  # 确保起始状态最新\n            self.arm.set_goal_state(pose_stamped_msg=pose, pose_link=self.eef_link)\n            plan_result = self.arm.plan()\n            if plan_result:\n                self.get_logger().info(\"MoveIt 规划成功\")\n                return plan_result\n            return None\n        except Exception as exc:\n            self.get_logger().error(f\"规划出错: {exc}\")\n            return None\n\n    # 执行规划轨迹  \n    def _execute_plan(self, plan, group_joint_order=None) -> bool:\n        if plan is None or plan.trajectory is None:\n            self.get_logger().error(\"空规划或无轨迹\")\n            return False\n        try:\n            rt = plan.trajectory\n            msg: RobotTrajectoryMsg = rt.get_robot_trajectory_msg()\n            jt = msg.joint_trajectory\n            name_to_index = {name: i for i, name in enumerate(jt.joint_names)}\n            joint_order = group_joint_order or self.joint_names or jt.joint_names\n            num_points = len(jt.points)\n\n            for i, point in enumerate(jt.points):\n                positions = [point.positions[name_to_index[n]] for n in joint_order]\n                positions_deg = _rad2deg_list(positions)\n                \n                is_last_point = (i == num_points - 1)\n                if is_last_point:\n                    # 最后一个点：connect=0 触发执行，block=1 等待完成\n                    connect_flag = 0\n                    radius = 0\n                    block_flag = 1 \n                else:\n                    # 中间所有点：connect=1 加入平滑队列，block=1 会立即返回\n                    connect_flag = 1\n                    radius = 100  # 交融半径系数(0-100)\n                    block_flag = 1\n                \n                self.get_logger().info(\n                    f\"发送路点 {i+1}/{num_points}: 规划角度={positions_deg}, connect={connect_flag}, r={radius}\"\n                )\n                ret = self.rm_controller.movej(positions_deg, v=20, r=radius, connect=connect_flag, block=block_flag)\n                if ret != 0:\n                    self.get_logger().error(f\"路点 {i} 执行失败，错误码: {ret}\")\n                    return False\n            return True\n        except Exception as exc:\n            self.get_logger().error(f\"执行轨迹出错: {exc}\")\n            return False\n\ndef main(argv=None):\n    parser = argparse.ArgumentParser(description=\"手动位姿 -> MoveIt 规划 -> RealMan 执行\")\n    parser.add_argument(\"--robot-ip\", default=\"192.168.0.17\", help=\"机械臂 IP\")\n    parser.add_argument(\"--pose-topic\", default=\"/Current_OBJ_position_1\", help=\"订阅的 PoseStamped 话题\")\n    parser.add_argument(\"--group\", default=\"rm_robot_arm\", help=\"MoveIt 规划组\")\n    parser.add_argument(\"--eef-link\", default=\"Link7\", help=\"末端链接名\")\n    parser.add_argument(\n        \"--joint-names\",\n        default=\"joint1,joint2,joint3,joint4,joint5,joint6,joint7\",\n        help=\"关节名顺序，逗号分隔（需与硬件状态顺序一致）\",\n    )\n    parser.add_argument(\"--joint-state-hz\", type=float, default=10.0, help=\"/joint_states 发布频率\")\n    args = parser.parse_args(argv)\n\n    joint_names = [n.strip() for n in args.joint_names.split(\",\") if n.strip()]\n    if not joint_names:\n        print(\"关节名不能为空\", file=sys.stderr)\n        sys.exit(1)\n\n    rclpy.init()\n    node = SimpleMoveItController(\n        robot_ip=args.robot_ip,\n        pose_topic=args.pose_topic,\n        group_name=args.group,\n        eef_link=args.eef_link,\n        joint_names=joint_names,\n        joint_state_hz=args.joint_state_hz,\n    )\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\n\nif __name__ == \"__main__\":\n    main()\n"}\n{"instruction": "Write a ROS2 Python node named 01_moveit_pick_and_place.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "#!/usr/bin/env python3\n\"\"\"\nAlicia D机械臂 Pick and Place 演示程序\n\n运行前需要先启动(注意夹爪类型50/100mm):\n    cd ~/alicia_ws\n    source install/setup.bash\n    ros2 launch alicia_d_moveit real_robot.launch.py gripper_type:=50mm\n\n然后在另一个终端运行此脚本:\n    cd ~/alicia_ws\n    python3 ./src/examples/01_moveit_pick_and_place.py\n\"\"\"\n\nimport sys\nimport rclpy\nfrom rclpy.node import Node\nfrom rclpy.action import ActionClient\nfrom control_msgs.action import FollowJointTrajectory\nfrom trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint\nfrom moveit_msgs.msg import DisplayTrajectory\nfrom geometry_msgs.msg import Pose, PoseStamped\nfrom moveit_msgs.srv import GetPositionIK, GetMotionPlan\nfrom moveit_msgs.msg import Constraints, JointConstraint\nfrom moveit_msgs.action import ExecuteTrajectory\nfrom sensor_msgs.msg import JointState\nimport time\nfrom rclpy.duration import Duration\n\n\nclass PickAndPlaceDemo(Node):\n    \"\"\"Pick and Place 演示节点\"\"\"\n    \n    def __init__(self):\n        super().__init__('pick_and_place_demo')\n        \n        # 创建Action客户端\n        self.arm_action_client = ActionClient(\n            self, \n            FollowJointTrajectory, \n            '/Alicia_controller/follow_joint_trajectory'\n        )\n        \n        self.gripper_action_client = ActionClient(\n            self, \n            FollowJointTrajectory, \n            '/Gripper_controller/follow_joint_trajectory'\n        )\n        \n        # 等待Action服务器\n        self.get_logger().info('等待Action服务器...')\n        self.arm_action_client.wait_for_server()\n        self.gripper_action_client.wait_for_server()\n        self.get_logger().info('Action服务器已连接!')\n        \n        # MoveIt ExecuteTrajectory action 客户端\n        self.execute_trajectory_client = ActionClient(\n            self, ExecuteTrajectory, '/execute_trajectory')\n        self.get_logger().info('等待ExecuteTrajectory服务器...')\n        self.execute_trajectory_client.wait_for_server()\n        self.get_logger().info('ExecuteTrajectory服务器已连接!')\n        \n        # 运动规划服务客户端\n        self.plan_client = self.create_client(GetMotionPlan, '/plan_kinematic_path')\n        self.get_logger().info('等待运动规划服务...')\n        self.plan_client.wait_for_service()\n        self.get_logger().info('运动规划服务已连接!')\n        \n        # 关节名称\n        self.arm_joint_names = ['Joint1', 'Joint2', 'Joint3', 'Joint4', 'Joint5', 'Joint6']\n        self.gripper_joint_names = ['Gripper']\n        \n        # HOME位置\n        self.home_position = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n        \n        # Position A \n        # 根据实际机械臂和工作空间调整\n        self.position_a = [-0.3, -0.279, 0.349, -0.105, -0.715, 0.314]\n        self.position_a_above = [-0.32, -0.052, 0.471, -0.087, -1.134, 0.297]\n        \n        # Position B \n        # self.position_b = [1.2, -0.5, 0.8, 0.0, 0.7, 0.0]\n        self.position_b = [0.3, -0.279, 0.349, -0.105, -0.715, 0.314]\n        self.position_b_above = [0.32, -0.052, 0.471, -0.087, -1.134, 0.297]\n        \n        # 夹爪位置\n        self.gripper_open = [0.0]  # 张开\n        self.gripper_close = [0.025]   # 闭合\n        \n    def plan_to_joint_positions(self, joint_positions):\n        \"\"\"\n        使用MoveIt规划到目标关节位置的轨迹\n        \n        Args:\n            joint_positions: 目标关节位置列表\n            \n        Returns:\n            规划好的轨迹或None（规划失败时）\n        \"\"\"\n        request = GetMotionPlan.Request()\n        \n        # 设置规划组\n        request.motion_plan_request.group_name = \"Alicia\"\n        request.motion_plan_request.num_planning_attempts = 5\n        request.motion_plan_request.allowed_planning_time = 5.0\n        request.motion_plan_request.max_velocity_scaling_factor = 0.3\n        request.motion_plan_request.max_acceleration_scaling_factor = 0.3\n        \n        # 使用当前状态作为起始状态\n        request.motion_plan_request.start_state.is_diff = True\n        \n        # 设置关节目标约束\n        goal_constraints = Constraints()\n        goal_constraints.name = \"joint_goal\"\n        \n        for i, joint_name in enumerate(self.arm_joint_names):\n            joint_constraint = JointConstraint()\n            joint_constraint.joint_name = joint_name\n            joint_constraint.position = float(joint_positions[i])\n            joint_constraint.tolerance_above = 0.01\n            joint_constraint.tolerance_below = 0.01\n            joint_constraint.weight = 1.0\n            goal_constraints.joint_constraints.append(joint_constraint)\n        \n        request.motion_plan_request.goal_constraints.append(goal_constraints)\n        \n        # 调用规划服务\n        try:\n            self.get_logger().info(f'规划到关节位置: {[f\"{j:.3f}\" for j in joint_positions]}')\n            future = self.plan_client.call_async(request)\n            rclpy.spin_until_future_complete(self, future, timeout_sec=10.0)\n            \n            if not future.done():\n                self.get_logger().error('运动规划服务超时')\n                return None\n            \n            response = future.result()\n            \n            if response.motion_plan_response.error_code.val == 1:  # SUCCESS\n                self.get_logger().info(f'规划成功，轨迹包含 {len(response.motion_plan_response.trajectory.joint_trajectory.points)} 个点')\n                return response.motion_plan_response.trajectory\n            else:\n                self.get_logger().error(f'运动规划失败，错误码: {response.motion_plan_response.error_code.val}')\n                return None\n                \n        except Exception as e:\n            self.get_logger().error(f'运动规划服务调用失败: {e}')\n            return None\n    \n    def execute_trajectory(self, trajectory):\n        \"\"\"\n        执行规划好的轨迹\n        \n        Args:\n            trajectory: RobotTrajectory消息\n            \n        Returns:\n            bool: 是否执行成功\n        \"\"\"\n        goal_msg = ExecuteTrajectory.Goal()\n        goal_msg.trajectory = trajectory\n        \n        self.get_logger().info('执行轨迹...')\n        \n        send_goal_future = self.execute_trajectory_client.send_goal_async(goal_msg)\n        rclpy.spin_until_future_complete(self, send_goal_future, timeout_sec=10.0)\n        \n        if not send_goal_future.done():\n            self.get_logger().error('等待轨迹执行目标接受超时')\n            return False\n        \n        goal_handle = send_goal_future.result()\n        if not goal_handle.accepted:\n            self.get_logger().error('轨迹执行目标被拒绝')\n            return False\n        \n        self.get_logger().info('轨迹执行目标已接受，等待完成...')\n        \n        # 根据轨迹时长计算超时\n        if trajectory.joint_trajectory.points:\n            last_point = trajectory.joint_trajectory.points[-1]\n            traj_duration = last_point.time_from_start.sec + last_point.time_from_start.nanosec / 1e9\n            timeout_sec = traj_duration + 15.0\n        else:\n            timeout_sec = 30.0\n        \n        result_future = goal_handle.get_result_async()\n        rclpy.spin_until_future_complete(self, result_future, timeout_sec=timeout_sec)\n        \n        if not result_future.done():\n            self.get_logger().error('等待轨迹执行结果超时')\n            return False\n        \n        result = result_future.result()\n        if result.result.error_code.val == 1:  # SUCCESS\n            self.get_logger().info('轨迹执行完成')\n            return True\n        else:\n            self.get_logger().error(f'轨迹执行失败，错误码: {result.result.error_code.val}')\n            return False\n    \n    def move_arm_to_joint_positions(self, joint_positions, duration_sec=3.0):\n        \"\"\"\n        移动机械臂到指定关节位置（使用MoveIt plan+execute）\n        \n        Args:\n            joint_positions: 关节位置列表\n            duration_sec: 运动时长(秒) - 现在仅作为备用方法的参数\n        \"\"\"\n        self.get_logger().info(f'移动机械臂到: {[f\"{j:.3f}\" for j in joint_positions]} (使用MoveIt)')\n        \n        # 使用MoveIt plan+execute\n        trajectory = self.plan_to_joint_positions(joint_positions)\n        if trajectory is not None:\n            if self.execute_trajectory(trajectory):\n                time.sleep(0.5)  # 等待机械臂稳定\n                return True\n        \n        # 如果MoveIt失败，回退到直接轨迹控制\n        self.get_logger().warn('MoveIt plan+execute失败，尝试直接轨迹控制...')\n        return self._move_arm_direct(joint_positions, duration_sec)\n    \n    def _move_arm_direct(self, joint_positions, duration_sec=3.0):\n        \"\"\"\n        直接使用FollowJointTrajectory控制机械臂（备用方法）\n        \n        Args:\n            joint_positions: 关节位置列表\n            duration_sec: 运动时长(秒)\n        \"\"\"\n        goal_msg = FollowJointTrajectory.Goal()\n        \n        # 构建轨迹消息\n        trajectory = JointTrajectory()\n        trajectory.joint_names = self.arm_joint_names\n        \n        # 添加目标点\n        point = JointTrajectoryPoint()\n        point.positions = joint_positions\n        point.time_from_start = Duration(seconds=duration_sec).to_msg()\n        \n        trajectory.points.append(point)\n        goal_msg.trajectory = trajectory\n        \n        # 发送目标\n        self.get_logger().info(f'直接控制移动到: {joint_positions}')\n        send_goal_future = self.arm_action_client.send_goal_async(goal_msg)\n        rclpy.spin_until_future_complete(self, send_goal_future)\n        \n        goal_handle = send_goal_future.result()\n        if not goal_handle.accepted:\n            self.get_logger().error('目标被拒绝')\n            return False\n        \n        # 等待执行完成\n        result_future = goal_handle.get_result_async()\n        rclpy.spin_until_future_complete(self, result_future)\n        \n        result = result_future.result()\n        if result.result.error_code == 0:\n            self.get_logger().info('到达目标位置')\n            return True\n        else:\n            self.get_logger().error(f'运动失败，错误码: {result.result.error_code}')\n            return False\n    \n    def move_gripper(self, gripper_position, duration_sec=1.0):\n        \"\"\"\n        控制夹爪\n        \n        Args:\n            gripper_position: 夹爪位置列表\n            duration_sec: 运动时长(秒)\n        \"\"\"\n        goal_msg = FollowJointTrajectory.Goal()\n        \n        # 构建轨迹消息\n        trajectory = JointTrajectory()\n        trajectory.joint_names = self.gripper_joint_names\n        \n        # 添加目标点\n        point = JointTrajectoryPoint()\n        point.positions = gripper_position\n        point.time_from_start = Duration(seconds=duration_sec).to_msg()\n        \n        trajectory.points.append(point)\n        goal_msg.trajectory = trajectory\n        \n        # 发送目标\n        gripper_state = \"闭合\" if gripper_position[0] > 0.02 else \"张开\"\n        # self.get_logger().info(f'夹爪{gripper_state}')\n        send_goal_future = self.gripper_action_client.send_goal_async(goal_msg)\n        rclpy.spin_until_future_complete(self, send_goal_future)\n        \n        goal_handle = send_goal_future.result()\n        if not goal_handle.accepted:\n            self.get_logger().error('夹爪目标被拒绝')\n            return False\n        \n        # 等待执行完成\n        result_future = goal_handle.get_result_async()\n        rclpy.spin_until_future_complete(self, result_future)\n        \n        result = result_future.result()\n        if result.result.error_code == 0:\n            self.get_logger().info(f'夹爪{gripper_state}完成')\n            return True\n        else:\n            self.get_logger().error(f'夹爪运动失败，错误码: {result.result.error_code}')\n            return False\n    \n    def run_demo(self):\n        \"\"\"执行完整的pick and place演示\"\"\"\n        self.get_logger().info('=' * 50)\n        self.get_logger().info('开始 Pick and Place 演示')\n        self.get_logger().info('=' * 50)\n        \n        try:\n            # 步骤1: 移动到HOME位置\n            self.get_logger().info('等待移动到HOME位置......')\n            if not self.move_arm_to_joint_positions(self.home_position, 3.0):\n                return False\n            time.sleep(1)\n            \n            # 步骤2: 夹爪张开\n            self.get_logger().info('等待夹爪张开......')\n            if not self.move_gripper(self.gripper_open, 1.0):\n                return False\n            time.sleep(1)\n            \n            # 步骤3: 移动到Position A上方\n            self.get_logger().info('等待移动到Position A上方......')\n            if not self.move_arm_to_joint_positions(self.position_a_above, 2.0):\n                return False\n            time.sleep(1)\n            \n            # 步骤4: 下降到Position A\n            self.get_logger().info('等待下降到Position A......')\n            if not self.move_arm_to_joint_positions(self.position_a, 2.0):\n                return False\n            time.sleep(1)\n            \n            # 步骤5: 夹爪闭合（抓取）\n            self.get_logger().info('等待夹爪闭合......')\n            if not self.move_gripper(self.gripper_close, 1.0):\n                return False\n            time.sleep(1)\n            \n            # 步骤6: 上升5cm\n            self.get_logger().info('等待上升......')\n            if not self.move_arm_to_joint_positions(self.position_a_above, 2.0):\n                return False\n            time.sleep(1)\n            \n            # 步骤7: 回到HOME位置\n            self.get_logger().info('等待回到HOME位置......')\n            if not self.move_arm_to_joint_positions(self.home_position, 2.0):\n                return False\n            time.sleep(1)\n            \n            # 步骤8: 移动到Position B上方\n            self.get_logger().info('等待移动到Position B上方......')\n            if not self.move_arm_to_joint_positions(self.position_b_above, 2.0):\n                return False\n            time.sleep(1)\n            \n            # 步骤9: 下降到Position B\n            self.get_logger().info('等待下降到Position B......')\n            if not self.move_arm_to_joint_positions(self.position_b, 2.0):\n                return False\n            time.sleep(1)\n            \n            # 步骤10: 夹爪张开（放置物体）\n            self.get_logger().info('等待夹爪张开......')\n            if not self.move_gripper(self.gripper_open, 1.0):\n                return False\n            time.sleep(1)\n            \n            # 步骤11: 上升5cm\n            self.get_logger().info('等待上升......')\n            if not self.move_arm_to_joint_positions(self.position_b_above, 2.0):\n                return False\n            time.sleep(1)\n            \n            # 步骤12: 回到HOME位置\n            self.get_logger().info('等待回到HOME位置......')\n            if not self.move_arm_to_joint_positions(self.home_position, 3.0):\n                return False\n            \n            self.get_logger().info('\\n' + '=' * 50)\n            self.get_logger().info('Pick and Place 演示完成!')\n            self.get_logger().info('=' * 50)\n            return True\n            \n        except Exception as e:\n            self.get_logger().error(f'演示过程中发生错误: {str(e)}')\n            return False\n\n\ndef main(args=None):\n    \"\"\"主函数\"\"\"\n    rclpy.init(args=args)\n    \n    # 创建节点\n    demo_node = PickAndPlaceDemo()\n    \n    # 等待一下确保系统初始化完成\n    time.sleep(2)\n    \n    # 运行演示\n    success = demo_node.run_demo()\n    \n    # 清理\n    demo_node.destroy_node()\n    rclpy.shutdown()\n    \n    return 0 if success else 1\n\n\nif __name__ == '__main__':\n    sys.exit(main())\n\n"}\n{"instruction": "Write a ROS2 Python node named gen3_rl_moveit_ik.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "#!/usr/bin/env python3\n# This script is a copy of gen3_rl_moveit.py but uses MoveIt for IK.\nimport rclpy\nfrom rclpy.node import Node\nfrom rclpy.action import ActionClient\nfrom trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint\nimport torch\nimport numpy as np\nimport os\nfrom sensor_msgs.msg import JointState\nfrom control_msgs.action import GripperCommand\nfrom geometry_msgs.msg import TransformStamped, PoseStamped\nfrom tf2_ros import TransformListener, Buffer\nimport tf2_geometry_msgs\nimport sys\nsys.path.append('/home/max/robosuite_ws/robosuite_training_examples')  # Directory containing networks.py\nfrom networks import TD3, Actor, Critic  # Import your network classes\n\nclass JointPublisher(Node):\n    def send_trajectory_to_moveit(self, joint_positions, duration_sec=1.0):\n        # Send a trajectory to the /execute_trajectory action server (MoveIt)\n        from moveit_msgs.action import ExecuteTrajectory\n        from moveit_msgs.msg import RobotTrajectory\n        from trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint\n        import rclpy\n        import time\n        # Build JointTrajectory\n        jt = JointTrajectory()\n        jt.joint_names = self.joint_names\n        point = JointTrajectoryPoint()\n        point.positions = joint_positions\n        point.time_from_start.sec = int(duration_sec)\n        point.time_from_start.nanosec = int((duration_sec % 1) * 1e9)\n        jt.points.append(point)\n        # Build RobotTrajectory\n        robot_traj = RobotTrajectory()\n        robot_traj.joint_trajectory = jt\n        # Create action client\n        self.moveit_action_client = ActionClient(self, ExecuteTrajectory, '/execute_trajectory')\n        if not self.moveit_action_client.wait_for_server(timeout_sec=5.0):\n            self.get_logger().error('MoveIt /execute_trajectory action server not available!')\n            return\n        goal_msg = ExecuteTrajectory.Goal()\n        goal_msg.trajectory = robot_traj\n        send_goal_future = self.moveit_action_client.send_goal_async(goal_msg)\n        rclpy.spin_until_future_complete(self, send_goal_future)\n        goal_handle = send_goal_future.result()\n        if not goal_handle.accepted:\n            self.get_logger().error('MoveIt did not accept trajectory goal!')\n            return\n        self.get_logger().info('MoveIt accepted trajectory goal, waiting for result...')\n        get_result_future = goal_handle.get_result_async()\n        rclpy.spin_until_future_complete(self, get_result_future)\n        result = get_result_future.result().result\n        self.get_logger().info(f'MoveIt trajectory execution result: {result}')\n    def __init__(self, joint_names, actor_model_path=\"/home/max/robosuite_ws/robosuite_training_examples/tmp/kinova_td3/best_actor.pth\"):\n        super().__init__('joint_publisher_rl')\n        self.joint_names = joint_names\n        state_dim = 57\n        action_dim = 7\n        max_action = 1.0\n        self.agent = TD3(state_dim, action_dim, max_action)\n        if os.path.exists(actor_model_path):\n            self.agent.actor.load_state_dict(torch.load(actor_model_path, map_location='c' \\\n            'pu', weights_only=True))\n            self.agent.actor.eval()\n            self.get_logger().info(f\"Successfully loaded actor model from: {actor_model_path}\")\n        else:\n            self.get_logger().error(f\"Failed to load actor model from: {actor_model_path}\")\n            self.get_logger().info(\"Using random actions instead\")\n            self.agent = None\n        self.current_state = np.zeros(state_dim)\n        self.tf_buffer = Buffer()\n        self.tf_listener = TransformListener(self.tf_buffer, self)\n        self.object_position = np.array([0.0, 0.0, 0.0])\n        self.object_orientation = np.array([0.0, 0.0, 0.0, 1.0])\n        self.gripper_position = np.array([0.0, 0.0, 0.0])\n        self.gripper_orientation = np.array([0.0, 0.0, 0.0, 1.0])\n        self.current_joint_positions = [0.0] * len(self.joint_names)\n        self.current_joint_velocities = [0.0] * len(self.joint_names)\n        self.joint_state_received = False\n        self.publisher = self.create_publisher(\n            JointTrajectory,\n            '/joint_trajectory_controller/joint_trajectory',\n            10\n        )\n        self.joint_state_subscriber = self.create_subscription(\n            JointState,\n            '/joint_states',\n            self.joint_state_callback,\n            10\n        )\n        self.gripper_client = ActionClient(self, GripperCommand, '/robotiq_gripper_controller/gripper_cmd')\n        self.get_logger().info(\"Waiting for joint_trajectory_controller...\")\n        self.timer = self.create_timer(0.1, self.check_and_send)\n        self.tf_timer = self.create_timer(0.05, self.update_transforms)\n\n    def joint_state_callback(self, msg):\n        try:\n            # Only update for joints in self.joint_names (ignore gripper/fingers)\n            for i, joint_name in enumerate(self.joint_names):\n                if joint_name in msg.name:\n                    joint_idx = msg.name.index(joint_name)\n                    self.current_joint_positions[i] = msg.position[joint_idx]\n                    if len(msg.velocity) > joint_idx:\n                        self.current_joint_velocities[i] = msg.velocity[joint_idx]\n            self.joint_state_received = True\n            self.update_full_state()\n        except Exception as e:\n            self.get_logger().warn(f\"Error updating joint state: {e}\")\n\n    def update_transforms(self):\n        try:\n            try:\n                ee_transform = self.tf_buffer.lookup_transform('base_link', 'end_effector_link', rclpy.time.Time())\n                self.gripper_position = np.array([\n                    ee_transform.transform.translation.x,\n                    ee_transform.transform.translation.y,\n                    ee_transform.transform.translation.z\n                ])\n                self.gripper_orientation = np.array([\n                    ee_transform.transform.rotation.x,\n                    ee_transform.transform.rotation.y,\n                    ee_transform.transform.rotation.z,\n                    ee_transform.transform.rotation.w\n                ])\n            except Exception:\n                pass\n            try:\n                obj_transform = self.tf_buffer.lookup_transform('base_link', 'target_object', rclpy.time.Time())\n                self.object_position = np.array([\n                    obj_transform.transform.translation.x,\n                    obj_transform.transform.translation.y,\n                    obj_transform.transform.translation.z\n                ])\n                self.object_orientation = np.array([\n                    obj_transform.transform.rotation.x,\n                    obj_transform.transform.rotation.y,\n                    obj_transform.transform.rotation.z,\n                    obj_transform.transform.rotation.w\n                ])\n            except Exception:\n                pass\n        except Exception as e:\n            self.get_logger().debug(f\"TF lookup failed: {e}\")\n\n    def update_full_state(self):\n        try:\n            # Compose the 57-dim state vector in the correct order\n            joint_pos = np.array(self.current_joint_positions[:6])  # (6,)\n            joint_pos_cos = np.cos(joint_pos)  # (6,)\n            joint_pos_sin = np.sin(joint_pos)  # (6,)\n            joint_vel = np.array(self.current_joint_velocities[:6])  # (6,)\n            ee_pos = self.gripper_position[:3]  # (3,)\n            ee_quat = self.gripper_orientation[:4]  # (4,)\n            ee_quat_site = np.zeros(4)  # (4,) placeholder, update if available\n            gripper_qpos = np.zeros(6)  # (6,) placeholder, update if available\n            gripper_qvel = np.zeros(6)  # (6,) placeholder, update if available\n            cube_pos = self.object_position[:3]  # (3,)\n            cube_quat = self.object_orientation[:4]  # (4,)\n            gripper_to_cube_pos = cube_pos - ee_pos  # (3,)\n\n            state = np.concatenate([\n                joint_pos,            # [0:6]\n                joint_pos_cos,        # [6:12]\n                joint_pos_sin,        # [12:18]\n                joint_vel,            # [18:24]\n                ee_pos,               # [24:27]\n                ee_quat,              # [27:31]\n                ee_quat_site,         # [31:35] (placeholder)\n                gripper_qpos,         # [35:41] (placeholder)\n                gripper_qvel,         # [41:47] (placeholder)\n                cube_pos,             # [47:50]\n                cube_quat,            # [50:54]\n                gripper_to_cube_pos   # [54:57]\n            ])\n            self.current_state = state\n            if hasattr(self, '_state_debug_count'):\n                self._state_debug_count += 1\n            else:\n                self._state_debug_count = 1\n            if self._state_debug_count <= 3:\n                self.get_logger().info(f\"State reconstruction (call {self._state_debug_count}):\")\n                self.get_logger().info(f\"  First 10 state values: {self.current_state[:10]}\")\n                self.get_logger().info(f\"  Total state dim: {len(self.current_state)}\")\n        except Exception as e:\n            self.get_logger().warn(f\"Error updating full state: {e}\")\n            self.current_state = np.zeros(57)\n\n    def set_target_object_position(self, x, y, z, qx=0.0, qy=0.0, qz=0.0, qw=1.0):\n        self.object_position = np.array([x, y, z])\n        self.object_orientation = np.array([qx, qy, qz, qw])\n        self.get_logger().info(f\"Target object position set to: [{x:.3f}, {y:.3f}, {z:.3f}]\")\n\n    def check_and_send(self):\n        if self.publisher.get_subscription_count() > 0:\n            self.get_logger().info(\"Controller detected! Starting RL-based control...\")\n            self.timer.cancel()\n            self.control_timer = self.create_timer(0.1, self.rl_control_step)\n\n    def rl_control_step(self):\n        try:\n            if not self.joint_state_received:\n                self.get_logger().warn(\"No joint state received yet, skipping control step.\")\n                return\n            if self.agent is not None:\n                full_action = self.agent.select_action(self.current_state)\n                pose_deltas = full_action[:6]\n                gripper_action = full_action[6]\n                max_translation = 0.05\n                max_rotation = 0.5\n                pos_deltas = pose_deltas[:3] * max_translation\n                rot_deltas = pose_deltas[3:] * max_rotation\n                target_pos = self.gripper_position + pos_deltas\n                current_euler = self.quaternion_to_euler(self.gripper_orientation)\n                target_euler = current_euler + rot_deltas\n                target_quat = self.euler_to_quaternion(target_euler)\n                self.get_logger().info(f\"RL Action - Pose Δ: {pos_deltas} | Rot Δ: {rot_deltas} | Gripper: {gripper_action:.3f}\")\n                # Use MoveIt for proper inverse kinematics\n                self.send_pose_with_moveit(target_pos, target_quat)\n                self.send_gripper_command_from_rl(gripper_action)\n        except Exception as e:\n            self.get_logger().error(f\"Error in RL control step: {e}\")\n\n    def send_gripper_command_from_rl(self, gripper_action):\n        try:\n            gripper_position = 0.35 * (gripper_action + 1)\n            goal_msg = GripperCommand.Goal()\n            goal_msg.command.position = gripper_position\n            goal_msg.command.max_effort = 0.0\n            if self.gripper_client.server_is_ready():\n                self.gripper_client.send_goal_async(goal_msg)\n                self.get_logger().info(f\"RL Gripper command: action={gripper_action:.3f} -> position={gripper_position:.3f}\")\n            else:\n                self.get_logger().warn(\"Gripper action server not ready\")\n        except Exception as e:\n            self.get_logger().error(f\"Error sending gripper command: {e}\")\n\n    def send_joint_positions(self, positions, duration_sec=0.1):\n        traj_msg = JointTrajectory()\n        traj_msg.joint_names = self.joint_names\n        point = JointTrajectoryPoint()\n        point.positions = positions\n        point.time_from_start.sec = int(duration_sec)\n        point.time_from_start.nanosec = int((duration_sec % 1) * 1e9)\n        traj_msg.points.append(point)\n        self.publisher.publish(traj_msg)\n\n    def quaternion_to_euler(self, quat):\n        x, y, z, w = quat\n        roll = np.arctan2(2*(w*x + y*z), 1 - 2*(x*x + y*y))\n        pitch = np.arcsin(2*(w*y - z*x))\n        yaw = np.arctan2(2*(w*z + x*y), 1 - 2*(y*y + z*z))\n        return np.array([roll, pitch, yaw])\n\n    def euler_to_quaternion(self, euler):\n        roll, pitch, yaw = euler\n        cy = np.cos(yaw * 0.5)\n        sy = np.sin(yaw * 0.5)\n        cp = np.cos(pitch * 0.5)\n        sp = np.sin(pitch * 0.5)\n        cr = np.cos(roll * 0.5)\n        sr = np.sin(roll * 0.5)\n        w = cr * cp * cy + sr * sp * sy\n        x = sr * cp * cy - cr * sp * sy\n        y = cr * sp * cy + sr * cp * sy\n        z = cr * cp * sy - sr * sp * cy\n        return np.array([x, y, z, w])\n\n    def send_pose_with_moveit(self, target_pos, target_quat):\n        \"\"\"\n        Proper pose control using MoveIt inverse kinematics via /compute_ik service, then execute via MoveIt action server.\n        \"\"\"\n        from moveit_msgs.srv import GetPositionIK\n        from moveit_msgs.msg import PositionIKRequest\n        from geometry_msgs.msg import PoseStamped\n        import builtin_interfaces.msg\n        import rclpy\n        try:\n            # Prepare IK request\n            ik_req = PositionIKRequest()\n            ik_req.group_name = 'manipulator'  # Change if your group is different\n            ik_req.ik_link_name = 'end_effector_link'  # Change if your EE link is different\n            ik_req.pose_stamped = PoseStamped()\n            ik_req.pose_stamped.header.frame_id = 'base_link'\n            ik_req.pose_stamped.header.stamp = self.get_clock().now().to_msg()\n            ik_req.pose_stamped.pose.position.x = float(target_pos[0])\n            ik_req.pose_stamped.pose.position.y = float(target_pos[1])\n            ik_req.pose_stamped.pose.position.z = float(target_pos[2])\n            ik_req.pose_stamped.pose.orientation.x = float(target_quat[0])\n            ik_req.pose_stamped.pose.orientation.y = float(target_quat[1])\n            ik_req.pose_stamped.pose.orientation.z = float(target_quat[2])\n            ik_req.pose_stamped.pose.orientation.w = float(target_quat[3])\n\n            # Create IK service client\n            cli = self.create_client(GetPositionIK, '/compute_ik')\n            if not cli.wait_for_service(timeout_sec=2.0):\n                self.get_logger().error('MoveIt IK service /compute_ik not available!')\n                return\n\n            req = GetPositionIK.Request()\n            req.ik_request = ik_req\n\n            future = cli.call_async(req)\n            rclpy.spin_until_future_complete(self, future, timeout_sec=2.0)\n            if not future.done():\n                self.get_logger().error('IK service call timed out!')\n                return\n            resp = future.result()\n            if resp.error_code.val != 1:\n                self.get_logger().error(f'MoveIt IK failed with code {resp.error_code.val}')\n                return\n            joint_state = resp.solution.joint_state\n            # Map returned joint positions to your joint order\n            joint_positions = [0.0] * len(self.joint_names)\n            for i, name in enumerate(self.joint_names):\n                if name in joint_state.name:\n                    idx = joint_state.name.index(name)\n                    joint_positions[i] = joint_state.position[idx]\n            self.get_logger().info(f\"MoveIt IK solution: {joint_positions}\")\n            # Send trajectory to MoveIt for execution\n            self.send_trajectory_to_moveit(joint_positions)\n        except Exception as e:\n            self.get_logger().error(f\"Error in send_pose_with_moveit: {e}\")\n\n\ndef main():\n    rclpy.init()\n    joint_names = ['joint_1','joint_2','joint_3','joint_4','joint_5','joint_6']\n    actor_model_path = \"/home/max/robosuite_ws/robosuite_training_examples/tmp/kinova_td3/best_actor.pth\"\n    node = JointPublisher(joint_names, actor_model_path)\n    node.set_target_object_position(x=0.3, y=0.1, z=0.1)\n    try:\n        rclpy.spin(node)\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"}\n{"instruction": "Write a ROS2 Python node named moveit_direct_bridge.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "#!/usr/bin/env python3\n\n\"\"\"\nDirect MoveIt Unity Bridge\nUses MoveIt Python API to directly execute planned trajectories\n\"\"\"\n\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState\nfrom std_msgs.msg import Header\nimport threading\nimport time\n\n# MoveIt Python API imports\nfrom moveit_msgs.action import MoveGroup\nfrom rclpy.action import ActionClient\n\nclass DirectMoveItBridge(Node):\n    def __init__(self):\n        super().__init__('direct_moveit_bridge')\n        \n        # Publishers for Unity\n        self.joint_command_pub = self.create_publisher(JointState, '/joint_command', 10)\n        self.trajectory_preview_pub = self.create_publisher(JointState, '/trajectory_preview', 10)\n        \n        # MoveGroup Action Client\n        self.move_group_client = ActionClient(self, MoveGroup, '/move_action')\n        \n        # Joint configuration\n        self.joint_names = ['joint_1', 'joint_2', 'joint_3', 'joint_4', 'joint_5', 'joint_6']\n        \n        self.get_logger().info('Direct MoveIt Unity Bridge initialized')\n        \n        # Wait for MoveGroup action server\n        self.move_group_client.wait_for_server(timeout_sec=10.0)\n        self.get_logger().info('Connected to MoveGroup action server')\n        \n        print(\"\\n🔗 DIRECT MOVEIT BRIDGE\")\n        print(\"This bridge will intercept MoveIt execution requests\")\n        print(\"and forward them directly to Unity\")\n        \n    def create_test_trajectory(self):\n        \"\"\"Create a test trajectory for Unity\"\"\"\n        test_positions = [\n            [0.0, 0.0, 0.0, 0.0, 0.0, 0.0],      # Home\n            [0.3, -0.2, 0.2, 0.0, 0.1, 0.0],     # Position 1  \n            [0.5, -0.4, 0.4, 0.0, 0.2, 0.0],     # Position 2\n            [0.3, -0.6, 0.6, 0.0, 0.3, 0.0],     # Position 3\n            [0.0, -0.5, 0.5, 0.0, 0.0, 0.0],     # Ready\n            [0.0, 0.0, 0.0, 0.0, 0.0, 0.0],      # Back to Home\n        ]\n        \n        self.get_logger().info('🎬 Creating test trajectory preview')\n        \n        # Send trajectory preview waypoints\n        for i, positions in enumerate(test_positions):\n            preview_msg = JointState()\n            preview_msg.header = Header()\n            preview_msg.header.stamp = self.get_clock().now().to_msg()\n            preview_msg.header.frame_id = f'waypoint_{i}'\n            preview_msg.name = self.joint_names\n            preview_msg.position = positions\n            preview_msg.velocity = []\n            preview_msg.effort = []\n            \n            self.trajectory_preview_pub.publish(preview_msg)\n            self.get_logger().info(f'📍 Sent waypoint {i}: {positions}')\n            time.sleep(0.2)\n            \n        self.get_logger().info('✅ Trajectory preview complete - check Unity for waypoints!')\n        \n        # Wait a moment then execute\n        time.sleep(2.0)\n        \n        self.get_logger().info('🚀 Executing trajectory')\n        for i, positions in enumerate(test_positions):\n            command_msg = JointState()\n            command_msg.header = Header()\n            command_msg.header.stamp = self.get_clock().now().to_msg()\n            command_msg.header.frame_id = 'direct_execution'\n            command_msg.name = self.joint_names\n            command_msg.position = positions\n            command_msg.velocity = []\n            command_msg.effort = []\n            \n            self.joint_command_pub.publish(command_msg)\n            self.get_logger().info(f'➡️  Executing waypoint {i}')\n            time.sleep(1.5)\n            \n        self.get_logger().info('🎯 Direct trajectory execution completed!')\n\ndef main():\n    rclpy.init()\n    \n    bridge = DirectMoveItBridge()\n    \n    def run_test():\n        time.sleep(3)  # Wait for initialization\n        print(\"\\n🎭 Running Direct MoveIt Bridge Test\")\n        print(\"This will:\")\n        print(\"1. Show trajectory waypoints in Unity (yellow spheres)\")\n        print(\"2. Execute the trajectory (robot movement)\")\n        bridge.create_test_trajectory()\n        \n        print(\"\\n✨ Test completed!\")\n        print(\"If this works, the ROS-Unity connection is perfect!\")\n    \n    # Run test in background\n    test_thread = threading.Thread(target=run_test, daemon=True)\n    test_thread.start()\n    \n    try:\n        rclpy.spin(bridge)\n    except KeyboardInterrupt:\n        print(\"\\n🛑 Shutting down Direct MoveIt Bridge...\")\n    finally:\n        bridge.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()"}\n{"instruction": "Write a ROS2 Python node named moveit2.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "\"\"\"\nA simple python interface with MoveIt2 services (and actions). This is an alternative to\nmoveit_commander, which is not yet ported to ROS 2 (as of Oct 2020).\nNote: This module is currently configured for Franka Emika Panda robot.\nNote: There is no Ignition-specific code in this module (this repo is just a convinient place).\n\nthe code is from https://github.com/AndrejOrsula/ign_moveit2 ,and is modified.\n\"\"\"\n\nimport threading\n\nimport rclpy\nfrom rclpy.node import Node\nfrom rclpy.action import ActionClient\n\nfrom std_msgs.msg import Float32\nfrom builtin_interfaces.msg import Duration\nfrom geometry_msgs.msg import Pose, Quaternion\nfrom shape_msgs.msg import SolidPrimitive\nfrom sensor_msgs.msg import JointState\nfrom trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint\nfrom moveit_msgs.msg import Constraints, JointConstraint, PositionConstraint, OrientationConstraint\nfrom moveit_msgs.msg import PositionIKRequest, RobotTrajectory\nfrom moveit_msgs.srv import GetPositionIK, GetPositionFK, GetMotionPlan, GetCartesianPath\nfrom moveit_msgs.action import MoveGroup\nfrom action_msgs.msg import GoalStatus\n\n\nclass MoveIt2Interface(Node):\n\n    def __init__(self):\n        super().__init__(\"ign_moveit2_py\")\n        self.init_robot()\n        self.init_compute_fk()\n        self.init_compute_ik()\n        self.init_plan_kinematic_path()\n        self.init_plan_cartesian_path()\n        self.get_logger().info(\"ign_moveit2_py initialised successfuly\")\n\n    def init_robot(self):\n        \"\"\"\n        Initialise robot groups, links and joints. This would normally get loaded from URDF via\n        `moveit_commander`.\n        This also initialises subscriber to joint states and publisher to joint trajectories.\n        \"\"\"\n        self.robot_group_name = \"ur10\"\n        # Arm\n        self.arm_group_name = \"manipulator\"\n        self.arm_joints = [\"shoulder_pan_joint\",\n                           \"shoulder_lift_joint\",\n                           \"elbow_joint\",\n                           \"wrist_1_joint\",\n                           \"wrist_2_joint\",\n                           \"wrist_3_joint\"]\n        self.arm_links = [\"base_link\",\n                          \"shoulder_link\",\n                          \"upper_arm_link\",\n                          \"forearm_link\",\n                          \"wrist_1_link\",\n                          \"wrist_2_link\",\n                          \"wrist_3_link\",\n                          \"ee_link\"]\n        self.arm_base_link = self.arm_links[0]\n        self.arm_end_effector = self.arm_links[-1]\n\n        # Publisher of trajectories\n        self.joint_trajectory_pub = self.create_publisher(JointTrajectory,\n                                                          \"set_joint_trajectory\", 1)\n\n        # Subscriber of current joint states\n        self.joint_state = JointState()\n        self.joint_state_mutex = threading.Lock()\n        self.joint_state_sub = self.create_subscription(JointState,\n                                                        \"joint_states\",\n                                                        self.joint_state_callback, 1)\n\n        # Subscriber of joint trajectory progress\n        self.joint_progress = 1.0\n        self.joint_progress_cond = threading.Condition()\n        self.joint_progress_sub = self.create_subscription(Float32,\n                                                           \"joint_trajectory_progress\",\n                                                           self.joint_progress_callback, 1)\n\n    def joint_state_callback(self, msg):\n        \"\"\"\n        Callback for getting current joint states.\n        \"\"\"\n        self.joint_state_mutex.acquire()\n        self.joint_state = msg\n        self.joint_state_mutex.release()\n\n    def get_joint_state(self) -> JointState:\n        \"\"\"\n        Get current joint states.\n        \"\"\"\n        self.joint_state_mutex.acquire()\n        joint_state = self.joint_state\n        self.joint_state_mutex.release()\n        return joint_state\n\n    def joint_progress_callback(self, msg):\n        \"\"\"\n        Callback for getting joint trajectory progress.\n        \"\"\"\n        with self.joint_progress_cond:\n            self.joint_progress = msg.data\n            self.joint_progress_cond.notify_all()\n\n    def wait_until_executed(self):\n        \"\"\"\n        Function that halts execution on the current thread until trajectory is executed.\n        \"\"\"\n        with self.joint_progress_cond:\n            while not self.joint_progress == 1.0:\n                self.joint_progress_cond.wait(timeout=0.5)\n\n    def pub_trajectory(self, trajectory):\n        \"\"\"\n        Publish trajectory such that it can be executed, e.g. by `JointTrajectoryController`\n        Ignition plugin.\n        \"\"\"\n        if isinstance(trajectory, JointTrajectory):\n            self.joint_trajectory_pub.publish(trajectory)\n            self.get_logger().info(\"pub trajectory msg!\")\n        elif isinstance(trajectory, RobotTrajectory):\n            self.joint_trajectory_pub.publish(trajectory.joint_trajectory)\n        else:\n            raise Exception(\"Invalid type passed into pub_trajectory()\")\n\n    def execute(self, joint_trajectory=None) -> bool:\n        \"\"\"\n        Execute last planned motion plan, or the `joint_trajectory` specified as argument.\n        \"\"\"\n\n        if joint_trajectory == None:\n            plan = self.motion_plan_.joint_trajectory\n        else:\n            plan = joint_trajectory\n\n        # Make sure there is a plan to follow\n        if not plan.points:\n            self.get_logger().warn(\n                \"Cannot execute motion plan because it does not contain any trajectory points\")\n            return False\n\n        # Reset joint progress\n        self.joint_progress = 0.0\n\n        self.pub_trajectory(plan)\n        return True\n\n    def move_to_joint_state(self, joint_state,\n                            set_position=True,\n                            set_velocity=True,\n                            set_effort=True):\n        \"\"\"\n        Set joint target on all joints defined in `joint_state`. This function does NOT plan a\n        smooth trajectory and only publishes joint_state as the next goal that should be reached\n        immediately.\n        \"\"\"\n        joint_trajectory = JointTrajectory()\n        joint_trajectory.joint_names = joint_state.name\n\n        point = JointTrajectoryPoint()\n        if set_position:\n            point.positions = joint_state.position\n        if set_velocity:\n            point.velocities = joint_state.velocity\n        if set_effort:\n            point.effort = joint_state.effort\n        joint_trajectory.points.append(point)\n\n        self.pub_trajectory(joint_trajectory)\n\n    # compute_fk\n    def init_compute_fk(self):\n        \"\"\"\n        Initialise `compute_fk` service.\n        \"\"\"\n        self.compute_fk_client = self.create_client(GetPositionFK,\n                                                    \"compute_fk\")\n        while not self.compute_fk_client.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info(\n                \"Service [compute_fk] not currently available, waiting...\")\n\n        self.fk_request = GetPositionFK.Request()\n        self.fk_request.header.frame_id = self.arm_base_link\n        # self.fk_request.header.stamp = \"Set during request\"\n        # self.fk_request.fk_link_names = \"Set during request\"\n        # self.fk_request.robot_state.joint_state = \"Set during request\"\n        # self.fk_request.robot_state.multi_dof_joint_state = \"Ignored\"\n        # self.fk_request.robot_state.attached_collision_objects = \"Ignored\"\n        self.fk_request.robot_state.is_diff = False\n\n    def compute_fk(self, fk_link_names=None, joint_state=None) -> GetPositionFK.Response:\n        \"\"\"\n        Call `compute_fk` service.\n        \"\"\"\n        if fk_link_names == None:\n            self.fk_request.fk_link_names = [self.arm_end_effector]\n        else:\n            self.fk_request.fk_link_names = fk_link_names\n\n        if joint_state == None:\n            self.fk_request.robot_state.joint_state = self.get_joint_state()\n        else:\n            self.fk_request.robot_state.joint_state = joint_state\n\n        self.fk_request.header.stamp = self._clock.now().to_msg()\n\n        self.compute_fk_client.wait_for_service()\n        return self.compute_fk_client.call(self.fk_request)\n\n    # compute_ik\n    def init_compute_ik(self):\n        \"\"\"\n        Initialise `compute_ik` service.\n        \"\"\"\n        # Service client for IK\n        self.compute_ik_client = self.create_client(GetPositionIK,\n                                                    \"compute_ik\")\n        while not self.compute_ik_client.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info(\n                \"Service [compute_ik] not currently available, waiting...\")\n\n        self.ik_request = GetPositionIK.Request()\n        self.ik_request.ik_request.group_name = self.arm_group_name\n        # self.ik_request.ik_request.robot_state.joint_state = \"Set during request\"\n        # self.ik_request.ik_request.robot_state.multi_dof_joint_state = \"Ignored\"\n        # self.ik_request.ik_request.robot_state.attached_collision_objects = \"Ignored\"\n        self.ik_request.ik_request.robot_state.is_diff = False\n        # self.ik_request.ik_request.constraints = \"Set during request OR Ignored\"\n        self.ik_request.ik_request.avoid_collisions = True\n        # self.ik_request.ik_request.ik_link_name = \"Ignored\"\n        self.ik_request.ik_request.pose_stamped.header.frame_id = self.arm_base_link\n        # self.ik_request.ik_request.pose_stamped.header.stamp = \"Set during request\"\n        # self.ik_request.ik_request.pose_stamped.pose = \"Set during request\"\n        # self.ik_request.ik_request.ik_link_names = \"Ignored\"\n        # self.ik_request.ik_request.pose_stamped_vector = \"Ignored\"\n        # self.ik_request.ik_request.timeout.sec = \"Ignored\"\n        # self.ik_request.ik_request.timeout.nanosec = \"Ignored\"\n\n    def compute_ik(self, pose, start_joint_state=None, constrains=None) -> GetPositionIK.Response:\n        \"\"\"\n        Call `compute_ik` service.\n        \"\"\"\n        if start_joint_state == None:\n            self.ik_request.ik_request.robot_state.joint_state = self.get_joint_state()\n        else:\n            self.ik_request.ik_request.robot_state.joint_state = start_joint_state\n\n        if constrains != None:\n            self.ik_request.ik_request.constraints = constrains\n\n        self.ik_request.ik_request.pose_stamped.pose = pose\n\n        self.ik_request.ik_request.pose_stamped.header.stamp = self._clock.now().to_msg()\n\n        self.compute_ik_client.wait_for_service()\n        return self.compute_ik_client.call(self.ik_request)\n\n    # plan_kinematic_path\n    def init_plan_kinematic_path(self):\n        \"\"\"\n        Initialise `plan_kinematic_path` service.\n        \"\"\"\n        # Service client for IK\n        self.plan_kinematic_path_client = self.create_client(GetMotionPlan,\n                                                             \"plan_kinematic_path\")\n        while not self.plan_kinematic_path_client.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info(\n                \"Service [plan_kinematic_path] not currently available, waiting...\")\n\n        self.kinematic_path_request = GetMotionPlan.Request()\n        self.kinematic_path_request.motion_plan_request.workspace_parameters.header.frame_id = \\\n            self.arm_base_link\n        # self.kinematic_path_request.motion_plan_request.workspace_parameters.header.stamp = \\\n        # \"Set during request\"\n        self.kinematic_path_request.motion_plan_request.workspace_parameters.min_corner.x = -0.855\n        self.kinematic_path_request.motion_plan_request.workspace_parameters.min_corner.y = -0.855\n        self.kinematic_path_request.motion_plan_request.workspace_parameters.min_corner.z = -0.36\n        self.kinematic_path_request.motion_plan_request.workspace_parameters.max_corner.x = 0.855\n        self.kinematic_path_request.motion_plan_request.workspace_parameters.max_corner.y = 0.855\n        self.kinematic_path_request.motion_plan_request.workspace_parameters.max_corner.z = 1.19\n        # self.kinematic_path_request.motion_plan_request.start_state = \"Ignored\"\n        self.kinematic_path_request.motion_plan_request.goal_constraints = \\\n            [Constraints()]\n        # self.kinematic_path_request.motion_plan_request.path_constraints = \"Ignored\"\n        # self.kinematic_path_request.motion_plan_request.trajectory_constraints = \"Ignored\"\n        # self.kinematic_path_request.motion_plan_request.reference_trajectories = \"Ignored\"\n        # self.kinematic_path_request.motion_plan_request.planner_id = \"Ignored\"\n        self.kinematic_path_request.motion_plan_request.group_name = self.arm_group_name\n        # self.kinematic_path_request.motion_plan_request.num_planning_attempts = \\\n        # \"Set during request\"\n        # self.kinematic_path_request.motion_plan_request.allowed_planning_time = \\\n        # \"Set during request\"\n        self.kinematic_path_request.motion_plan_request.max_velocity_scaling_factor = 0.0\n        self.kinematic_path_request.motion_plan_request.max_acceleration_scaling_factor = 0.0\n        self.kinematic_path_request.motion_plan_request.cartesian_speed_end_effector_link = \\\n            self.arm_end_effector\n        self.kinematic_path_request.motion_plan_request.max_cartesian_speed = 0.0\n\n    def set_max_velocity(self, scaling_factor):\n        \"\"\"\n        Set maximum velocity of joints as a factor of joint limits.\n        \"\"\"\n        self.kinematic_path_request.motion_plan_request.max_velocity_scaling_factor = scaling_factor\n\n    def set_max_acceleration(self, scaling_factor):\n        \"\"\"\n        Set maximum acceleration of joints as a factor of joint limits.\n        \"\"\"\n        self.kinematic_path_request.motion_plan_request.max_acceleration_scaling_factor = \\\n            scaling_factor\n\n    def set_max_cartesian_speed(self, speed):\n        \"\"\"\n        Set maximum cartesian speed of end effector.\n        \"\"\"\n        self.kinematic_path_request.motion_plan_request.max_cartesian_speed = speed\n\n    def plan_kinematic_path(self,\n                            allowed_planning_time=5.0,\n                            num_planning_attempts=10) -> GetMotionPlan.Response:\n        \"\"\"\n        Call `plan_kinematic_path` service, with goal set using either `set_joint_goal()`,\n        `set_position_goal()`, `set_orientation_goal()` or `set_pose_goal()`.\n        \"\"\"\n\n        self.kinematic_path_request.motion_plan_request.num_planning_attempts = \\\n            num_planning_attempts\n        self.kinematic_path_request.motion_plan_request.allowed_planning_time = \\\n            allowed_planning_time\n\n        self.kinematic_path_request.motion_plan_request.workspace_parameters.header.stamp = \\\n            self._clock.now().to_msg()\n\n        # Stamp message with current time\n        clock_time_now_msg = self._clock.now().to_msg()\n        self.kinematic_path_request.motion_plan_request.workspace_parameters.header.stamp = \\\n            clock_time_now_msg\n        for contraints in self.kinematic_path_request.motion_plan_request.goal_constraints:\n            for position_constraint in contraints.position_constraints:\n                position_constraint.header.stamp = clock_time_now_msg\n            for orientation_constraint in contraints.orientation_constraints:\n                orientation_constraint.header.stamp = clock_time_now_msg\n\n        self.plan_kinematic_path_client.wait_for_service()\n        response = self.plan_kinematic_path_client.call(\n            self.kinematic_path_request)\n\n        self.clear_goal_constraints()\n        self.motion_plan_ = response.motion_plan_response.trajectory\n\n        return response\n\n    def clear_goal_constraints(self):\n        \"\"\"\n        Clear all goal constraints that were previously set.\n        Note that this function is called automatically after each `plan_kinematic_path()`.\n        \"\"\"\n        self.kinematic_path_request.motion_plan_request.goal_constraints = \\\n            [Constraints()]\n\n    def create_new_goal_constraint(self):\n        \"\"\"\n        Create a new set of goal contraints that will be set together with the request. Each\n        subsequent setting of goals with `set_joint_goal()`, `set_pose_goal()` and others will be\n        added under this newly created set of contraints.\n        \"\"\"\n        (self.kinematic_path_request.motion_plan_request.goal_constraints\n         .append(Constraints()))\n\n    def set_joint_goal(self, joint_positions, tolerance=0.001, weight=1.0, joint_names=None):\n        \"\"\"\n        Set goal position in joint space. With `joint_names` specified, `joint_positions` can be\n        defined for specific joints. Otherwise, first `n` joints defined in `init_robot()` will be\n        used, where `n` is the length of `joint_positions`.\n        \"\"\"\n        if joint_names == None:\n            joint_names = self.arm_joints\n\n        for i in range(len(joint_positions)):\n            joint_constraint = JointConstraint()\n            joint_constraint.joint_name = joint_names[i]\n            joint_constraint.position = joint_positions[i]\n            joint_constraint.tolerance_above = tolerance\n            joint_constraint.tolerance_below = tolerance\n            joint_constraint.weight = weight\n\n            (self.kinematic_path_request.motion_plan_request.goal_constraints[-1].\n             joint_constraints.append(joint_constraint))\n\n    def set_position_goal(self, position, tolerance=0.001, weight=1.0, frame=None):\n        \"\"\"\n        Set goal position of `frame` in Cartesian space. Defaults to the end-effector `frame`.\n        \"\"\"\n        if frame == None:\n            frame = self.arm_base_link\n\n        position_constraint = PositionConstraint()\n        position_constraint.header.frame_id = frame\n        position_constraint.link_name = self.arm_end_effector\n        position_constraint.constraint_region.primitive_poses.append(Pose())\n        position_constraint.constraint_region.primitive_poses[0].position.x = position[0]\n        position_constraint.constraint_region.primitive_poses[0].position.y = position[1]\n        position_constraint.constraint_region.primitive_poses[0].position.z = position[2]\n\n        # Goal is defined as a sphere with radius equal to tolerance\n        position_constraint.constraint_region.primitives.append(\n            SolidPrimitive())\n        position_constraint.constraint_region.primitives[0].type = 2\n        position_constraint.constraint_region.primitives[0].dimensions = [\n            tolerance]\n        position_constraint.weight = weight\n\n        (self.kinematic_path_request.motion_plan_request.goal_constraints[-1].position_constraints\n         .append(position_constraint))\n\n    def set_orientation_goal(self, quaternion, tolerance=0.001, weight=1.0, frame=None):\n        \"\"\"\n        Set goal orientation of `frame`. Defaults to the end-effector `frame`.\n        \"\"\"\n        if frame == None:\n            frame = self.arm_end_effector\n\n        orientation_constraint = OrientationConstraint()\n        orientation_constraint.header.frame_id = self.arm_base_link\n        orientation_constraint.link_name = frame\n        orientation_constraint.orientation = quaternion\n        orientation_constraint.absolute_x_axis_tolerance = tolerance\n        orientation_constraint.absolute_y_axis_tolerance = tolerance\n        orientation_constraint.absolute_z_axis_tolerance = tolerance\n        orientation_constraint.weight = weight\n\n        (self.kinematic_path_request.motion_plan_request.goal_constraints[-1]\n         .orientation_constraints.append(orientation_constraint))\n\n    def set_pose_goal(self, position, quaternion,\n                      tolerance_position=0.001, tolerance_orientation=0.001,\n                      weight_position=1.0, weight_orientation=1.0,\n                      frame=None):\n        \"\"\"\n        Set goal pose. This is direct combination of `set_position_goal()` and\n        `set_orientation_goal()`.\n        \"\"\"\n        self.set_position_goal(\n            position, tolerance_position, weight_position, frame)\n        self.set_orientation_goal(\n            quaternion, tolerance_orientation, weight_orientation, frame)\n\n    # plan_cartesian_path\n    def init_plan_cartesian_path(self):\n        \"\"\"\n        Initialise `compute_cartesian_path` service.\n        \"\"\"\n        # TODO\n        pass\n\n    def plan_cartesian_path(self, pose,\n                            start_joint_state=None,\n                            constrains=None) -> GetCartesianPath.Response:\n        \"\"\"\n        Call `compute_cartesian_path` service.\n        \"\"\"\n        # TODO\n        pass\n"}\n{"instruction": "Write a ROS2 Python node named waypoint_service_moveit.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "\n\"\"\"\n# Custom parameters\npython3 waypoint_service_moveit.py --file setd.json --eef-step 0.01 --min-fraction 0.8 --timeout 45\n\"\"\"\n\nimport rclpy\nfrom rclpy.node import Node\nfrom rclpy.action import ActionClient\nimport json\nimport time\nimport math\nimport argparse\nfrom typing import List, Optional\nfrom geometry_msgs.msg import Pose, PoseStamped\nfrom moveit_msgs.srv import GetCartesianPath, GetMotionPlan\nfrom moveit_msgs.msg import RobotTrajectory, MoveItErrorCodes, MotionPlanRequest, PlanningOptions\nfrom control_msgs.action import FollowJointTrajectory\nfrom sensor_msgs.msg import JointState\nfrom std_msgs.msg import UInt8, Header\nfrom trajectory_msgs.msg import JointTrajectory\n\ndef rotvec_to_quat(rx, ry, rz):\n    angle = math.sqrt(rx*rx + ry*ry + rz*rz)\n    if angle < 1e-12:\n        return (0.0, 0.0, 0.0, 1.0)\n    ax, ay, az = rx/angle, ry/angle, rz/angle\n    s = math.sin(angle/2.0)\n    return (ax*s, ay*s, az*s, math.cos(angle/2.0))\n\nclass ServiceBasedMoveIt(Node):\n    GLOBAL_Z_OFFSET = 0\n    \n    def __init__(self):\n        super().__init__('service_based_moveit')\n        self.cartesian_path_client = self.create_client(GetCartesianPath, '/compute_cartesian_path')\n        self.motion_plan_client = self.create_client(GetMotionPlan, '/plan_kinematic_path')\n        self.trajectory_client = ActionClient(self, FollowJointTrajectory, \n                                              '/scaled_joint_trajectory_controller/follow_joint_trajectory')\n        self.joint_state_sub = self.create_subscription(JointState, '/joint_states', self.joint_state_cb, 10)\n        self.gripper_pub = self.create_publisher(UInt8, '/lebai_gripper/cmd/position', 10)\n        self.current_joint_state = None\n        self.joint_names = ['shoulder_pan_joint', 'shoulder_lift_joint', 'elbow_joint',\n                           'wrist_1_joint', 'wrist_2_joint', 'wrist_3_joint']\n\n    def joint_state_cb(self, msg):\n        self.current_joint_state = msg\n\n    def wait_for_services(self, timeout=10.0):\n        \n        if not self.cartesian_path_client.wait_for_service(timeout_sec=timeout):\n        \n            return False\n            \n        if not self.motion_plan_client.wait_for_service(timeout_sec=timeout):\n            return False\n            \n        if not self.trajectory_client.wait_for_server(timeout_sec=timeout):\n            return False\n            \n        start = time.time()\n        while self.current_joint_state is None and (time.time() - start) < timeout:\n            rclpy.spin_once(self, timeout_sec=0.1)\n            \n        if self.current_joint_state is None:\n            return False\n            \n        return True\n\n    def create_pose_from_array(self, pose_array):\n        x, y, z, rx, ry, rz = pose_array\n        qx, qy, qz, qw = rotvec_to_quat(rx, ry, rz)\n        z_offset = self.GLOBAL_Z_OFFSET  \n        pose = Pose()\n        pose.position.x = x\n        pose.position.y = y  \n        pose.position.z = z + z_offset\n        pose.orientation.x = qx\n        pose.orientation.y = qy\n        pose.orientation.z = qz\n        pose.orientation.w = qw\n        return pose\n\n    def plan_cartesian_path(self, waypoints, eef_step=0.01, min_fraction=0.8):\n        request = GetCartesianPath.Request()\n        request.header.frame_id = \"base_link\"\n        request.header.stamp = self.get_clock().now().to_msg()\n        request.waypoints = [self.create_pose_from_array(wp['pose']) for wp in waypoints]\n        request.max_step = eef_step\n        request.jump_threshold = 2.0\n        request.group_name = \"ur_manipulator\"\n        request.link_name = \"tool0\" \n        if self.current_joint_state:\n            request.start_state.joint_state = self.current_joint_state\n            print(f\"Using current joint state with {len(self.current_joint_state.position)} joints\")\n        else:\n            print(\"WARNING: No current joint state \")\n        \n        future = self.cartesian_path_client.call_async(request)\n        rclpy.spin_until_future_complete(self, future)\n        \n        if future.result() is not None:\n            response = future.result()\n            if response.error_code.val == MoveItErrorCodes.SUCCESS:\n                return response.solution, response.fraction\n            else:\n                print(f\"Failed: {response.error_code.val}\")\n                return None, 0.0\n        else:\n            return None, 0.0\n\n    def scale_trajectory_velocity(self, trajectory, velocity_scale=0.1):\n        if not trajectory.joint_trajectory.points:\n            return trajectory\n        for point in trajectory.joint_trajectory.points:\n            # Scale velocities if they exist\n            if point.velocities:\n                point.velocities = [v * velocity_scale for v in point.velocities]\n        \n            if point.accelerations:\n                point.accelerations = [a * velocity_scale * velocity_scale for a in point.accelerations]\n        \n            total_time_ns = point.time_from_start.sec * 1e9 + point.time_from_start.nanosec\n            scaled_time_ns = int(total_time_ns / velocity_scale)\n            point.time_from_start.sec = int(scaled_time_ns // 1e9)\n            point.time_from_start.nanosec = int(scaled_time_ns % 1e9)\n            \n        return trajectory\n\n    def execute_trajectory(self, trajectory, timeout=30.0, velocity_scale=0.1):\n        if not trajectory.joint_trajectory.points:\n            print(\"Empty trajectory, nothing to execute\")\n            return False\n            \n        trajectory = self.scale_trajectory_velocity(trajectory, velocity_scale)\n        print(f\"Executing trajectory with {len(trajectory.joint_trajectory.points)} points at {velocity_scale*100}% speed...\")\n        \n        if not self.trajectory_client.wait_for_server(timeout_sec=5.0):\n            return False\n        \n        goal = FollowJointTrajectory.Goal()\n        goal.trajectory = trajectory.joint_trajectory\n        \n        goal_future = self.trajectory_client.send_goal_async(goal)\n        \n        try:\n            start_time = time.time()\n            while not goal_future.done():\n                rclpy.spin_once(self, timeout_sec=0.1)\n                if time.time() - start_time > 5.0:  # 5 second timeout for goal acceptance\n                    print(\"Timeout waiting for goal acceptance\")\n                    return False\n            \n            goal_handle = goal_future.result()\n            if not goal_handle.accepted:\n                print(\"Goal rejected by action server\")\n                return False\n                \n        \n            result_future = goal_handle.get_result_async()\n            start_time = time.time()\n            while not result_future.done():\n                rclpy.spin_once(self, timeout_sec=0.1)\n                if time.time() - start_time > timeout:\n                    print(f\"Timeout{timeout}\")\n                    goal_handle.cancel_goal_async()\n                    return False\n            \n            result = result_future.result()\n            if result.result.error_code == FollowJointTrajectory.Result.SUCCESSFUL:\n                return True\n            else:\n                return False\n                \n        except KeyboardInterrupt:\n            return False\n        except Exception as e:\n            return False\n\n    def set_gripper(self, value):\n        msg = UInt8()\n        msg.data = max(0, min(100, value))\n        self.gripper_pub.publish(msg)\n        time.sleep(0.3)\n\n    def execute_waypoints(self, waypoints: List[dict], eef_step=0.005, min_fraction=0.8, timeout=30.0, velocity_scale=0.1):\n        for i, waypoint in enumerate(waypoints):\n            single_waypoint = [waypoint]\n            trajectory, fraction = self.plan_cartesian_path(single_waypoint, eef_step, min_fraction)\n            \n            if not trajectory:\n                return False\n                \n            print(f\"Planned trajectory covers {fraction*100:.2f}% of path\")\n            if fraction < min_fraction:\n                print(f\"Path coverage {fraction*100:.2f}% below {min_fraction*100:.2f}%\")\n                return False\n            \n            success = self.execute_trajectory(trajectory, timeout, velocity_scale)\n            if not success:\n                return False\n            \n            if 'gripper' in waypoint:\n                self.set_gripper(waypoint['gripper'])\n                time.sleep(0.5) \n            \n            if 'wait_time' in waypoint and waypoint['wait_time'] > 0:\n                time.sleep(waypoint['wait_time'])\n        return True\n\ndef update_dynamic_coordinates(waypoints_data, target_x, target_y):\n    dynamic_waypoint_names = [\"get_x_y\", \"x_y_down\", \"x_y_close_half\", \"x_y_closed\", \"x_y_up\", \"x_y_up_2\"]\n    \n    updated_count = 0\n    for waypoint in waypoints_data.get('waypoints', []):\n        if waypoint.get('name') in dynamic_waypoint_names:\n            old_x, old_y = waypoint['pose'][0], waypoint['pose'][1]\n            waypoint['pose'][0] = target_x\n            waypoint['pose'][1] = target_y\n            updated_count += 1\n            print(f\"  Updated {waypoint['name']}: ({old_x:.4f}, {old_y:.4f}) → ({target_x:.4f}, {target_y:.4f})\")\n    \n    return updated_count\n\ndef load_and_update_waypoints(filename):\n    try:\n        if filename.startswith('sete') or filename.startswith('setf') or filename.startswith('seth'): #------------------------include sets\n            import sys\n            import os\n            sys.path.append(os.path.dirname(os.path.abspath(__file__)))\n            from get_coordinates import get_target_coordinates\n            \n            target_x, target_y = get_target_coordinates()\n            print(f\"Dynamic coordinates from get_coordinates.py: X={target_x:.4f}, Y={target_y:.4f}\")\n            with open(filename, 'r') as f:\n                waypoints_data = json.load(f)\n            updated_count = update_dynamic_coordinates(waypoints_data, target_x, target_y)\n            \n            if updated_count > 0:\n                for wp in waypoints_data.get('waypoints', []):\n                    if wp.get('name') in [\"get_x_y\", \"x_y_down\", \"x_y_close_half\", \"x_y_closed\", \"x_y_up\"]:\n                        print(f\"  {wp['name']}: X={wp['pose'][0]:.4f}, Y={wp['pose'][1]:.4f}, Z={wp['pose'][2]:.4f}\")\n                \n                response = input(\"\\nProceed with these coordinates? (y/N): \").strip().lower()\n                if response != 'y':\n                    print(\"Execution cancelled by user\")\n                    return None\n            \n            return waypoints_data\n        else:\n            with open(filename, 'r') as f:\n                return json.load(f)\n                \n    except ImportError:\n        print(\"ERROR: Could not import get_coordinates.py\")\n        return None\n    except FileNotFoundError:\n        print(f\"ERROR: File {filename} not found\")\n        return None\n    except Exception as e:\n        print(f\"ERROR: Failed to load waypoints: {e}\")\n        return None\n\ndef main():\n    parser = argparse.ArgumentParser(description='Execute waypoints using MoveIt services')\n    parser.add_argument('--file', '-f', default='setz.json', \n                        help='Waypoint JSON file to execute (default: setd.json)')\n    parser.add_argument('--eef-step', type=float, default=0.005,\n                        help='End-effector step size for Cartesian planning (default: 0.005)')\n    parser.add_argument('--min-fraction', type=float, default=0.05,\n                        help='Minimum fraction of path that must be planned (default: 0.7)')\n    parser.add_argument('--timeout', type=int, default=30,\n                        help='Execution timeout in seconds (default: 30)')\n    parser.add_argument('--velocity-scale', type=float, default=0.3,\n                        help='Velocity scaling factor for safe execution (default: 0.1)')\n    \n    args = parser.parse_args()\n    \n    rclpy.init()\n    node = ServiceBasedMoveIt()\n    \n    if not node.wait_for_services():\n        print(\"Failed to connect to services\")\n        rclpy.shutdown()\n        return\n        \n    data = load_and_update_waypoints(args.file)\n    if data is None:\n        rclpy.shutdown()\n        return\n        \n    waypoints = data.get('waypoints', [])\n    if len(waypoints) < 2:\n        print(\"Need at least 2 waypoints\")\n        rclpy.shutdown()\n        return\n       \n    for i, wp in enumerate(waypoints):\n        original_z = wp['pose'][2]\n        adjusted_z = original_z + node.GLOBAL_Z_OFFSET\n        print(f\"  Waypoint {i+1}: Z {original_z:.3f}m → {adjusted_z:.3f}m\")\n        \n    success = node.execute_waypoints(waypoints, \n                                    eef_step=args.eef_step, \n                                    min_fraction=args.min_fraction,\n                                    timeout=args.timeout,\n                                    velocity_scale=args.velocity_scale)\n    \n    if success:\n        print(\"Waypoint execution completed\")\n    else:\n        print(\"Waypoint execution failed\")\n        \n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"}\n{"instruction": "Write a ROS2 Python node named moveit_ik_request.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "import rclpy\nfrom rclpy.node import Node\nfrom moveit_msgs.srv import GetPositionIK\nfrom std_srvs.srv import Trigger\nfrom rclpy.executors import MultiThreadedExecutor\nfrom threading import Event\nfrom rclpy.callback_groups import ReentrantCallbackGroup\n\n\nclass IKClient(Node):\n\n    def __init__(self):\n        super().__init__(\"ik_client\")\n        self.service_done_event = Event()\n        self.callback_group = ReentrantCallbackGroup()\n\n        self.client = self.create_client(\n            GetPositionIK, \"compute_ik\", callback_group=self.callback_group\n        )\n        self.trigger_pose = self.create_service(\n            Trigger,\n            \"trigger_pose\",\n            self.trigger_pose_callback,\n            callback_group=self.callback_group,\n        )\n\n    def trigger_pose_callback(self, request, response):\n        if not self.client.wait_for_service(timeout_sec=5.0):\n            self.get_logger().error(\"No action server available\")\n\n        self.service_done_event.clear()\n        event = Event()\n\n        def done_callback(future):\n            nonlocal event\n            event.set()\n\n        reqIK = GetPositionIK.Request()\n        reqIK.ik_request.group_name = (\n            \"ur_manipulator\"  # Set the MoveIt planning group name\n        )\n        reqIK.ik_request.pose_stamped.header.frame_id = (\n            \"\"  # Set the desired frame ID\n        )\n        reqIK.ik_request.pose_stamped.pose.position.x = (\n            0.5  # Set the desired pose position\n        )\n        reqIK.ik_request.pose_stamped.pose.position.y = 0.0\n        reqIK.ik_request.pose_stamped.pose.position.z = 0.3\n        reqIK.ik_request.pose_stamped.pose.orientation.x = (\n            0.0  # Set the desired pose orientation\n        )\n        reqIK.ik_request.pose_stamped.pose.orientation.y = (\n            0.0  # Set the desired pose orientation\n        )\n        reqIK.ik_request.pose_stamped.pose.orientation.z = (\n            0.0  # Set the desired pose orientation\n        )\n        reqIK.ik_request.pose_stamped.pose.orientation.w = (\n            1.0  # Set the desired pose orientation\n        )\n        future = self.client.call_async(reqIK)\n        future.add_done_callback(done_callback)\n        # Wait for action to be done\n        # self.service_done_event.wait()\n        event.wait()\n        res = future.result()\n        response.success = True\n        response.message = f\"{res.solution.joint_state.position}\"\n        return response\n\n    def send_request(self):\n        request = GetPositionIK.Request()\n        request.ik_request.group_name = (\n            \"ur_manipulator\"  # Set the MoveIt planning group name\n        )\n        request.ik_request.pose_stamped.header.frame_id = (\n            \"\"  # Set the desired frame ID\n        )\n        request.ik_request.pose_stamped.pose.position.x = 0.5\n        request.ik_request.pose_stamped.pose.position.y = 0.0\n        request.ik_request.pose_stamped.pose.position.z = 0.3\n        request.ik_request.pose_stamped.pose.orientation.x = 0.0\n        request.ik_request.pose_stamped.pose.orientation.y = 0.0\n        request.ik_request.pose_stamped.pose.orientation.z = 0.0\n        request.ik_request.pose_stamped.pose.orientation.w = 1.0\n\n        self.future = self.client.call_async(request)\n        rclpy.spin_until_future_complete(self, self.future)\n        return self.future.result()\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n    ik_client = IKClient()\n    # ik_client.send_request()\n    # respone = ik_client.send_request()\n    # print(f\"==>> respone: \\n{respone}\")\n\n    # joint1 = respone.solution.joint_state.position[0]\n    # joint2 = respone.solution.joint_state.position[1]\n    # joint3 = respone.solution.joint_state.position[2]\n    # joint4 = respone.solution.joint_state.position[3]\n    # joint5 = respone.solution.joint_state.position[4]\n    # joint6 = respone.solution.joint_state.position[5]\n    # print(f\"Joint Pose = {[joint1, joint2, joint3, joint4, joint5, joint6]}\")\n    executor = MultiThreadedExecutor()\n    rclpy.spin(ik_client, executor)\n    ik_client.destroy_node()\n    rclpy.shutdown()\n\n\nif __name__ == \"__main__\":\n    main()\n"}\n{"instruction": "Write a ROS2 Python node named checker.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "import subprocess as sp\nimport threading\nimport os\nimport pickle\nimport time\nimport math\nimport json\nimport statistics\n\nimport numpy as np\n\nimport constants as c\n\nimport rclpy\nfrom rclpy.node import Node\n\nimport ros_utils\n\n# import checkers\nimport oracles.turtlesim\nimport oracles.turtlebot\nimport oracles.px4\nimport oracles.moveit\nimport oracles.rosidl\n\n\nclass StateMonitorNode(Node):\n    subs = dict()\n    msg_queue = list()\n    rosbag_proc = None\n\n    def __init__(self, fuzzer):\n        super().__init__(\"_checker\")\n\n        self.fuzzer = fuzzer\n\n    def retrieve_states(self, exec_cnt):\n        \"\"\"\n        Retrieve recorded states by re-playing a rosbag file\n        \"\"\"\n        print(\"[checker] retrieving states\")\n\n        watchlist_file = self.fuzzer.config.watchlist\n\n        with open(watchlist_file, \"r\") as fp:\n            data = fp.read()\n\n        self.watchlist = json.loads(data)\n\n        for target_topic in self.watchlist:\n            topic_msg_type = self.watchlist[target_topic]\n            pkg_name = \".\".join(topic_msg_type.split(\"/\")[:-1])\n            module_name = topic_msg_type.split(\"/\")[-1]\n\n            msg_type_class = ros_utils.get_msg_class_from_name(\n                pkg_name.split(\".\")[0], module_name\n            )\n\n            self.subs[target_topic] = self.create_subscription(\n                msg_type_class, target_topic, self.msg_callback, 500\n            )\n\n            print(f\"[state monitor] subscribed to {target_topic}\")\n            time.sleep(1)\n\n        # self.play_rosbag(exec_cnt)\n\n    def msg_callback(self, msg):\n        \"\"\"\n        Generic callback for storing re-played messages of any topic\n        \"\"\"\n\n        self.msg_queue.append(msg)\n\n    def play_rosbag(self, exec_cnt):\n        rosbag_cmd = f\"ros2 bag play states-{exec_cnt}.bag\"\n\n        self.rosbag_proc = sp.Popen(\n            rosbag_cmd, shell=True, stdout=sp.PIPE, stderr=sp.PIPE\n        )\n        print(\"[checker] started ros2 bag play:\", rosbag_cmd)\n\n    def check_rosbag(self):\n        # check if ros2 bag play is still running\n        pass\n\n\ndef group_msgs_by_topic(states):\n    \"\"\"\n    input: queue of messages of various topics\n    output: dictionary mapping each topic to corresponding messages\n    \"\"\"\n\n    topic_to_msg_dict = {}\n    for msg in states:\n        msg_type_name = f\"{msg.__class__.__module__}.{msg.__class__.__name__}\"\n        try:\n            topic_to_msg_dict[msg_type_name].append(msg)\n        except KeyError:\n            topic_to_msg_dict[msg_type_name] = [msg]\n\n    return topic_to_msg_dict\n\n\ndef retrieve_states():\n    state_msgs = pickle.load(open(\"states.pkl\", \"rb\"))\n    print(\"recorded:\", len(state_msgs))\n\n    try:\n        os.remove(\"states.pkl\")\n    except:\n        print(\"[-] cannot remove states file\")\n    # print(\"[monitor] retrieved states\")\n\n    return state_msgs\n\n\ndef run_checks(config, msg_list, state_dict, feedback_list=[]):\n    \"\"\"invoke checks of the oracles defined for each target package\n\n    Parameters\n    ----------\n    config : RuntimeConfig object\n    msg_list : list of messages published\n    state_dict : dict of messages captured by pre-defined state topics\n    feedback_list : list of Feedback objects\n    \"\"\"\n\n    errs = []\n    if config.rospkg == \"turtlesim\":\n        try:\n            pose_list = state_dict[\"/turtle1/pose\"]\n        except KeyError:\n            print(\"[checker] no Pose available\")\n            return errs\n\n        errs = oracles.turtlesim.check(config, msg_list, pose_list, feedback_list)\n\n    elif config.tb3_sitl or config.tb3_hitl:\n        if (\n            \"/imu\" not in state_dict\n            and \"/odom\" not in state_dict\n            and \"/scan_list\" not in state_dict\n        ):\n            print(\"[checker] no state available\")\n            return errs\n\n        errs = oracles.turtlebot.check(config, msg_list, state_dict, feedback_list)\n\n    elif config.px4_sitl:\n        if (\n            \"/ActuatorArmed_PubSubTopic\" not in state_dict\n            and \"/ActuatorOutputs_PubSubTopic\" not in state_dict\n            and \"/BatteryStatus_PubSubTopic\" not in state_dict\n            and \"/SensorAccel_PubSubTopic\" not in state_dict\n            and \"/SensorBaro_PubSubTopic\" not in state_dict\n            and \"/SensorGps_PubSubTopic\" not in state_dict\n            and \"/SensorGyro_PubSubTopic\" not in state_dict\n            and \"/SensorsStatusImu_PubSubTopic\" not in state_dict\n            and \"/SensorCombined_PubSubTopic\" not in state_dict\n            and \"/VehicleOdometry_PubSubTopic\" not in state_dict\n            and \"/VehicleImu_PubSubTopic\" not in state_dict\n            and \"/VehicleGpsPosition_PubSubTopic\" not in state_dict\n            and \"/VehicleLocalPosition_PubSubTopic\" not in state_dict\n            and \"/VehicleGlobalPosition_PubSubTopic\" not in state_dict\n            and \"/VehicleAttitude_PubSubTopic\" not in state_dict\n            and \"/VehicleAcceleration_PubSubTopic\" not in state_dict\n            and \"/VehicleAngularAcceleration_PubSubTopic\" not in state_dict\n            and \"/VehicleAngularVelocity_PubSubTopic\" not in state_dict\n        ):\n            print(\"[checker] no state available\")\n            return errs\n\n        errs = oracles.px4.check(config, msg_list, state_dict, feedback_list)\n\n    elif config.test_moveit:\n        if (\n            \"/joint_states\" not in state_dict\n            and \"/panda_arm_controller/state\" not in state_dict\n            and \"/move_action/_action/status\" not in state_dict\n            and \"/motion_plan_request\" not in state_dict\n        ):\n            print(\"[checker] no state available\")\n            return errs\n\n        errs = oracles.moveit.check(config, msg_list, state_dict, feedback_list)\n\n    elif config.test_rosidl:\n        if len(msg_list) != 1:\n            print(\"[-] msg_list contains more than one message\")\n            exit(1)\n\n        errs = oracles.rosidl.check(config, msg_list, state_dict, feedback_list)\n\n    elif config.test_cli:\n        try:\n            with open(\"out-0\", \"r\") as f:\n                out0 = \"\\n\".join(f.readlines())\n        except:\n            print(\"[checker] out-0 does not exist\")\n            exit(1)\n\n        try:\n            with open(\"out-1\", \"r\") as f:\n                out1 = \"\\n\".join(f.readlines())\n        except:\n            print(\"[checker] out-1 does not exist\")\n            exit(1)\n\n        if out0 != out1:\n            errs = [f\"CLI outputs do not match: {out0} vs {out1}\"]\n\n    # Print result\n    if len(errs) > 0:\n        if len(errs) > 10:\n            print(f\"{c.RED}ERROR DETECTED: {len(errs)}\")\n            for err in list(set(errs))[:10]:\n                print(\"-\", err)\n            print(\"- ...\")\n            print(c.END)\n        else:\n            print(f\"{c.RED}ERROR DETECTED: {len(errs)}\")\n            for err in list(set(errs)):\n                print(\"-\", err)\n            print(c.END)\n\n    return errs\n\n\ndef run_rpt_checks(config, state_dict_list):\n    \"\"\"check if repeated executions over the same messages result in the identical states\"\"\"\n\n    print(\n        f\"[checker] cross-checking states from {len(state_dict_list)} executions\"\n    )\n\n    last_states = dict()\n\n    for state_dict in state_dict_list:\n        for topic in state_dict:\n            last_state = state_dict[topic][-1]\n            if topic not in last_states:\n                last_states[topic] = [last_state]\n            else:\n                last_states[topic].append(last_state)\n\n    errs = []\n\n    for topic in last_states:\n        last_msgs = last_states[topic]\n        num_last_states = len(last_msgs)\n        if num_last_states != len(state_dict_list):\n            errs.append(f\"number of topics do not match: {topic}\")\n\n        # TODO: cross-check messages in last_msgs\n\n    return errs\n\n\nclass APIChecker:\n    def __init__(self, feature, targets, job):\n        self.tracer = \"ltrace\"\n        self.feature = feature\n        self.targets = targets\n        self.job = job\n\n    def config_trace(self):\n        pass\n\n    def get_timestamp(self, filename=\"out\"):\n        if not os.path.isfile(filename):\n            print(f\"[tracer] Cannot find trace file {filename}\")\n            return -1\n\n        with open(filename, \"r\") as fp:\n            out_raw = fp.readlines()\n\n        t0 = -1\n        t1 = 2147483647.0\n        for line in out_raw:\n            if \"time1\" in line:\n                t0 = line.strip().split(\" \")[-1]\n                if \".\" not in t0:\n                    t0 = (\n                        int(t0) / 1000000.0\n                    )  # c++/rust prints us w/o decimal point\n                else:\n                    t0 = float(t0)\n            elif \"time2\" in line:\n                t1 = line.strip().split(\" \")[-1]\n                if \".\" not in t1:\n                    t1 = (\n                        int(t1) / 1000000.0\n                    )  # c++/rust prints us w/o decimal point\n                else:\n                    t1 = float(t1)\n                break\n\n        self.t0 = t0\n        self.t1 = t1\n\n    def parse_trace(self, filename=\"trace\"):\n        if not os.path.isfile(filename):\n            print(f\"[tracer] Cannot find trace file {filename}\")\n            return -1\n\n        func_dict = dict()\n\n        with open(filename, \"r\") as fp:\n            trace_raw = fp.readlines()\n\n        for line in trace_raw:\n            line = line.strip()\n            timestamp = float(line.split(\" \")[0])\n\n            if timestamp < self.t0 or timestamp > self.t1:\n                continue\n\n            if \"<unfinished ...>\" in line:\n                func_name = line.split(\" \")[1].split(\"@\")[0]\n                retval = None\n                if func_name in func_dict:\n                    func_dict[func_name].append([timestamp, retval])\n                else:\n                    func_dict[func_name] = [[timestamp, retval]]\n\n            elif \"<...\" in line and \"resumed>\" in line:\n                func_name = line.split(\" \")[2]\n                retval = line.split(\"= \")[-1]\n\n                if func_name not in func_dict:\n                    print(f\"[tracer] fatal error: {func_name} not seen yet\")\n                    return -1\n\n                # update retval\n                func_dict[func_name][-1][1] = retval\n\n            elif \".so\" in line:\n                func_name = line.split(\" \")[1].split(\"@\")[0]\n                retval = line.split(\"= \")[-1]\n\n                if func_name in func_dict:\n                    func_dict[func_name].append([timestamp, retval])\n                else:\n                    func_dict[func_name] = [[timestamp, retval]]\n\n        # print(func_dict)\n        return func_dict\n\n    def check_deviant(self):\n        print(\"[API checker] Checking deviant API behavior\")\n        target_trace_map = dict()\n\n        for i, target in enumerate(self.targets):\n            outfile = f\"out-{i}\"\n            tracefile = f\"trace-{i}\"\n            ret = self.get_timestamp(outfile)\n            func_dict = self.parse_trace(tracefile)\n            target_trace_map[target] = func_dict\n\n        # 1. check if each lang calls the same API\n        functions_list = list()\n        target_list = target_trace_map.keys()\n        for target in target_list:\n            func_dict = target_trace_map[target]\n            functions = list(func_dict.keys())\n            functions.sort()\n            functions_list.append(functions)\n\n        if not functions_list.count(functions_list[0]) == len(functions_list):\n            err = \"RCL API discrepancy - called APIs do not match\"\n            for f in functions_list:\n                print(f)\n            return err\n\n        # 2. check retval\n        function_retvals_map = dict()\n        for target in target_list:\n            func_dict = target_trace_map[target]\n            functions = list(func_dict.keys())\n\n            for function in functions:\n                ret_list = [x[1] for x in func_dict[function]]\n                if function in function_retvals_map:\n                    function_retvals_map[function].append(ret_list)\n                else:\n                    function_retvals_map[function] = [ret_list]\n\n        for function in function_retvals_map:\n            retvals_list = function_retvals_map[function]\n            if not retvals_list.count(retvals_list[0]) == len(retvals_list):\n                err = \"RCL API discrepancy - return values do not match\"\n                print(function_retvals_map)\n                return err\n\n\nclass CollisionChecker:\n    topic_proc_map = dict()\n    # topic_stdout_map = dict()\n    collision_events = dict()\n    topic_monitor_map = dict()\n\n    def __init__(self):\n        pass\n\n    def listen(self, topics):\n        print(\"[collision checker] start listening\")\n        self.collision_events = dict()\n        for topic in topics:\n            # print(\"[collision checker] start listening to \", topic)\n\n            cmd = [\"gz\", \"topic\", \"-u\", \"-e\", topic]\n            proc = sp.Popen(cmd, shell=False, stdout=sp.PIPE, stderr=sp.PIPE)\n\n            t = threading.Thread(\n                target=self.monitor,\n                args=(\n                    proc,\n                    topic,\n                ),\n            )\n            t.start()\n\n            self.topic_proc_map[topic] = proc\n            self.topic_monitor_map[topic] = t\n\n    def stop(self):\n        print(\"[collision checker] stop listening\")\n        for topic in self.topic_proc_map:\n            # print(\"[collision checker] stop listening to\", topic)\n\n            proc = self.topic_proc_map[topic]\n            proc.kill()\n\n            thread = self.topic_monitor_map[topic]\n            thread.join()\n            assert thread.is_alive() is False\n\n            # self.topic_stdout_map[topic] = outs\n\n    def monitor(self, proc, topic):\n        for line in iter(proc.stdout.readline, b\"\"):\n            if b\"contact\" in line:\n                line_str = line.decode(\"utf-8\")\n                # print(\"collision: {0}\".format(line_str), end=\"\")\n\n                try:\n                    self.collision_events[topic].append(line_str)\n                except KeyError:\n                    self.collision_events[topic] = [line_str]\n\n    def found_collision(self):\n\n        if len(self.collision_events) > 0:\n            return True\n\n        # for topic in self.topic_stdout_map:\n        # outs = self.topic_stdout_map[topic]\n        # if b'contact' in outs:\n        # self.collision_topic.append(topic)\n        # collision = True\n\n        # return collision\n\n    def print_collision_topics(self) -> None:\n\n        print(list(self.collision_events.keys()))\n"}\n{"instruction": "Write a ROS2 Python node named moveit.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "import rclpy\nfrom rclpy.callback_groups import ReentrantCallbackGroup\nfrom threading import Thread\nfrom pymoveit2 import MoveIt2\n\nhome = [0., 0., 0., 0., 0., 0.]\n\ndef main():\n    rclpy.init()\n    node = rclpy.create_node(node_name=\"maci_moveit_controller\")\n    logger = node.get_logger()\n    \n    callback_group = ReentrantCallbackGroup()\n\n    moveit2 = MoveIt2(node=node, \n                      joint_names=['ur5_shoulder_pan_joint', 'ur5_shoulder_lift_joint',\n                                   'ur5_elbow_joint','ur5_wrist_1_joint',\n                                   'ur5_wrist_2_joint','ur5_wrist_3_joint'],\n                      base_link_name='ur5_base_link',\n                      end_effector_name='gripper',\n                      group_name='arm',\n                      callback_group=callback_group                      )\n\n    # Spin the node in background thread(s) and wait a bit for initialization\n    executor = rclpy.executors.MultiThreadedExecutor(2)\n    executor.add_node(node)\n    executor_thread = Thread(target=executor.spin, daemon=True, args=())\n    executor_thread.start()\n    node.create_rate(1.0).sleep()\n\n    logger.info(\"Move To Home Position\")\n\n    moveit2.move_to_configuration(home)\n    moveit2.wait_until_executed()\n\n    rclpy.shutdown()\n    executor_thread.join()\n\nif __name__ == '__main__':\n    main()"}\n{"instruction": "Write a ROS2 Python node named moveit_widget.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "# Software License Agreement (BSD License)\n#\n# Copyright (c) 2012, Willow Garage, Inc.\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions\n# are met:\n#\n#  * Redistributions of source code must retain the above copyright\n#    notice, this list of conditions and the following disclaimer.\n#  * Redistributions in binary form must reproduce the above\n#    copyright notice, this list of conditions and the following\n#    disclaimer in the documentation and/or other materials provided\n#    with the distribution.\n#  * Neither the name of Willow Garage, Inc. nor the names of its\n#    contributors may be used to endorse or promote products derived\n#    from this software without specific prior written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n# \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n# POSSIBILITY OF SUCH DAMAGE.\n#\n# Author: Isaac Saito\n\nimport os\nimport sys\nimport threading\nfrom collections import defaultdict\n\nimport rclpy\n\nfrom ament_index_python.packages import get_package_share_directory\nfrom python_qt_binding import loadUi\nfrom python_qt_binding.QtWidgets import QWidget\nfrom python_qt_binding.QtCore import QModelIndex, QTimer, Signal\nfrom python_qt_binding.QtGui import QStandardItem, QStandardItemModel\nfrom rqt_gui.main import Main\nfrom rqt_topic.topic_widget import TopicWidget\nfrom rcl_interfaces.srv import ListParameters\n\n\nclass MoveitWidget(QWidget):\n    \"\"\"\n    This Widget provides an overview about the presence of different parts of a running moveIt instance.\n    \"\"\"\n    # To be connected to PluginContainerWidget\n    sig_sysmsg = Signal(str)\n    sig_param = Signal(bool, str)  # param name emitted\n    sig_node = Signal(bool, str)  # node name emitted\n    sig_topic = Signal(list)  # topic name emitted\n\n    _SPLITTER_H = 'splitter_horizontal'\n\n    def __init__(self, parent, plugin_context):\n        \"\"\"\n        @type parent: MoveitMain\n        \"\"\"\n        self._node = rclpy.create_node('rqt_moveit_node')\n        self._stop_event = threading.Event()\n\n        # Nodes to monitor. Discovered MoveIt node will be added to beginning of the list\n        self._nodes_monitored = []\n        self._selected_topics = [('/pointcloud', 'sensor_msgs/msg/PointCloud'),\n                                 ('/pointcloud2', 'sensor_msgs/msg/PointCloud2'),\n                                 ('/image', 'sensor_msgs/msg/Image'),\n                                 ('/camera_info', 'sensor_msgs/msg/CameraInfo')]\n        self._params_monitored = ['robot_description',\n                                  'robot_description_semantic']\n        self._moveit_node_identification_topics = ['/display_contacts',\n                                                   '/display_planned_path']\n\n        super(MoveitWidget, self).__init__()\n        self._parent = parent\n        self._plugin_context = plugin_context\n        self._refresh_rate = 3  # With default value\n\n        package_share_dir = get_package_share_directory('rqt_moveit')\n        ui_file = os.path.join(package_share_dir, 'resource', 'moveit_top.ui')\n        loadUi(ui_file, self)\n\n        # Create and add topics widget programmatically\n        self._widget_topic = TopicWidget(self._node)\n        self._splitter.addWidget(self._widget_topic)\n\n        self._spinbox_refreshrate.valueChanged.connect(self._update_refreshrate)\n\n        # Show default ref rate on QSpinbox\n        self._spinbox_refreshrate.setValue(self._refresh_rate)\n\n        # Monitor node\n        self._moveit_node_found = False\n        self._moveit_node_name = ''\n        self._node_qitems = {}\n        self._node_monitor_thread = self._init_monitor_nodes()\n        self._node_monitor_thread.start()\n\n        # topic to show\n        self._registered_topics = None\n        self._topic_monitor_thread = self._init_monitor_topics()\n        self._topic_monitor_thread.start()\n\n        # Init monitoring parameters.\n        self._parameter_client = None\n        self._parameter_client_registered = False\n        self._param_qitems = {}\n        _col_names_paramtable = ['Param name', 'Found in MoveIt node?']\n        self._param_check_thread = self._init_monitor_parameters(_col_names_paramtable)\n        self._param_check_thread.start()\n\n    def _register_parameter_client(self):\n        \"\"\"\n        If a moveit node was already found. This method tries to create a service client\n        to read the parameter list from the moveit node.\n        \"\"\"\n        if self._moveit_node_found:\n            self._parameter_client = self._node.create_client(ListParameters,\n                                                              f'{self._moveit_node_name}/list_parameters')\n            ready = self._parameter_client.wait_for_service(timeout_sec=5.0)\n            if ready:\n                self._parameter_client_registered = True\n            else:\n                self._node.get_logger().err('Waiting for parameter service timed out')\n\n    def _discover_moveit_node(self):\n        \"\"\"\n        This method gets called by the _check_nodes_alive function if\n        self._moveit_node_found is False. It tries to discover the moveit node\n        based on list of known publishers (self._moveit_node_identification_topics)\n        of a moveit node.\n        \"\"\"\n        publishers = defaultdict(list)\n        for name, namespace in self._node.get_node_names_and_namespaces():\n            node_name = namespace + name if namespace.endswith('/') else namespace + '/' + name\n            for topic_name, topic_type in self._node.get_publisher_names_and_types_by_node(name, namespace):\n                publishers[topic_name].append(node_name)\n\n        if self._moveit_node_identification_topics[0] in publishers and \\\n                self._moveit_node_identification_topics[1] in publishers:\n            # TODO add logic if more than one node publishes to this topics\n            moveit_node_name = publishers[self._moveit_node_identification_topics[1]][0]\n            self._moveit_node_name = moveit_node_name\n            self._nodes_monitored.insert(0, moveit_node_name)\n            self._moveit_node_found = True\n\n    def _init_monitor_nodes(self):\n        \"\"\"\n        @rtype: Thread\n        \"\"\"\n        self._node_datamodel = QStandardItemModel(0, 2)\n        self._root_qitem = self._node_datamodel.invisibleRootItem()\n        self._view_nodes.setModel(self._node_datamodel)\n\n        node_monitor_thread = threading.Thread(target=self._check_nodes_alive,\n                                     args=(self.sig_node, self._nodes_monitored, self._stop_event))\n\n        self.sig_node.connect(self._update_output_nodes)\n        return node_monitor_thread\n\n    def _check_nodes_alive(self, signal, nodes_monitored, stop_event):\n        \"\"\"\n        Working as a callback of Thread class, this method keeps looping to\n        watch if the nodes whose names are passed exist and emits signal per\n        each node.\n\n        Notice that what MoveitWidget._check_nodes_alive &\n        MoveitWidget._check_params_alive do is very similar, but since both of\n        them are supposed to be passed to Thread class, there might not be\n        a way to generalize these 2.\n\n        @param signal: Signal(bool, str)\n        @type nodes_monitored: str[]\n        @type stop_event: Event()\n        \"\"\"\n        while True:\n            if not self._moveit_node_found:\n                self._discover_moveit_node()\n\n            for nodename in nodes_monitored:\n                registered_nodes = self._node.get_node_names_and_namespaces()\n                # Also considering the namespace of a node\n                nodes_with_namespaces = [f'{node[1]}{node[0]}' for node in registered_nodes]\n                is_node_running = nodename in nodes_with_namespaces\n                signal.emit(is_node_running, nodename)\n                self._node.get_logger().debug('_update_output_nodes')\n\n            if stop_event.wait(self._refresh_rate):\n                return\n\n    def _init_monitor_topics(self):\n        \"\"\"\n        @rtype: Thread\n        \"\"\"\n        topic_monitor_thread = threading.Thread(target=self._check_topics_alive,\n                                      args=(self.sig_topic, self._selected_topics, self._stop_event))\n        self.sig_topic.connect(self._update_output_topics)\n        return topic_monitor_thread\n\n    def _check_topics_alive(self, signal, topics_monitored, stop_event):\n        \"\"\"\n        Working as a callback of Thread class, this method keeps looping to\n        watch if the topics whose names are passed exist and emits signal per\n        each node.\n\n        @param signal: Signal()\n        @type topics_monitored: str[]\n        @type stop_event: Event()\n        \"\"\"\n        while True:\n            published_topics = dict(self._node.get_topic_names_and_types())\n            registered_topics = []\n            for topic in topics_monitored:\n                # If topic is published\n                if topic[0] in published_topics:\n                    topic_types = published_topics.get(topic[0])\n                    # And has the same type\n                    if topic[1] in topic_types:\n                        registered_topics.append((topic[0], published_topics.get(topic[0])))\n\n            signal.emit(list(registered_topics))\n            self._node.get_logger().debug('_update_output_topics')\n            if stop_event.wait(self._refresh_rate):\n                return\n\n    def _init_monitor_parameters(self, _col_names_paramtable=None):\n        \"\"\"\n        @rtype: Thread\n        \"\"\"\n\n        self._param_datamodel = QStandardItemModel(0, 2)\n        self._root_qitem = self._param_datamodel.invisibleRootItem()\n        self._view_params.setModel(self._param_datamodel)\n\n        # Names of header on the QTableView.\n        if not _col_names_paramtable:\n            _col_names_paramtable = ['Param name',\n                                     'Found in MoveIt node?']\n        self._param_datamodel.setHorizontalHeaderLabels(_col_names_paramtable)\n\n        self.sig_param.connect(self._update_output_parameters)\n\n        param_check_thread = threading.Thread(target=self._check_params_alive,\n                                    args=(self.sig_param, self._params_monitored, self._stop_event))\n        return param_check_thread\n\n    def _update_output_nodes(self, is_node_running, node_name):\n        \"\"\"\n        Slot for signals that tell nodes existence.\n\n        @type is_node_running: bool\n        @type node_name: str\n        \"\"\"\n        # TODO: What this method does is exactly the same with\n        # monitor_parameters. Unify them.\n\n        self._node.get_logger().debug('is_node_running={} par_name={}'.format(is_node_running, node_name))\n        node_name = str(node_name)\n        node_qitem = None\n        if node_name not in self._node_qitems:\n            node_qitem = QStandardItem(node_name)\n            self._node_qitems[node_name] = node_qitem\n            self._node_datamodel.appendRow(node_qitem)\n        else:  # qsitem with the node name already exists.\n            node_qitem = self._node_qitems[str(node_name)]\n\n        qindex = self._node_datamodel.indexFromItem(node_qitem)\n        _str_node_running = 'Not running'\n        if is_node_running:\n            _str_node_running = 'Running'\n        qitem_node_status = QStandardItem(_str_node_running)\n        self._node_datamodel.setItem(qindex.row(), 1, qitem_node_status)\n\n    def _update_output_topics(self, registered_topics):\n        \"\"\"\n        Slot for signals that tell topic's existence.\n\n        @type registered_topics: list\n        \"\"\"\n        # This branch will cause that once a selected topic was found the topic view will\n        # never be empty again.\n        if len(registered_topics) > 0:\n            if self._registered_topics is None:\n                self._widget_topic.set_selected_topics(registered_topics)\n                self._widget_topic.set_topic_specifier(TopicWidget.SELECT_BY_NAME)\n                self._widget_topic.start()\n            elif self._registered_topics is not None and \\\n                    set([topic[0] for topic in self._registered_topics]) != \\\n                    set([topic[0] for topic in registered_topics]):\n                self._widget_topic.set_selected_topics(registered_topics)\n\n            self._registered_topics = registered_topics\n\n    def _check_params_alive(self, signal, params_monitored, stop_event):\n        \"\"\"\n        Working as a callback of Thread class, this method keeps looping to\n        watch if the params whose names are passed exist and emits signal per\n        each node.\n\n        Notice that what MoveitWidget._check_nodes_alive &\n        MoveitWidget._check_params_alive do is very similar, but since both of\n        them are supposed to be passed to Thread class, there might not be\n        a way to generalize these 2.\n\n        @type signal: Signal(bool, str)\n        @param_name signal: emitting a name of the parameter that's found.\n        @type params_monitored: str[]\n        @type stop_event: Event()\n        \"\"\"\n\n        while True:\n            if self._parameter_client_registered:\n                request = ListParameters.Request()\n                future = self._parameter_client.call_async(request)\n                rclpy.spin_until_future_complete(self._node, future)\n                moveit_node_params = future.result().result.names\n                for param_name in params_monitored:\n                    has_param = True if param_name in moveit_node_params else False\n                    signal.emit(has_param, param_name)\n                    self._node.get_logger().debug('has_param {}, check_param_alive: {}'.format(has_param, param_name))\n            else:\n                self._register_parameter_client()\n                for param_name in params_monitored:\n                    signal.emit(False, param_name)\n\n            if stop_event.wait(self._refresh_rate):\n                return\n\n    def _update_output_parameters(self, has_param, param_name):\n        \"\"\"\n        Slot\n\n        @type has_param: bool\n        @type param_name: str\n        \"\"\"\n        self._node.get_logger().debug('has_param={} par_name={}'.format(has_param,\n                                                         param_name))\n        param_name = str(param_name)\n        param_qitem = None\n        if param_name not in self._param_qitems:\n            param_qitem = QStandardItem(param_name)\n            self._param_qitems[param_name] = param_qitem\n            self._param_datamodel.appendRow(param_qitem)\n        else:  # qsitem with the param name already exists.\n            param_qitem = self._param_qitems[str(param_name)]\n\n        qindex = self._param_datamodel.indexFromItem(param_qitem)\n        _str_param_found = 'No'\n        if has_param:\n            _str_param_found = 'Yes'\n        qitem_param_status = QStandardItem(_str_param_found)\n        self._param_datamodel.setItem(qindex.row(), 1, qitem_param_status)\n        self._view_params.resizeColumnsToContents()\n\n    def _update_refreshrate(self, refresh_rate):\n        \"\"\"\n        Slot\n\n        @type refresh_rate: int\n        \"\"\"\n        self._refresh_rate = refresh_rate\n\n    def save_settings(self, plugin_settings, instance_settings):\n        instance_settings.set_value(self._SPLITTER_H,\n                                    self._splitter.saveState())\n\n    def restore_settings(self, plugin_settings, instance_settings):\n        if instance_settings.contains(self._SPLITTER_H):\n            self._splitter.restoreState(instance_settings.value(self._SPLITTER_H))\n        else:\n            self._splitter.setSizes([100, 100, 200])\n        pass\n\n    def shutdown(self):\n        \"\"\"\n        Overridden.\n\n        Close threads.\n\n        @raise RuntimeError:\n        \"\"\"\n        try:\n            self._stop_event.set()\n\n            self._node_monitor_thread.join()\n            self._param_check_thread.join()\n            self._topic_monitor_thread.join()\n\n            self._node_monitor_thread = None\n            self._param_check_thread = None\n            self._topic_monitor_thread = None\n\n            self._node.destroy_node()\n\n        except RuntimeError as e:\n            self._node.get_logger().err(e)\n            raise e\n\n\ndef main(args=None):\n    main_obj = Main()\n    sys.exit(\n        main_obj.main(\n            sys.argv,\n            standalone='rqt_moveit.moveit_plugin.MoveitPlugin'\n        )\n    )\n\n"}\n{"instruction": "Write a ROS2 Python node named follow_estop_tf2_mp.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "import rclpy\nfrom rclpy.node import Node\nfrom rclpy.executors import MultiThreadedExecutor\n\nfrom cv_bridge import CvBridge\nimport cv2\nimport numpy as np\nfrom sensor_msgs.msg import Image, CameraInfo\nfrom std_msgs.msg import Header\nfrom geometry_msgs.msg import Pose, TransformStamped, Twist, TwistStamped, Quaternion\nimport tf2_ros\nimport tf2_py\nimport transforms3d as t3d\nfrom transforms3d.euler import quat2euler\nfrom geometry_msgs.msg import Vector3\nfrom tf2_geometry_msgs import do_transform_pose\nimport tf2_geometry_msgs\nfrom tf2_ros import StaticTransformBroadcaster\n\nfrom moveit_msgs.msg import ServoStatus\n\nimport time\nimport math\nfrom scipy.spatial.transform import Rotation as R\n\nfrom world_info_msgs.msg import BoundingPolygon, BoundingPolygonArray\nfrom world_info_msgs.msg import BoundingBox, BoundingBoxArray, Keypoints, KeypointsArray\nfrom geometry_msgs.msg import Point32\n\nfrom ultralytics import YOLO\nfrom ament_index_python.packages import get_package_share_directory\nimport os\n\nfrom rclpy.action import ActionClient\nfrom rclpy.node import Node\n\nfrom moveit_msgs.msg import MotionPlanRequest\nfrom moveit_msgs.msg import JointConstraint\nfrom moveit_msgs.msg import Constraints\nfrom moveit_msgs.msg import PlanningOptions\nfrom moveit_msgs.action import MoveGroup\n\nfrom sensor_msgs.msg import JointState\nfrom moveit_msgs.srv import GetPositionIK\n\nfrom copy import deepcopy\n\nfrom tf2_ros import StaticTransformBroadcaster\n\nARUCO_ID = 25\nARUCO_SIZE = 0.059\nDISTANCE_TO_ARUCO = 0.35\nlabel_map = [\"estop\"]\n\nrelative_points = np.array(\n    [\n        [-ARUCO_SIZE / 2, ARUCO_SIZE / 2, 0],\n        [ARUCO_SIZE / 2, ARUCO_SIZE / 2, 0],\n        [ARUCO_SIZE / 2, -ARUCO_SIZE / 2, 0],\n        [-ARUCO_SIZE / 2, -ARUCO_SIZE / 2, 0],\n    ],\n    dtype=np.float32,\n)\n\n\nclass Moveit(Node):\n    def __init__(self):\n        super().__init__(\"moveit_plan_execute_python\")\n\n        self._action_client = ActionClient(self, MoveGroup, \"/move_action\")\n\n    def send_goal(self, target_angles):\n        self.joint_state = None\n        self.goal_done = False\n\n        motion_plan_request = MotionPlanRequest()\n\n        motion_plan_request.workspace_parameters.header.stamp = (\n            self.get_clock().now().to_msg()\n        )\n        motion_plan_request.workspace_parameters.header.frame_id = \"gen3_base_link\"\n        motion_plan_request.workspace_parameters.min_corner.x = -1.0\n        motion_plan_request.workspace_parameters.min_corner.y = -1.0\n        motion_plan_request.workspace_parameters.min_corner.z = -1.0\n        motion_plan_request.workspace_parameters.max_corner.x = 1.0\n        motion_plan_request.workspace_parameters.max_corner.y = 1.0\n        motion_plan_request.workspace_parameters.max_corner.z = 1.0\n        motion_plan_request.start_state.is_diff = True\n\n        jc = JointConstraint()\n        jc.tolerance_above = 0.01\n        jc.tolerance_below = 0.01\n        jc.weight = 1.0\n\n        joints = {}\n        joints[\"joint_1\"] = target_angles[0]\n        joints[\"joint_2\"] = target_angles[1]\n        joints[\"joint_3\"] = target_angles[2]\n        joints[\"joint_4\"] = target_angles[3]\n        joints[\"joint_5\"] = target_angles[4]\n        joints[\"joint_6\"] = target_angles[5]\n\n        constraints = Constraints()\n        for joint, angle in joints.items():\n            jc.joint_name = joint\n            jc.position = angle\n            constraints.joint_constraints.append(deepcopy(jc))\n\n        motion_plan_request.goal_constraints.append(constraints)\n\n        motion_plan_request.pipeline_id = \"ompl\"\n        # motion_plan_request.planner_id = \"STOMP\"\n        motion_plan_request.group_name = \"manipulator\"\n        motion_plan_request.num_planning_attempts = 10\n        motion_plan_request.allowed_planning_time = 10.0\n        motion_plan_request.max_velocity_scaling_factor = 0.5\n        motion_plan_request.max_acceleration_scaling_factor = 0.5\n        motion_plan_request.max_cartesian_speed = 0.0\n\n        planning_options = PlanningOptions()\n        planning_options.plan_only = False\n        planning_options.look_around = False\n        planning_options.look_around_attempts = 0\n        planning_options.max_safe_execution_cost = 0.0\n        planning_options.replan = True\n        planning_options.replan_attempts = 10\n        planning_options.replan_delay = 0.1\n\n        goal_msg = MoveGroup.Goal()\n        goal_msg.request = motion_plan_request\n        goal_msg.planning_options = planning_options\n\n        self._action_client.wait_for_server()\n        self._send_goal_future = self._action_client.send_goal_async(\n            goal_msg, feedback_callback=self.feedback_callback\n        )\n        self._send_goal_future.add_done_callback(self.goal_response_callback)\n\n    def goal_response_callback(self, future):\n        goal_handle = future.result()\n        if not goal_handle.accepted:\n            self.get_logger().info(\"Goal rejected :(\")\n            self.goal_done = True\n            return\n\n        self.get_logger().info(\"Goal accepted :)\")\n\n        self._get_result_future = goal_handle.get_result_async()\n        self._get_result_future.add_done_callback(self.get_result_callback)\n\n    def get_result_callback(self, future):\n        # self.get_logger().info(str(future))\n        self.goal_done = True\n\n    def feedback_callback(self, feedback_msg):\n        # self.get_logger().info(str(feedback_msg))\n        pass\n\n\nclass IK(Node):\n    def __init__(self):\n        super().__init__(\"moveit_ik\")\n\n        self.create_subscription(JointState, \"/joint_states\", self.joint_states_cb, 1)\n\n        self.cli = self.create_client(GetPositionIK, \"/compute_ik\")\n\n        while not self.cli.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info(\"service not available, waiting again...\")\n            rclpy.spin_once(self)\n\n    def joint_states_cb(self, joint_state):\n        self.joint_state = joint_state\n\n    def send_request(self, pose):\n        self.joint_state = None\n\n        while self.joint_state is None:\n            rclpy.spin_once(self)\n\n        req = GetPositionIK.Request()\n        \n        req.ik_request.group_name = \"manipulator\"\n        req.ik_request.robot_state.joint_state = self.joint_state\n        req.ik_request.avoid_collisions = True\n\n        req.ik_request.pose_stamped.header.stamp = self.get_clock().now().to_msg()\n        req.ik_request.pose_stamped.header.frame_id = \"gen3_base_link\"\n\n        req.ik_request.pose_stamped.pose = pose\n        req.ik_request.timeout.sec = 10\n\n        self.future = self.cli.call_async(req)\n        rclpy.spin_until_future_complete(self, self.future)\n\n        target_angles = list(self.future.result().solution.joint_state.position)[:6]\n\n        if len(target_angles) > 0:\n            return target_angles\n\n        self.get_logger().warn(\"No ik soln found\")\n        return None\n\n\ndef moveit_motion(pose):\n    ik = IK()\n    moveit = Moveit()\n    target_angles = ik.send_request(pose)\n    ik.destroy_node()\n    if target_angles != None:\n        moveit.send_goal(target_angles)\n        while not moveit.goal_done:\n            rclpy.spin_once(moveit)\n        moveit.destroy_node()\n        return target_angles\n    moveit.destroy_node()\n    return target_angles\n\n\ndef compute_end_effector_twist(body_twist, body_to_ee_transform, ee_to_body_transform):\n    # Convert Quaternion to Rotation Matrix for both transformations\n    quat_ab = [body_to_ee_transform.transform.rotation.x,\n               body_to_ee_transform.transform.rotation.y,\n               body_to_ee_transform.transform.rotation.z,\n               body_to_ee_transform.transform.rotation.w]\n    r_ab = R.from_quat(quat_ab)\n    rotation_matrix_ab = r_ab.as_matrix()\n\n    quat_ba = [ee_to_body_transform.transform.rotation.x,\n               ee_to_body_transform.transform.rotation.y,\n               ee_to_body_transform.transform.rotation.z,\n               ee_to_body_transform.transform.rotation.w]\n    r_ba = R.from_quat(quat_ba)\n    rotation_matrix_ba = r_ba.as_matrix()\n\n    # Calculate translation for both transformations\n    translation_ab = np.array([body_to_ee_transform.transform.translation.x,\n                                body_to_ee_transform.transform.translation.y,\n                                body_to_ee_transform.transform.translation.z])\n\n    translation_ba = np.array([ee_to_body_transform.transform.translation.x,\n                                ee_to_body_transform.transform.translation.y,\n                                ee_to_body_transform.transform.translation.z])\n\n    # Construct the twist in the body frame\n    body_twist_vector = np.array([body_twist.linear.x, body_twist.linear.y, body_twist.linear.z,\n                                  body_twist.angular.x, body_twist.angular.y, body_twist.angular.z])\n\n    # Construct the twist in the end effector frame using the relation Sa = [Ad(Tab)] Sb\n    # Adjoint transformation for Tab\n    adjoint_ab = np.zeros((6, 6))\n    adjoint_ab[:3, :3] = rotation_matrix_ab\n    adjoint_ab[3:6, 3:6] = rotation_matrix_ab\n    adjoint_ab[:3, 3:6] = np.dot(rotation_matrix_ab.T, np.cross(-translation_ab, rotation_matrix_ab))\n\n    # Adjoint transformation for Tba\n    adjoint_ba = np.zeros((6, 6))\n    adjoint_ba[:3, :3] = rotation_matrix_ba\n    adjoint_ba[3:6, 3:6] = rotation_matrix_ba\n    adjoint_ba[:3, 3:6] = np.dot(rotation_matrix_ba.T, np.cross(-translation_ba, rotation_matrix_ba))\n\n    # Apply the relation Sa = [Ad(Tab)] Sb\n    end_effector_twist_vector = np.dot(adjoint_ab, np.dot(adjoint_ba, -body_twist_vector))\n\n    # Construct the Twist message for the end effector\n    end_effector_twist = Twist()\n    end_effector_twist.linear.x = -end_effector_twist_vector[0]\n    end_effector_twist.linear.y = -end_effector_twist_vector[1]\n    end_effector_twist.linear.z = -end_effector_twist_vector[2]\n    end_effector_twist.angular.x = -end_effector_twist_vector[3]\n    end_effector_twist.angular.y = -end_effector_twist_vector[4]\n    end_effector_twist.angular.z = -end_effector_twist_vector[5]\n\n    return end_effector_twist\n\n\nclass CameraLinkPose:\n    def __init__(self, tf_buffer, logger):\n        self.logger = logger\n        self.tf_buffer = tf_buffer\n\n        self.nominal_x_position = 0.617\n        self.min_x_position = 0.61\n        self.max_x_position = 0.8\n\n        self.nominal_y_position = 0.0\n        self.min_y_position = self.nominal_y_position - 0.15\n        self.max_y_position = self.nominal_y_position + 0.15\n\n        self.nominal_z_position = 0.6\n        self.min_z_position = self.nominal_z_position - 0.1\n        self.max_z_position = self.nominal_z_position + 0.1\n\n        self.source = \"camera_link\"\n        self.target = \"body\"\n\n        self.height_source = \"camera_link\"\n        self.height_target = \"gpe\"\n\n        self.current_spot_height = 0.0\n        self.new_spot_height = 0.0\n\n    def is_ee_within_xyz_limit(self):\n        SPOT_SPEED_TR = 0.16\n        SPOT_SPEED_ROT = 0.16\n\n        change_height = False\n\n        try:\n            t = self.tf_buffer.lookup_transform(\n                self.target, self.source, rclpy.time.Time()\n            )\n\n            x = 0.0\n            if t.transform.translation.x < self.min_x_position:\n                x = -SPOT_SPEED_TR\n            elif t.transform.translation.x > self.max_x_position:\n                x = SPOT_SPEED_TR\n\n            y = 0.0\n            if t.transform.translation.y < self.min_y_position:\n                y = -SPOT_SPEED_ROT\n            elif t.transform.translation.y > self.max_y_position:\n                y = SPOT_SPEED_ROT\n\n            DELTA_HEIGHT = 0.005\n            if t.transform.translation.z < self.min_z_position:\n                self.new_spot_height -= DELTA_HEIGHT\n            elif t.transform.translation.z > self.max_z_position:\n                self.new_spot_height += DELTA_HEIGHT\n            \n            # self.logger.info(f\"{self.new_spot_height}\")\n\n            MIN_SPOT_HEIGHT = -0.04\n            MAX_SPOT_HEIGHT = 0.04\n            self.new_spot_height = np.clip(self.new_spot_height, MIN_SPOT_HEIGHT, MAX_SPOT_HEIGHT)\n\n            t1 = self.tf_buffer.lookup_transform(\n                self.source, self.target, rclpy.time.Time()\n            )\n\n            if x != 0 or y != 0 or self.current_spot_height != self.new_spot_height:\n                if self.current_spot_height != self.new_spot_height:\n                    self.current_spot_height = self.new_spot_height\n                    change_height = True\n                return False, change_height, x, y, self.current_spot_height, [t1, t]\n\n            return True, change_height, 0.0, 0.0, self.current_spot_height, [t1, t]\n\n        except tf2_ros.TransformException as ex:\n            # self.get_logger().info(f\"Could not transform {self.source} to {self.target}: {ex}\")\n            pass\n\n        return False, change_height, 0.0, 0.0, self.current_spot_height, None\n\n\n\ndef calculate_distance(point1, point2):\n    x1, y1 = point1\n    x2, y2 = point2\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\n    \nclass ArucoDetectorNode(Node):\n    def __init__(self):\n        super().__init__('aruco_detector_node')\n\n        static_broadcaster = StaticTransformBroadcaster(self)\n\n        transform1 = TransformStamped()\n        transform1.header.frame_id = f'aruco_{ARUCO_ID}'\n        transform1.child_frame_id = 'camera_link_target'\n        transform1.transform.translation.z = DISTANCE_TO_ARUCO\n        transform1.transform.rotation.y = 1.0\n        transform1.transform.rotation.w = 0.0\n\n        transform2 = TransformStamped()\n        transform2.header.frame_id = 'camera_link_target'\n        transform2.child_frame_id = 'tool_frame_target'\n        transform2.transform.translation.y = 0.056\n        transform2.transform.translation.z = 0.203\n        transform2.transform.rotation.z = 1.0\n        transform2.transform.rotation.w = 0.0\n\n        static_broadcaster.sendTransform([transform1, transform2])\n\n        pose_model_path = os.path.join(\n            get_package_share_directory(\"alert_auto_dexterity\"), \"models\", \"estop_openvino_model\"# \"estop.onnx\"\n        )\n        \n        # Load the YOLOv8 model\n        self.yolo_model = YOLO(pose_model_path, task=\"pose\")\n\n        self.bridge = CvBridge()\n\n        self.tf_broadcaster = tf2_ros.TransformBroadcaster(self)\n        self.tf_buffer = tf2_ros.Buffer()\n        self.tf_listener = tf2_ros.TransformListener(self.tf_buffer, self)\n\n        self.image_sub = self.create_subscription(\n            Image, '/kinova_color', self.image_callback, 1)\n        self.camera_info_sub = self.create_subscription(\n            CameraInfo, '/kinova_color/camera_info', self.camera_info_callback, 1)\n\n        self.servo_status_sub = self.create_subscription(ServoStatus, '/servo_node/status', self.servo_status_cb, 1)\n\n        # self.create_timer(1/50, self.step)\n        self.ee_twist_pub = self.create_publisher(TwistStamped, \"/twist_controller/commands\", 1)\n        self.spot_twist_pub = self.create_publisher(Twist, \"/cmd_vel\", 1)\n        self.spot_body_pose_pub = self.create_publisher(Pose, \"/body_pose\", 1)\n\n        self.bounding_polygon_pub = self.create_publisher(BoundingPolygonArray, \"/kinova_color/bp\", 1)\n\n        IMAGE_TOPIC = \"/kinova_color\"\n\n        self.bounding_box_pub = self.create_publisher(\n            BoundingBoxArray, IMAGE_TOPIC + \"/bb\", 1\n        )\n        self.keypoints_pub = self.create_publisher(\n            KeypointsArray, IMAGE_TOPIC + \"/kp\", 1\n        )\n\n        ar_dict = cv2.aruco.getPredefinedDictionary(cv2.aruco.DICT_6X6_50)\n        self.aruco_detector = cv2.aruco.ArucoDetector(ar_dict)\n\n        self.source = 'tool_frame_target'\n        self.target = 'gen3_base_link'\n        \n        # Initialize previous values for smoothing\n        self.prev_linear = np.zeros(3)\n        self.prev_angular = np.zeros(3)\n        self.alpha = 0.2  # Smoothing factor (tune this value)\n\n        self.target_goal_reached = False\n\n        self.camera_pose = CameraLinkPose(self.tf_buffer, self.get_logger())\n\n        self.pause = False\n\n    def servo_status_cb(self, msg):\n        status = msg.code\n        if status == 0:\n            self.pause = False\n            return\n\n        self.pause = True\n        self.get_logger().warn(f\"{status}\")\n        time.sleep(0.1)\n\n    def image_callback(self, msg):\n        if not hasattr(self, 'dist_coeff'):\n            return\n\n        image = self.bridge.imgmsg_to_cv2(msg, \"bgr8\")\n\n        results = self.yolo_model.track(image, persist=True, verbose=False)\n\n        boxes = results[0].boxes.xyxy.cpu()\n\n        if results[0].boxes.id is not None:\n            detection = {}\n            detection[\"box\"] = results[0].boxes.xywh.cpu().tolist()\n            detection[\"kpt\"] = results[0].keypoints.xy.cpu().tolist()\n            detection[\"score\"] = results[0].boxes.conf.float().cpu().tolist()\n            detection[\"tracker_id\"] = results[0].boxes.id.int().cpu().tolist()\n\n            bb_msg = BoundingBoxArray()\n            bb_msg.header = msg.header\n            bb_msg.type = label_map[0]\n\n            kp_msg = KeypointsArray()\n            kp_msg.header = msg.header\n            kp_msg.type = label_map[0]\n\n            # detection = results[0]\n\n            center_x = image.shape[1] // 2\n            center_y = image.shape[0] // 2\n\n            closest_distance = float(\"inf\")\n            closest_estop = None\n\n            idx = 0\n            for box, keypoints in zip(detection[\"box\"], detection[\"kpt\"]):\n                for keypoint in keypoints:\n                    distance = calculate_distance(keypoint, (center_x, center_y))\n                    if distance < closest_distance:\n                        closest_distance = distance\n                        closest_estop = idx\n                idx += 1\n\n            idx = closest_estop\n\n            if closest_estop is not None:\n                box = detection[\"box\"][idx]\n                keypoints = detection[\"kpt\"][idx]\n                score = detection[\"score\"][idx]\n                label = detection[\"tracker_id\"][idx]\n\n                x1, y1, x2, y2 = box\n\n                u1 = keypoints[0][0]\n                v1 = keypoints[0][1]\n                u2 = keypoints[1][0]\n                v2 = keypoints[1][1]\n                u3 = keypoints[2][0]\n                v3 = keypoints[2][1]\n                u4 = keypoints[3][0]\n                v4 = keypoints[3][1]\n                u5 = keypoints[4][0]\n                v5 = keypoints[4][1]\n\n                image_points = np.array(\n                    [[u1, v1], [u2, v2], [u4, v4], [u3, v3]], dtype=np.float32\n                )\n\n                label = int(label)\n                label_name = label_map[label] if label < len(label_map) else \"Unknown\"\n                label_str = f\"{label_name}: {score:.2f}\"  # Create a label string\n\n                bb = BoundingBox()\n                bb.name = label_map[0] + str(idx)\n                bb.confidence = float(score)\n                bb.cx = float(x1-x2/2)\n                bb.cy = float(y1-y2/2)\n                bb.width = float(x2)\n                bb.height = float(y2)\n                bb_msg.array.append(bb)\n\n                kp = Keypoints()\n                kp.name = label_map[0] + str(idx)\n                for image_kp in image_points:\n                    point = Point32()\n                    point.x = float(image_kp[0])\n                    point.y = float(image_kp[1])\n                    kp.array.append(point)\n                kp_msg.array.append(kp)\n\n                _, rvec, tvec = cv2.solvePnP(\n                    relative_points, image_points, self.camera_matrix, self.dist_coeff\n                )\n                transform = self.calculate_transform(rvec, tvec)\n                self.publish_transform(transform, msg.header, ARUCO_ID)\n\n            self.bounding_box_pub.publish(bb_msg)\n            self.keypoints_pub.publish(kp_msg)\n\n        self.step()\n\n    def camera_info_callback(self, msg):\n        if hasattr(self, 'dist_coeff'):\n            return\n        self.camera_matrix = np.array(msg.k).reshape((3, 3))\n        self.dist_coeff = np.array(msg.d)\n\n    def calculate_transform(self, rvec, tvec):\n        rotation_matrix, _ = cv2.Rodrigues(rvec)\n        translation_vector = np.array(tvec).reshape((3, 1))\n\n        transform = np.eye(4)\n        transform[:3, :3] = rotation_matrix\n        transform[:3, 3] = translation_vector.flatten()\n\n        return transform\n\n    def publish_transform(self, transform, header, aruco_id):\n        tf_msg = TransformStamped()\n        tf_msg.header = header\n        tf_msg.child_frame_id = f'aruco_{aruco_id}'\n        tf_msg.transform.translation.x = transform[0, 3]\n        tf_msg.transform.translation.y = transform[1, 3]\n        tf_msg.transform.translation.z = transform[2, 3]\n\n        rotation_matrix = transform[:3, :3]\n        rotation_quaternion = t3d.quaternions.mat2quat(rotation_matrix)\n        tf_msg.transform.rotation.x = -rotation_quaternion[2]\n        tf_msg.transform.rotation.y = rotation_quaternion[1]\n        tf_msg.transform.rotation.z = -rotation_quaternion[0]\n        tf_msg.transform.rotation.w = rotation_quaternion[3]\n\n        self.tf_broadcaster.sendTransform(tf_msg)\n            \n    def step(self):\n        GOAL_DISTANCE_TOLERANCE = 4.0\n        GOAL_ANGULAR_TOLERANCE = 1.5\n\n        ee_twist_msg = None\n\n        ee_within_xyz_limit, change_height, spot_speed_x, spot_yaw, spot_height, t_body_camera_link = self.camera_pose.is_ee_within_xyz_limit()\n        # self.get_logger().info(f\"{ee_within_xyz_limit}, {x}\")\n        if not ee_within_xyz_limit:\n            if spot_speed_x != 0 or spot_yaw != 0 or change_height:\n                spot_twist_msg = Twist()\n                spot_twist_msg.linear.x = spot_speed_x\n                spot_twist_msg.angular.z = spot_yaw\n                # spot_twist_msg.linear.y = spot_yaw\n\n                body_pose_msg = Pose()\n                # self.get_logger().info(f\"{spot_height}\")\n                body_pose_msg.position.z = spot_height\n\n                if not self.pause:\n                    self.spot_body_pose_pub.publish(body_pose_msg)\n                    # self.spot_twist_pub.publish(spot_twist_msg)\n\n                    ee_twist_msg = TwistStamped()\n                    ee_twist_msg.header.frame_id = \"body\"\n                    ee_twist_msg.header.stamp = self.get_clock().now().to_msg()\n\n                    ee_twist_msg.twist.linear.x = -2.0*spot_twist_msg.linear.x\n                    ee_twist_msg.twist.linear.y = -4.0*spot_twist_msg.angular.z\n\n                    if t_body_camera_link is not None:\n                        t_body_camera_link, t_camera_link_body = t_body_camera_link\n                        # ee_twist_msg.twist = compute_end_effector_twist(spot_twist_msg, t_body_camera_link, t_camera_link_body)\n                        \n                        # print(spot_twist_msg, ee_twist_msg)\n\n        try:\n            t = self.tf_buffer.lookup_transform(\n                self.target, self.source, rclpy.time.Time()\n            )\n\n            within_distance_tolerance = False\n            if abs(t.transform.translation.x) < GOAL_DISTANCE_TOLERANCE and \\\n            abs(t.transform.translation.y) < GOAL_DISTANCE_TOLERANCE and \\\n            abs(t.transform.translation.z) < GOAL_DISTANCE_TOLERANCE:\n                within_distance_tolerance = True\n\n            # Apply low-pass filter to angular components\n            euler_angles = quat2euler([\n                t.transform.rotation.w,\n                t.transform.rotation.x,\n                t.transform.rotation.y,\n                t.transform.rotation.z\n            ])\n\n            within_angular_tolerance = False\n            if abs(euler_angles[0]) < GOAL_ANGULAR_TOLERANCE and \\\n            abs(euler_angles[1]) < GOAL_ANGULAR_TOLERANCE and \\\n            abs(euler_angles[2]) < GOAL_ANGULAR_TOLERANCE:\n                within_angular_tolerance = True\n\n            # self.get_logger().info(f\"{within_distance_tolerance}, {within_angular_tolerance}\")\n            if within_distance_tolerance and within_angular_tolerance:\n                self.target_goal_reached = True\n            else:\n                pose_goal = Pose()\n                pose_goal.position.x = t.transform.translation.x\n                pose_goal.position.y = t.transform.translation.y \n                pose_goal.position.z = t.transform.translation.z \n                pose_goal.orientation.x = t.transform.rotation.x\n                pose_goal.orientation.y = t.transform.rotation.y\n                pose_goal.orientation.z = t.transform.rotation.z\n                pose_goal.orientation.w = t.transform.rotation.w\n\n                self.tf_buffer.clear()\n\n                moveit_motion(pose_goal)\n\n                self.target_goal_reached = False\n            self.get_logger().info(f\"{self.target_goal_reached}\")\n\n        except tf2_ros.TransformException as ex:\n            self.get_logger().info(f\"Could not transform {self.source} to {self.target}: {ex}\")\n            pass\n\n        # self.ee_twist_pub.publish(ee_twist_msg)\n        # self.tf_buffer.clear()\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = ArucoDetectorNode()\n\n    executor = MultiThreadedExecutor()\n    executor.add_node(node)\n    executor.spin()\n\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"}\n{"instruction": "Write a ROS2 Python node named task_2a_moveit.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "from std_srvs.srv import Trigger\nfrom threading import Thread\n\nfrom math import cos, sin\nimport math, time\nfrom copy import deepcopy\nimport rclpy\nimport tf2_ros\nfrom tf2_ros import TransformListener,TFMessage\nfrom rclpy.callback_groups import ReentrantCallbackGroup\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import TwistStamped,TransformStamped\nfrom pymoveit2 import MoveIt2\nfrom pymoveit2.robots import ur5\nfrom rclpy.qos import (\n    QoSDurabilityPolicy,\n    QoSHistoryPolicy,\n    QoSProfile,\n    QoSReliabilityPolicy,\n)\nfrom rclpy.duration import Duration\n\nclass Posecontroller(Node):\n    def __init__(self):\n        super().__init__('pose_controller')\n        self.twist_pub=self.create_publisher(TwistStamped,'/pose_node/delta_twist_cmds',10)\n        self.tf_buffer=tf2_ros.Buffer(Duration(seconds=1))\n        self.tf_listener=tf2_ros.TransformListener(self.tf_buffer,self)\n\n        # self.target_pose=[translation.x,translation.y,translation.z]\n        # self.target_pose=[0.3014,0.1023,0.629]\n        self.stop_threshold=0.2\n        self.subscription1=None\n\n        self.timer=self.create_timer(0.02,self.pose_reach_target,ReentrantCallbackGroup())\n\n    def transform_callback(self,msg):\n        try:\n            # print(msg)\n            for transform_stamped in msg.transforms:\n                self.translation = transform_stamped.transform.translation\n                self.rotation = transform_stamped.transform.rotation\n                self.frame_id = transform_stamped.header.frame_id\n                # self.child_frame_id = transform_stamped.header.child_frame_id\n\n                # self.get_logger().info(\n                #     f\"Received transform: Translation({self.translation.x}, {self.translation.y}, {self.translation.z}), \"\n                #     f\"Rotation({self.rotation.x}, {self.rotation.y}, {self.rotation.z}, {self.rotation.w}) \"\n                #     f\"from frame '{self.frame_id}' to frame '{self.child_frame_id}'\"\n                # )\n\n                self.target_pose=[self.translation.x,self.translation.y,self.translation.z]\n        except Exception as e:\n                self.get_logger().error(f\"Error in transform_callback: {e}\")\n\n    def transform_subscription(self):\n        self.subscription1=self.create_subscription(TFMessage,'/tf',self.transform_callback,10)\n\n    def pose_reach_target(self)\n         \n              transform=self.tf_buffer.lookup_transform('base_link','obj_1',rclpy.time.Time().to_msg())\n              translation=transform.transform.translation\n\n              current_pose=[translation.x,translation.y,translation.z]\n              print(current_pose)\n              node.declare_parameter(\"position\", self.target_pose[0]-current_pose[0])\n              node.declare_parameter(\"quat_xyzw\", [0.5, 0.5, 0.5, 0.5])\n              node.declare_parameter(\"position1\", self.target_pose[1]-current_pose[1])\n              node.declare_parameter(\"quat_xyzw1\", [0.5,0.5,0.5,0.5])\n              node.declare_parameter(\"position2\", self.target_pose[2]-current_pose[2])\n              node.declare_parameter(\"quat_xyzw2\", [0.5,0.5,0.5,0.5])\n              node.declare_parameter(\"cartesian\", False)\n\n              callback_group = ReentrantCallbackGroup()\n\n              moveit2 = MoveIt2(\n                node=node,\n                joint_names=ur5.joint_names(),\n                base_link_name=ur5.base_link_name(),\n                end_effector_name=ur5.end_effector_name(),\n                group_name=ur5.MOVE_GROUP_ARM,\n                callback_group=callback_group,\n              )\n              \n            \n             executor = rclpy.executors.MultiThreadedExecutor(2)\n             executor.add_node(node)\n             executor_thread = Thread(target=executor.spin, daemon=True, args=())\n             executor_thread.start()\n\n    # Get parameters\n            position= node.get_parameter(\"position\").get_parameter_value().double_array_value\n            quat_xyzw = node.get_parameter(\"quat_xyzw\").get_parameter_value().double_array_value\n            position1= node.get_parameter(\"position1\").get_parameter_value().double_array_value\n            quat_xyzw1= node.get_parameter(\"quat_xyzw1\").get_parameter_value().double_array_value\n            position2= node.get_parameter(\"position2\").get_parameter_value().double_array_value\n            quat_xyzw2= node.get_parameter(\"quat_xyzw2\").get_parameter_value().double_array_value\n            cartesian = node.get_parameter(\"cartesian\").get_parameter_value().bool_value\n\n    # Move to pose\n    \n         node.get_logger().info(\n        f\"  Moving to {{position: {list(position)}, quat_xyzw: {list(quat_xyzw)}}}\"\n        )\n         moveit2.move_to_pose(position=position, quat_xyzw=quat_xyzw, cartesian=cartesian)\n         moveit2.wait_until_executed()\n         node.get_logger().info(\n            f\"Moving to {{position: {list(position1)}, quat_xyzw: {list(quat_xyzw1)}}}\"\n        )\n        moveit2.move_to_pose(position=position1, quat_xyzw=quat_xyzw1, cartesian=cartesian)\n        moveit2.wait_until_executed()\n        node.get_logger().info(\n           f\"Moving to {{position: {list(position2)}, quat_xyzw: {list(quat_xyzw2)}}}\"\n        )\n        moveit2.move_to_pose(position=position2, quat_xyzw=quat_xyzw2, cartesian=cartesian)\n        moveit2.wait_until_executed()\n        node.get_logger().info(\n          f\"Moving to {{position: {list(position1)}, quat_xyzw: {list(quat_xyzw1)}}}\"\n        )\n        moveit2.move_to_pose(position=position1, quat_xyzw=quat_xyzw1, cartesian=cartesian)\n        moveit2.wait_until_executed()\n\n        node.get_logger().info(\n          f\"Completed\"\n        )\n    def main():\n    rclpy.init()\n    node = Posecontroller()\n    node.transform_subscription()\n    node.pose_reach_target()\n    rclpy.spin(node=node)\n    rclpy.shutdown()\n    \nif __name__ == \"__main__\":\n    main()\n\n\n\n"}\n{"instruction": "Write a ROS2 Python node named demo.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "#!/usr/bin/env python3\nfrom reach import load, runReachStudy\nfrom reach_ros import init_ros, set_parameter, parse_yaml, set_logger_level, update_search_libraries_env\n\nfrom ament_index_python.packages import get_package_share_directory\nimport os\nfrom rclpy.parameter import Parameter\nfrom rclpy.logging import LoggingSeverity\nimport sys\nimport xacro\nimport yaml\n\n\ndef main():\n    # initialize ROS with any parameters provided as arguments\n    init_ros(sys.argv)\n\n    # Set logger level to reduce MoveIt message spam\n    moveit_loggers = [\"moveit_ros\",\n                      \"moveit_kinematics_base\",\n                      \"moveit_rdf_loader\",\n                      \"moveit_robot_model\"]\n    for logger_name in moveit_loggers:\n        try:\n            set_logger_level(logger_name, LoggingSeverity.WARN)\n        except:\n            pass\n\n    # Manually load the parameters necessary for running MoveIt.\n    reach_ros_dir = get_package_share_directory('reach_ros')\n    model_dir = os.path.join(reach_ros_dir, 'demo', 'model')\n\n    # Generate the URDF string from the xacro file\n    urdf = xacro.process(os.path.join(model_dir, 'reach_study.xacro'))\n\n    # Load the SRDF\n    with open(os.path.join(model_dir, 'reach_study.srdf'), 'r') as f:\n        srdf = f.read()\n\n    moveit_parameters = [\n        *parse_yaml(os.path.join(model_dir, 'kinematics.yaml'), 'robot_description_kinematics.'),\n        *parse_yaml(os.path.join(model_dir, 'joint_limits.yaml'), 'robot_description_joint_limits.'),\n        Parameter(name=\"robot_description\", value=urdf),\n        Parameter(name=\"robot_description_semantic\", value=srdf),\n    ]\n\n    for parameter in moveit_parameters:\n        # We don't need to declare the parameters as the node allows undeclared parameters\n        set_parameter(parameter.name, parameter.value)\n\n    with open(os.path.join(reach_ros_dir, 'demo', 'config', 'reach_study.yaml'), 'r') as f:\n        config = yaml.safe_load(f)\n\n    # Update the search libraries environment variable to include the plugin library provided by this package\n    update_search_libraries_env()\n\n    # Disable the optimization steps to make this demo faster and highlight the performance difference\n    config['optimization']['max_steps'] = 0\n\n    print(\"Starting first study with default kinematic parameters\")\n    save_dir = \"/tmp\"\n    study_name = \"study1\"\n    runReachStudy(config, study_name, save_dir, False)\n\n    # Loading the study results\n    results_1 = load(os.path.join(save_dir, study_name, 'reach.db.xml')).calculateResults()\n\n    # Decrease the IK solver time and see if we still find equally good solutions\n    set_parameter(\n        \"robot_description_kinematics.manipulator.kinematics_solver_timeout\", 0.00005)\n\n    print(\"Starting second study with decreased solver resolution.\")\n    study_name = 'study2'\n    runReachStudy(config, study_name, save_dir, False)\n\n    # Loading the study results\n    results_2 = load(os.path.join(save_dir, study_name, 'reach.db.xml')).calculateResults()\n\n    print('Both REACH studies finished')\n    print(f'\\tOriginal parameters: Score {results_1.total_pose_score:.2f}, Reached {results_1.reach_percentage:.2f}%')\n    print(f'\\tModified parameters: Score {results_2.total_pose_score:.2f}, Reached {results_2.reach_percentage:.2f}%')\n\n\nif __name__ == '__main__':\n    main()\n"}\n{"instruction": "Write a ROS2 Python node named start_blocking.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "#!/usr/bin/env python3\n\n# Copyright 2023 Picknik Inc.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#\n#    * Redistributions of source code must retain the above copyright\n#      notice, this list of conditions and the following disclaimer.\n#\n#    * Redistributions in binary form must reproduce the above copyright\n#      notice, this list of conditions and the following disclaimer in the\n#      documentation and/or other materials provided with the distribution.\n#\n#    * Neither the name of the Picknik Inc. nor the names of its\n#      contributors may be used to endorse or promote products derived from\n#      this software without specific prior written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n# POSSIBILITY OF SUCH DAMAGE.\n\n# Start an Objective and block until the Objective has completed execution.\n\nimport argparse\nimport rclpy\n\nfrom moveit_studio_py.objective_manager import ObjectiveManager\n\n\ndef main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        \"objective_name\", type=str, help=\"Name of the Objective to start.\"\n    )\n    args = parser.parse_args()\n\n    rclpy.init()\n\n    objective_manager = ObjectiveManager()\n\n    print(f\"Starting {args.objective_name}.\")\n    success, error_message = objective_manager.start_objective(\n        args.objective_name, blocking=True\n    )\n    if success:\n        print(\"Objective executed successfully!\")\n    else:\n        print(error_message)\n\n    rclpy.shutdown()\n\n\nif __name__ == \"__main__\":\n    main()\n"}\n{"instruction": "Write a ROS2 Python node named moveit2_agent.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "# Copyright (C) 2025 Advanced Micro Devices, Inc.\n# Developed by Robotec.ai sp. z o.o.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport argparse\nimport logging\nfrom pathlib import Path\n\nimport rclpy\nfrom ament_index_python import get_package_share_directory\nfrom control_msgs.action import GripperCommand\nfrom geometry_msgs.msg import Point, Pose, PoseStamped, Quaternion\nfrom langchain_core.language_models.chat_models import BaseChatModel\n\n# generic ros libraries\nfrom langchain_core.language_models.fake_chat_models import FakeChatModel\nfrom launch_param_builder import load_yaml\nfrom moveit.core.kinematic_constraints import construct_joint_constraint\nfrom moveit.core.planning_interface import MotionPlanResponse\nfrom moveit.core.robot_state import RobotState\nfrom moveit.planning import MoveItPy\nfrom moveit.utils import create_params_file_from_dict\nfrom moveit_configs_utils import MoveItConfigsBuilder\nfrom rai.agents import wait_for_shutdown\nfrom rai.agents.base import BaseAgent\nfrom rai.communication.ros2 import (\n    ROS2Connector,\n    ROS2Context,\n)\nfrom rai_interfaces.srv import MoveArm, SetArmJoints\nfrom rclpy.action.client import ActionClient\nfrom rclpy.node import Node\nfrom tf2_geometry_msgs import do_transform_pose\n\nfrom rai_app.control.moveit_utils import decode_error_code\nfrom rai_app.initialization.llms import get_llm_model\n\nGRIPPER_HEIGHT = 0.07\n\n\nclass MoveitToolkit:\n    quaternion = Quaternion(x=0.9238795325112867, y=-0.3826834323650898, z=0.0, w=0.0)\n\n    def __init__(self, namespace: str, ros_package_name) -> None:\n        self.namespace = namespace\n        self.ros_package_name = ros_package_name\n        self.pose_link = f\"{self.namespace}egoarm_wrist_3_link\"\n        self.manipulator_frame = f\"{self.namespace}egoarm_base_link\"\n        self.moveitpy = self.setup_moveitpy()\n\n        self.planning_component = self.moveitpy.get_planning_component(\"base\")\n\n    def setup_moveitpy(self) -> MoveItPy:\n        package_config_dir = (\n            Path(get_package_share_directory(self.ros_package_name)) / \"config\"\n        )\n        joint_limits_yaml_path = package_config_dir / \"joint_limits.yaml\"\n        moveit_controllers_yaml_path = package_config_dir / \"moveit_controllers.yaml\"\n        moveit_cpp_conf = package_config_dir / \"moveit_cpp.yaml\"\n        trajectory_execution_conf = package_config_dir / \"moveit_controllers.yaml\"\n\n        for path in [\n            joint_limits_yaml_path,\n            moveit_controllers_yaml_path,\n            moveit_cpp_conf,\n            trajectory_execution_conf,\n        ]:\n            if not path.exists():\n                raise FileNotFoundError(f\"File {path} doesn't exist\")\n\n        moveit_config = (\n            MoveItConfigsBuilder(\"rbkairos\", package_name=self.ros_package_name)\n            .moveit_cpp(file_path=str(moveit_cpp_conf))\n            .robot_description(\n                mappings={\n                    \"namespace\": f\"{self.namespace}ego\",\n                    \"prefix\": f\"{self.namespace}ego\",\n                    \"ur_type\": \"ur10\",\n                    \"gazebo_classic\": \"false\",\n                    \"gazebo_ignition\": \"false\",\n                }\n            )\n            .trajectory_execution(\n                file_path=str(trajectory_execution_conf),\n                moveit_manage_controllers=False,\n            )\n            .robot_description_semantic(\n                mappings={\n                    \"namespace\": f\"{self.namespace}ego\",\n                    \"prefix\": f\"{self.namespace}ego\",\n                }\n            )\n            .to_moveit_configs()\n        )\n\n        joint_limits_params = self._get_joint_limit_params(joint_limits_yaml_path)\n        moveit_controllers_params = self._get_moveit_controller_params(\n            moveit_controllers_yaml_path\n        )\n\n        moveit_config.joint_limits = {\"robot_description_planning\": joint_limits_params}\n        moveit_config = moveit_config.to_dict()\n        moveit_config.update({\"use_sim_time\": True})\n\n        file = create_params_file_from_dict(\n            moveit_config | moveit_controllers_params, \"/**\"\n        )\n\n        moveitpy = MoveItPy(\n            node_name=\"moveit_py\",\n            launch_params_filepaths=[file],\n            remappings={\"/joint_states\": f\"/{self.namespace}joint_states\"},\n        )\n\n        return moveitpy\n\n    def plan_and_execute(self, pose: Pose):\n        pose_stamped = PoseStamped()\n        pose_stamped.header.frame_id = self.manipulator_frame\n        pose_stamped.pose = pose\n\n        self.planning_component.set_start_state_to_current_state()\n        self.planning_component.set_goal_state(\n            pose_stamped_msg=pose_stamped, pose_link=self.pose_link\n        )\n\n        plan: MotionPlanResponse = self.planning_component.plan()\n        if plan:\n            self.moveitpy.execute(plan.trajectory, controllers=[])\n        else:\n            error_code = plan.error_code\n            error_msg = decode_error_code(error_code)\n            raise RuntimeError(f\"Failed to plan the trajectory: {error_msg}\")\n\n    def set_joint_values(self, joint_values):\n        robot_model = self.moveitpy.get_robot_model()\n        robot_state = RobotState(robot_model)\n        robot_state.joint_positions = joint_values\n        joint_constraint = construct_joint_constraint(\n            robot_state=robot_state,\n            joint_model_group=robot_model.get_joint_model_group(\n                self.planning_component.planning_group_name\n            ),\n        )\n\n        self.planning_component.set_start_state_to_current_state()\n        self.planning_component.set_goal_state(\n            motion_plan_constraints=[joint_constraint]\n        )\n\n        plan = self.planning_component.plan()\n\n        if plan:\n            self.moveitpy.execute(plan.trajectory, controllers=[])\n        else:\n            error_code = plan.error_code\n            error_msg = decode_error_code(error_code)\n            raise RuntimeError(f\"Failed to plan the trajectory: {error_msg}\")\n\n    def _get_joint_limit_params(self, joint_limits_yaml_path: Path) -> dict:\n        joint_limits_params = load_yaml(joint_limits_yaml_path)\n\n        for joint in list(joint_limits_params[\"joint_limits\"]):\n            joint_limits_params[\"joint_limits\"][f\"{self.namespace}{joint}\"] = (\n                joint_limits_params[\"joint_limits\"].pop(joint)\n            )\n        return joint_limits_params\n\n    def _get_moveit_controller_params(self, moveit_controllers_yaml_path: Path) -> dict:\n        moveit_controllers_params = load_yaml(Path(moveit_controllers_yaml_path))\n        controller_names = list(\n            moveit_controllers_params[\"moveit_simple_controller_manager\"][\n                \"controller_names\"\n            ]\n        )\n        for controller in controller_names:\n            params = moveit_controllers_params[\"moveit_simple_controller_manager\"].pop(\n                controller\n            )\n            params[\"joints\"] = [\n                f\"{self.namespace}{joint}\" for joint in params[\"joints\"]\n            ]\n            moveit_controllers_params[\"moveit_simple_controller_manager\"][\n                f\"{self.namespace}{controller}\"\n            ] = params\n        moveit_controllers_params[\"moveit_simple_controller_manager\"][\n            \"controller_names\"\n        ] = [f\"{self.namespace}{controller}\" for controller in controller_names]\n        return moveit_controllers_params\n\n\nclass GripperController(Node):\n    def __init__(self, namespace: str) -> None:\n        super().__init__(\"gripper_controller\")\n        self.gripper_action_client = ActionClient(\n            self, GripperCommand, f\"{namespace}gripper_server\"\n        )\n        pass\n\n    def gripper_command(self, position):\n        \"\"\"Send a command to open or close the gripper.\n\n        Parameters\n        ----------\n        position : float\n            Target gripper position where ``0.0`` closes the gripper and ``1.0``\n            opens it.\n\n        Raises\n        ------\n        RuntimeError\n            If the action server fails to execute the goal.\n        \"\"\"\n        goal = GripperCommand.Goal()\n        goal.command.position = position\n        goal.command.max_effort = 0.0\n        future = self.gripper_action_client.send_goal_async(goal)\n\n        # TODO(boczekbartek): fix this\n        rclpy.spin_until_future_complete(self, future)\n        if future.result() is None:\n            raise RuntimeError(\"Gripper command failed\")\n\n    def close_gripper(self):\n        self.gripper_command(0.0)\n\n    def open_gripper(self):\n        self.gripper_command(1.0)\n\n\nclass ArmController:\n    ARM_STAGING_POSE_DISTANCE = 0.1\n    BASE_JOINT_VALUES = {\n        \"egoarm_wrist_1_joint\": -1.5223139524459839,\n        \"egoarm_wrist_2_joint\": -1.5707021951675415,\n        \"egoarm_wrist_3_joint\": -0.841789960861206,\n        \"egoarm_shoulder_lift_joint\": -2.226045608520508,\n        \"egoarm_elbow_joint\": 2.1977827548980713,\n        \"egoarm_shoulder_pan_joint\": 0.018245616927742958,\n    }\n\n    LOW_BASE_JOINT_VALUES = {\n        \"egoarm_wrist_1_joint\": -2.150108575820923,\n        \"egoarm_wrist_2_joint\": -1.5708777904510498,\n        \"egoarm_wrist_3_joint\": -0.84187912940979,\n        \"egoarm_shoulder_lift_joint\": -0.06665489822626114,\n        \"egoarm_elbow_joint\": 0.6900210380554199,\n        \"egoarm_shoulder_pan_joint\": 0.018179576843976974,\n    }\n\n    def __init__(\n        self, connector: ROS2Connector, namespace: str, ros_package_name: str\n    ) -> None:\n        self.connector = connector\n        self.namespace = namespace\n        self.ros_package_name = ros_package_name\n\n        self.logger = logging.getLogger(__name__)\n\n        self.moveit_toolkit = MoveitToolkit(namespace, ros_package_name)\n\n    def move_arm(self, pose: Pose, frame: str | None = None, retries: int = 3):\n        if frame is None:\n            frame = f\"{self.namespace}egoarm_base_link\"\n        ros2_pose = do_transform_pose(\n            pose,\n            self.connector.get_transform(\n                f\"{self.namespace}egoarm_base_link\", frame, timeout_sec=60\n            ),\n        )\n\n        self.logger.info(\n            f\"Moving arm to {ros2_pose.position.x}, {ros2_pose.position.y}, {ros2_pose.position.z}\"\n        )\n        for _ in range(retries):\n            try:\n                self.moveit_toolkit.plan_and_execute(ros2_pose)\n                return True\n            except RuntimeError as e:\n                self.logger.error(e)\n                continue\n        raise RuntimeError(\"Failed to move arm\")\n\n    def move_arm_to_base_pose(self):\n        self.moveit_toolkit.set_joint_values(self.BASE_JOINT_VALUES)\n\n    def move_arm_to_low_base_pose(self):\n        self.moveit_toolkit.set_joint_values(self.LOW_BASE_JOINT_VALUES)\n\n    def move_arm_to_staging_pose(self, target_pose: Pose, object_height: float):\n        self.move_arm(\n            Pose(\n                position=Point(\n                    x=target_pose.position.x,\n                    y=target_pose.position.y,\n                    z=target_pose.position.z\n                    + object_height\n                    + self.ARM_STAGING_POSE_DISTANCE,\n                )\n            ),\n            \"odom\",\n        )\n\n    def move_arm_to_gripping_pose(self, target_pose: Pose, object_height: float):\n        self.move_arm(\n            Pose(\n                position=Point(\n                    x=target_pose.position.x,\n                    y=target_pose.position.y,\n                    z=target_pose.position.z + object_height,\n                )\n            ),\n            \"odom\",\n        )\n\n\nclass ManipulatorController:\n    def __init__(\n        self,\n        connector: ROS2Connector,\n        namespace: str = \"\",\n        ros_package_name: str = \"robotec_kairos_ur10\",\n    ) -> None:\n        self.ros_package_name = ros_package_name\n        self.connector = connector\n        self.node = self.connector.node\n        self.namespace = namespace\n\n        self.logger = self.node.get_logger()\n\n        self.gripper_controller = GripperController(self.namespace)\n        self.arm_controller = ArmController(\n            self.connector, self.namespace, self.ros_package_name\n        )\n\n    def open_gripper(self):\n        self.gripper_controller.open_gripper()\n\n    def close_gripper(self):\n        self.gripper_controller.close_gripper()\n\n    def move_arm(self, pose, frame: str | None = None):\n        self.arm_controller.move_arm(pose, frame)\n\n    def move_arm_to_base_pose(self):\n        self.arm_controller.move_arm_to_base_pose()\n\n    def move_arm_to_low_base_pose(self):\n        self.arm_controller.move_arm_to_low_base_pose()\n\n    def move_arm_to_staging_pose(self, target_pose: Pose, object_height: float):\n        self.arm_controller.move_arm_to_staging_pose(target_pose, object_height)\n\n    def move_arm_to_gripping_pose(self, target_pose: Pose, object_height: float):\n        self.arm_controller.move_arm_to_gripping_pose(target_pose, object_height)\n\n\ndef logging_wrapper(func):\n    def wrapper(self, *args, **kwargs):\n        RED = \"\\033[91m\"\n        GREEN = \"\\033[92m\"\n        RESET = \"\\033[0m\"\n        self.connector.node.get_logger().info(\n            f\"{GREEN}Calling {func.__name__} with args: {args} and kwargs: {kwargs}{RESET}\"\n        )\n        result = func(self, *args, **kwargs)\n        color = GREEN if result.success else RED\n        msg = f\"{color}Result of {func.__name__}: success={result.success}{RESET}\"\n        msg += f\" {result.report}\" if not result.success else \"\"\n        self.connector.node.get_logger().info(msg)\n        return result\n\n    return wrapper\n\n\nclass MoveIt2Agent(BaseAgent):\n    SYSTEM_PROMPT: str = \"\"\"\n    You are an agent responsible for moving the robotic arm to a specified position and gripper state.\n    You work alongside other agents and specialists to accomplish the task.\n    You work within the MoveIt2, ROS 2 framework.\n    When asked to debug, check the logs and provide short and actionable summary for the other agents.\n    \"\"\"\n\n    def __init__(self, llm: BaseChatModel | None = None):\n        super().__init__()\n        self.connector = ROS2Connector(executor_type=\"single_threaded\")\n        self.manipulator_controller = ManipulatorController(\n            connector=self.connector,\n            namespace=\"\",\n            ros_package_name=\"robotec_kairos_ur10\",\n        )\n\n        if llm is None:\n            self.llm = FakeChatModel()\n        else:\n            self.llm = llm\n\n        self.connector.create_service(\n            service_name=\"/rai/moveit2/move_arm\",\n            service_type=\"rai_interfaces/srv/MoveArm\",\n            on_request=self.move_arm,\n        )\n        self.connector.create_service(\n            service_name=\"/rai/moveit2/set_arm_joints\",\n            service_type=\"rai_interfaces/srv/SetArmJoints\",\n            on_request=self.set_arm_joints,\n        )\n\n        self.logger.info(\"MoveIt2Agent initialized\")\n\n    def formulate_prompt(self, prompt: str, logs: str) -> str:\n        return self.SYSTEM_PROMPT + \"\\n\\n Task:\\n\" + prompt + \"\\n\\n Logs:\\n\" + logs\n\n    @logging_wrapper\n    def set_arm_joints(\n        self, request: SetArmJoints.Request, response: SetArmJoints.Response\n    ):\n        self.logger.info(\n            f\"Setting arm joints: {request.joints_names} to {request.joints}\"\n        )\n        try:\n            joints = {k: v for k, v in zip(request.joints_names, request.joints)}\n            self.manipulator_controller.arm_controller.moveit_toolkit.set_joint_values(\n                joints\n            )\n            response.success = True\n            response.report = \"Moved arm to position.\"\n            return response\n        except Exception as e:\n            self.logger.error(f\"Failed to set arm joints: {e}\")\n            response.success = False\n            response.report = str(e)\n        return response\n\n    def _is_neutral_pose(self, pose: PoseStamped) -> bool:\n        neutral_pose = PoseStamped().pose\n        test_pose = pose.pose\n        return (\n            test_pose.position.x == neutral_pose.position.x\n            and test_pose.position.y == neutral_pose.position.y\n            and test_pose.position.z == neutral_pose.position.z\n            and test_pose.orientation.x == neutral_pose.orientation.x\n            and test_pose.orientation.y == neutral_pose.orientation.y\n            and test_pose.orientation.z == neutral_pose.orientation.z\n            and test_pose.orientation.w == neutral_pose.orientation.w\n        )\n\n    @logging_wrapper\n    def move_arm(self, request: MoveArm.Request, response: MoveArm.Response):\n        if not self._is_neutral_pose(\n            request.target_pose\n        ):  # empty pose, gripper state only\n            try:\n                self.manipulator_controller.move_arm(\n                    pose=request.target_pose.pose,\n                    frame=request.target_pose.header.frame_id,\n                )\n            except Exception as e:\n                response.success = False\n                llm_response = self.llm.invoke(\n                    \"The arm failed to move to the position. Check the logs and provide a short summary.\"\n                    + str(e)\n                )\n                response.report = llm_response.content\n                return response\n\n        if request.gripper_state == 0:\n            response.success = True\n            response.report = \"Moved arm to position.\"\n        elif request.gripper_state == 1:\n            try:\n                self.manipulator_controller.open_gripper()\n                response.success = True\n                response.report = \"Moved arm to position and opened gripper.\"\n            except Exception as e:\n                self.logger.error(f\"Failed to open gripper: {e}\")\n                response.success = False\n                llm_response = self.llm.invoke(\n                    self.formulate_prompt(\"The arm failed to open the gripper.\", str(e))\n                )\n                response.report = llm_response.content\n                return response\n        elif request.gripper_state == 2:\n            try:\n                self.manipulator_controller.close_gripper()\n                response.success = True\n                response.report = \"Moved arm to position and closed gripper.\"\n            except Exception as e:\n                self.logger.error(f\"Failed to close gripper: {e}\")\n                response.success = False\n                llm_response = self.llm.invoke(\n                    self.formulate_prompt(\n                        \"The arm failed to close the gripper.\", str(e)\n                    )\n                )\n                response.report = llm_response.content\n                return response\n        else:\n            response.success = False\n            response.report = \"Invalid gripper state.\"\n        return response\n\n    def run(self):\n        pass\n\n    def stop(self):\n        self.connector.shutdown()\n\n\n@ROS2Context()\ndef main():\n    parser = argparse.ArgumentParser(description=\"Run MoveIt2 agent\")\n    parser.add_argument(\"--test-mode\", action=\"store_true\", help=\"Run in test mode\")\n    args = parser.parse_args()\n    if args.test_mode:\n        llm = FakeChatModel()\n    else:\n        llm = get_llm_model(config_name=\"general\")\n    agent = MoveIt2Agent(llm=llm)\n    agent.run()\n\n    wait_for_shutdown([agent])\n\n\nif __name__ == \"__main__\":\n    main()\n"}\n{"instruction": "Write a ROS2 Python node named mover_right_arm.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "import rclpy\nimport sys\nimport geometry_msgs.msg\nfrom moveit_commander import MoveGroupCommander\nfrom moveit_commander.conversions import pose_to_list\n\ndef main():\n    rclpy.init()\n    node = rclpy.create_node('mover_right_arm_node')\n\n    # Inicializar el objeto MoveGroupCommander para el grupo 'right_arm'\n    move_group = MoveGroupCommander('right_arm', node=node)\n\n    # Definir la posición y orientación del objetivo\n    pose_goal = geometry_msgs.msg.Pose()\n\n    # Posición (Translation)\n    pose_goal.position.x = -0.538\n    pose_goal.position.y = 0.039\n    pose_goal.position.z = 0.823\n\n    # Orientación (Quaternion)\n    pose_goal.orientation.x = -0.001\n    pose_goal.orientation.y = 0.609\n    pose_goal.orientation.z = -0.001\n    pose_goal.orientation.w = 0.793\n\n    # Establecer el objetivo de pose para el grupo de movimiento\n    move_group.set_pose_target(pose_goal)\n    node.get_logger().info(f\"Estableciendo el objetivo de pose para right_arm: {pose_to_list(pose_goal)}\")\n\n    # Llamar al planificador para calcular el plan y ejecutarlo\n    success = move_group.go(wait=True)\n\n    if success:\n        node.get_logger().info(\"Planificación y ejecución completadas con éxito.\")\n    else:\n        node.get_logger().error(\"Error en la planificación y ejecución.\")\n\n    # Asegurar que no haya movimiento residual\n    move_group.stop()\n\n    # Limpiar los objetivos de pose después de la planificación\n    move_group.clear_pose_targets()\n\n    # Cierra rclpy\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n\n"}\n{"instruction": "Write a ROS2 Python node named ex_collision_primitive.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "#!/usr/bin/env python3\n\"\"\"\nExample of adding and removing a collision object with a primitive geometry.\n- ros2 run pymoveit2 ex_collision_primitive.py --ros-args -p shape:=\"sphere\" -p position:=\"[0.5, 0.0, 0.5]\" -p dimensions:=\"[0.04]\"\n- ros2 run pymoveit2 ex_collision_primitive.py --ros-args -p shape:=\"cylinder\" -p position:=\"[0.2, 0.0, -0.045]\" -p quat_xyzw:=\"[0.0, 0.0, 0.0, 1.0]\" -p dimensions:=\"[0.04, 0.02]\"\n- ros2 run pymoveit2 ex_collision_primitive.py --ros-args -p action:=\"remove\" -p shape:=\"sphere\"\n- ros2 run pymoveit2 ex_collision_primitive.py --ros-args -p action:=\"move\" -p shape:=\"sphere\" -p position:=\"[0.2, 0.0, 0.2]\"\n\"\"\"\n\nfrom threading import Thread\n\nimport rclpy\nfrom rclpy.callback_groups import ReentrantCallbackGroup\nfrom rclpy.node import Node\n\nfrom pymoveit2 import MoveIt2\nfrom pymoveit2.robots import fetch as robot\n\n\ndef main():\n    rclpy.init()\n\n    # Create node for this example\n    node = Node(\"ex_collision_primitive\")\n\n    # Declare parameter for joint positions\n    node.declare_parameter(\n        \"shape\",\n        \"box\",\n    )\n    node.declare_parameter(\n        \"action\",\n        \"add\",\n    )\n    node.declare_parameter(\"position\", [0.5, 0.0, 0.5])\n    node.declare_parameter(\"quat_xyzw\", [0.0, 0.0, -0.7071, 0.7071])\n    node.declare_parameter(\"dimensions\", [0.1, 0.1, 0.1])\n\n    # Create callback group that allows execution of callbacks in parallel without restrictions\n    callback_group = ReentrantCallbackGroup()\n\n    # Create MoveIt 2 interface\n    moveit2 = MoveIt2(\n        node=node,\n        joint_names=robot.joint_names(),\n        base_link_name=robot.base_link_name(),\n        end_effector_name=robot.end_effector_name(),\n        group_name=robot.MOVE_GROUP_ARM,\n        callback_group=callback_group,\n    )\n\n    # Spin the node in background thread(s) and wait a bit for initialization\n    executor = rclpy.executors.MultiThreadedExecutor(2)\n    executor.add_node(node)\n    executor_thread = Thread(target=executor.spin, daemon=True, args=())\n    executor_thread.start()\n    node.create_rate(1.0).sleep()\n\n    # Get parameters\n    shape = node.get_parameter(\"shape\").get_parameter_value().string_value\n    action = node.get_parameter(\"action\").get_parameter_value().string_value\n    position = node.get_parameter(\"position\").get_parameter_value().double_array_value\n    quat_xyzw = node.get_parameter(\"quat_xyzw\").get_parameter_value().double_array_value\n    dimensions = (\n        node.get_parameter(\"dimensions\").get_parameter_value().double_array_value\n    )\n\n    # Use the name of the primitive shape as the ID\n    object_id = shape\n\n    if action == \"add\":\n        # Add collision primitive\n        node.get_logger().info(\n            f\"Adding collision primitive of type '{shape}' \"\n            f\"{{position: {list(position)}, quat_xyzw: {list(quat_xyzw)}, dimensions: {list(dimensions)}}}\"\n        )\n        if shape == \"box\":\n            moveit2.add_collision_box(\n                id=object_id, position=position, quat_xyzw=quat_xyzw, size=dimensions\n            )\n        elif shape == \"sphere\":\n            moveit2.add_collision_sphere(\n                id=object_id, position=position, radius=dimensions[0]\n            )\n        elif shape == \"cylinder\":\n            moveit2.add_collision_cylinder(\n                id=object_id,\n                position=position,\n                quat_xyzw=quat_xyzw,\n                height=dimensions[0],\n                radius=dimensions[1],\n            )\n        elif shape == \"cone\":\n            moveit2.add_collision_cone(\n                id=object_id,\n                position=position,\n                quat_xyzw=quat_xyzw,\n                height=dimensions[0],\n                radius=dimensions[1],\n            )\n        else:\n            raise ValueError(f\"Unknown shape '{shape}'\")\n    elif action == \"remove\":\n        # Remove collision primitive\n        node.get_logger().info(f\"Removing collision primitive with ID '{object_id}'\")\n        moveit2.remove_collision_object(id=object_id)\n    elif action == \"move\":\n        # Move collision primitive\n        node.get_logger().info(\n            f\"Moving collision primitive with ID '{object_id}' to \"\n            f\"{{position: {list(position)}, quat_xyzw: {list(quat_xyzw)}}}\"\n        )\n        moveit2.move_collision(id=object_id, position=position, quat_xyzw=quat_xyzw)\n    else:\n        raise ValueError(\n            f\"Unknown action '{action}'. Valid values are 'add', 'remove', 'move'\"\n        )\n\n    rclpy.shutdown()\n    executor_thread.join()\n    exit(0)\n\n\nif __name__ == \"__main__\":\n    main()\n"}\n{"instruction": "Write a ROS2 Python node named integrated_pick_place_system.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "#!/usr/bin/env python3\n\"\"\"\nIntegrated Pick-Place System with Voice/Text, Depth, LLM, and Visual Feedback\nFeatures:\n- Voice and text command processing with LLM\n- Depth-based 3D object localization\n- Visual markers in RViz showing detected objects\n- Camera-suction offset compensation (50mm)\n- Automatic home position after task completion\n- Real-time feedback\n\"\"\"\n\nimport rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import PoseStamped, Pose, Point\nfrom std_msgs.msg import String, ColorRGBA\nfrom sensor_msgs.msg import Image, CameraInfo\nfrom visualization_msgs.msg import Marker, MarkerArray\nfrom moveit_msgs.action import MoveGroup\nfrom rclpy.action import ActionClient\nfrom cv_bridge import CvBridge\nimport numpy as np\nimport threading\nimport json\nimport time\nimport tf2_ros\nfrom rclpy.duration import Duration\n\n# Voice recognition (optional)\ntry:\n    import speech_recognition as sr\n    SPEECH_AVAILABLE = True\nexcept ImportError:\n    SPEECH_AVAILABLE = False\n    print(\"⚠️  Speech recognition not available. Install: pip install SpeechRecognition pyaudio\")\n\n# LLM integration (optional)\ntry:\n    import requests\n    LLM_AVAILABLE = True\nexcept ImportError:\n    LLM_AVAILABLE = False\n\n\nclass IntegratedPickPlaceSystem(Node):\n    def __init__(self):\n        super().__init__('integrated_pick_place_system')\n        \n        # ============ PARAMETERS ============\n        self.declare_parameter('camera_offset_x', 0.050)  # 50mm camera offset from suction (105-55=50mm)\n        self.declare_parameter('home_position', [0.2, 0.0, 0.25])\n        self.declare_parameter('llm_enabled', False)\n        self.declare_parameter('llm_api_url', 'http://localhost:11434/api/generate')  # Ollama default\n        \n        self.camera_offset_x = self.get_parameter('camera_offset_x').value\n        self.home_pos = self.get_parameter('home_position').value\n        self.llm_enabled = self.get_parameter('llm_enabled').value\n        self.llm_api = self.get_parameter('llm_api_url').value\n        \n        # ============ ROS INTERFACES ============\n        # Subscribers\n        self.detection_sub = self.create_subscription(\n            String, '/yolo/detections', self.detection_callback, 10)\n        self.depth_sub = self.create_subscription(\n            Image, '/camera/depth/image_raw', self.depth_callback, 10)\n        self.camera_info_sub = self.create_subscription(\n            CameraInfo, '/camera/camera_info', self.camera_info_callback, 10)\n        self.rgb_sub = self.create_subscription(\n            Image, '/camera/image_raw', self.rgb_callback, 10)\n        \n        # Publishers\n        self.marker_pub = self.create_publisher(MarkerArray, '/detected_objects_markers', 10)\n        self.target_pose_pub = self.create_publisher(PoseStamped, '/target_pose', 10)\n        self.status_pub = self.create_publisher(String, '/robot/status', 10)\n        self.command_pub = self.create_publisher(String, '/robot/command', 10)\n        \n        # MoveIt Action Client\n        self.move_group_client = ActionClient(self, MoveGroup, '/move_action')\n        self.get_logger().info('⏳ Waiting for MoveGroup action server...')\n        # Don't block - continue initialization\n        \n        # TF buffer / listener for transforms\n        self.tf_buffer = tf2_ros.Buffer()\n        self.tf_listener = tf2_ros.TransformListener(self.tf_buffer, self)\n        \n        # ============ STATE VARIABLES ============\n        self.bridge = CvBridge()\n        self.camera_info = None\n        self.depth_image = None\n        self.rgb_image = None\n        self.current_detections = []\n        self.current_position = list(self.home_pos)\n        self.is_busy = False\n        self.task_history = []\n        \n        # Voice recognition\n        if SPEECH_AVAILABLE:\n            self.recognizer = sr.Recognizer()\n            self.microphone = sr.Microphone()\n            self.get_logger().info('🎤 Voice recognition ready')\n        \n        # ============ STARTUP ============\n        self.get_logger().info('=' * 70)\n        self.get_logger().info('🤖 INTEGRATED PICK-PLACE SYSTEM INITIALIZED')\n        self.get_logger().info('=' * 70)\n        self.get_logger().info(f'📏 Camera offset: {self.camera_offset_x*1000:.0f}mm')\n        self.get_logger().info(f'🏠 Home position: {self.home_pos}')\n        self.get_logger().info(f'🧠 LLM enabled: {self.llm_enabled}')\n        self.get_logger().info(f'🎤 Voice enabled: {SPEECH_AVAILABLE}')\n        self.get_logger().info('=' * 70)\n        \n    # ============ CAMERA CALLBACKS ============\n    \n    def camera_info_callback(self, msg):\n        \"\"\"Store camera calibration parameters for depth-to-3D conversion\"\"\"\n        if self.camera_info is None:\n            self.camera_info = msg\n            self.get_logger().info(f'📷 Camera calibration received: {msg.width}x{msg.height}')\n            self.fx = msg.k[0]  # Focal length X\n            self.fy = msg.k[4]  # Focal length Y\n            self.cx = msg.k[2]  # Principal point X\n            self.cy = msg.k[5]  # Principal point Y\n    \n    def depth_callback(self, msg):\n        \"\"\"Store latest depth image\"\"\"\n        try:\n            self.depth_image = self.bridge.imgmsg_to_cv2(msg, desired_encoding='passthrough')\n        except Exception as e:\n            self.get_logger().error(f'Depth conversion error: {e}')\n    \n    def rgb_callback(self, msg):\n        \"\"\"Store latest RGB image\"\"\"\n        try:\n            self.rgb_image = self.bridge.imgmsg_to_cv2(msg, desired_encoding='bgr8')\n        except Exception as e:\n            self.get_logger().error(f'RGB conversion error: {e}')\n    \n    def detection_callback(self, msg):\n        \"\"\"Process YOLO detections and create 3D positions with depth\"\"\"\n        try:\n            detections = json.loads(msg.data)\n            self.current_detections = []\n            markers = MarkerArray()\n            \n            for idx, det in enumerate(detections):\n                # Parse detection: \"small red cube at (x, y, conf)\"\n                obj_class = det.get('class', 'unknown')\n                bbox = det.get('bbox', [0, 0, 0, 0])  # [x_min, y_min, x_max, y_max]\n                confidence = det.get('confidence', 0.0)\n                \n                # Calculate bbox center in image coordinates\n                img_x = int((bbox[0] + bbox[2]) / 2)\n                img_y = int((bbox[1] + bbox[3]) / 2)\n                \n                # Get 3D position from depth (in camera frame)\n                position_3d = self.get_3d_position(img_x, img_y)\n\n                if position_3d:\n                    camera_x, camera_y, camera_z = position_3d\n\n                    # Build a PoseStamped in camera frame\n                    from geometry_msgs.msg import PoseStamped\n                    pose_cam = PoseStamped()\n                    pose_cam.header.frame_id = 'camera_link'\n                    pose_cam.header.stamp = self.get_clock().now().to_msg()\n                    pose_cam.pose.position.x = camera_x\n                    pose_cam.pose.position.y = camera_y\n                    pose_cam.pose.position.z = camera_z\n                    pose_cam.pose.orientation.w = 1.0\n\n                    # Transform camera pose to base_link so markers align with robot base\n                    try:\n                        pose_base = self.tf_buffer.transform(pose_cam, 'base_link', timeout=Duration(seconds=1.0))\n                        base_x = pose_base.pose.position.x\n                        base_y = pose_base.pose.position.y\n                        base_z = pose_base.pose.position.z\n                    except Exception as e:\n                        # If TF fails, fall back to using camera-frame coordinates (assume alignment)\n                        self.get_logger().warn(f'TF transform failed: {e} - publishing in camera frame')\n                        base_x, base_y, base_z = camera_x, camera_y, camera_z\n\n                    # Apply camera-suction offset compensation in base frame (camera X ahead of suction)\n                    suction_x = base_x - self.camera_offset_x\n                    suction_y = base_y\n                    suction_z = base_z\n\n                    detection_info = {\n                        'class': obj_class,\n                        'confidence': confidence,\n                        'camera_pos': (camera_x, camera_y, camera_z),\n                        'camera_pos_base': (base_x, base_y, base_z),\n                        'suction_pos': (suction_x, suction_y, suction_z),\n                        'bbox': bbox\n                    }\n                    self.current_detections.append(detection_info)\n\n                    # Create visual marker for RViz in base_link frame\n                    marker = self.create_marker(idx, obj_class, base_x, base_y, base_z, confidence)\n                    markers.markers.append(marker)\n\n                    # Also create a marker for suction target position in base_link\n                    suction_marker = self.create_suction_marker(idx, suction_x, suction_y, suction_z)\n                    markers.markers.append(suction_marker)\n            \n            # Publish markers to RViz\n            if markers.markers:\n                self.marker_pub.publish(markers)\n                self.get_logger().info(f'📍 Visualized {len(self.current_detections)} objects in RViz')\n                \n        except Exception as e:\n            self.get_logger().error(f'Detection processing error: {e}')\n    \n    def get_3d_position(self, img_x, img_y):\n        \"\"\"Convert 2D image coordinates + depth to 3D position in camera frame\"\"\"\n        if self.depth_image is None or self.camera_info is None:\n            return None\n        \n        try:\n            # Get depth value at pixel location\n            depth = self.depth_image[img_y, img_x]\n            \n            if depth <= 0 or np.isnan(depth) or np.isinf(depth):\n                # Invalid depth, use default\n                depth = 0.3  # 30cm default\n                self.get_logger().warn(f'Invalid depth at ({img_x},{img_y}), using default: {depth}m')\n            \n            # Convert to meters if needed\n            if depth > 100:  # Likely in millimeters\n                depth = depth / 1000.0\n            \n            # Convert pixel coordinates to 3D using camera intrinsics\n            # X = (u - cx) * Z / fx\n            # Y = (v - cy) * Z / fy\n            # Z = depth\n            x = (img_x - self.cx) * depth / self.fx\n            y = (img_y - self.cy) * depth / self.fy\n            z = depth\n            \n            return (x, y, z)\n            \n        except Exception as e:\n            self.get_logger().error(f'3D position calculation error: {e}')\n            return None\n    \n    def create_marker(self, marker_id, obj_class, x, y, z, confidence):\n        \"\"\"Create visualization marker for detected object (camera position)\"\"\"\n        marker = Marker()\n        marker.header.frame_id = 'camera_link'\n        marker.header.stamp = self.get_clock().now().to_msg()\n        marker.ns = 'detected_objects'\n        marker.id = marker_id * 2\n        marker.type = Marker.SPHERE\n        marker.action = Marker.ADD\n        \n        # Position (where camera sees it)\n        marker.pose.position.x = x\n        marker.pose.position.y = y\n        marker.pose.position.z = z\n        marker.pose.orientation.w = 1.0\n        \n        # Size\n        marker.scale.x = 0.05\n        marker.scale.y = 0.05\n        marker.scale.z = 0.05\n        \n        # Color based on object class\n        colors = {\n            'cube': (1.0, 0.0, 0.0, 0.8),      # Red\n            'sphere': (0.0, 1.0, 0.0, 0.8),    # Green\n            'cylinder': (0.0, 0.0, 1.0, 0.8),  # Blue\n            'pyramid': (1.0, 1.0, 0.0, 0.8),   # Yellow\n        }\n        color = colors.get(obj_class, (1.0, 1.0, 1.0, 0.8))\n        marker.color.r, marker.color.g, marker.color.b, marker.color.a = color\n        \n        marker.lifetime.sec = 2  # Disappear after 2 seconds\n        \n        return marker\n    \n    def create_suction_marker(self, marker_id, x, y, z):\n        \"\"\"Create visualization marker for suction target position\"\"\"\n        marker = Marker()\n        marker.header.frame_id = 'camera_link'\n        marker.header.stamp = self.get_clock().now().to_msg()\n        marker.ns = 'suction_targets'\n        marker.id = marker_id * 2 + 1\n        marker.type = Marker.ARROW\n        marker.action = Marker.ADD\n        \n        # Position (where suction will move)\n        marker.pose.position.x = x\n        marker.pose.position.y = y\n        marker.pose.position.z = z\n        marker.pose.orientation.w = 1.0\n        \n        # Size\n        marker.scale.x = 0.03\n        marker.scale.y = 0.01\n        marker.scale.z = 0.01\n        \n        # Color - Purple for suction target\n        marker.color.r = 0.5\n        marker.color.g = 0.0\n        marker.color.b = 1.0\n        marker.color.a = 0.9\n        \n        marker.lifetime.sec = 2\n        \n        return marker\n    \n    # ============ COMMAND PROCESSING ============\n    \n    def process_command(self, command_text):\n        \"\"\"Process text or voice command, optionally using LLM\"\"\"\n        command_text = command_text.lower().strip()\n        self.get_logger().info(f'📝 Processing command: \"{command_text}\"')\n        \n        # Use LLM to parse command if enabled\n        if self.llm_enabled and LLM_AVAILABLE:\n            parsed = self.parse_command_with_llm(command_text)\n        else:\n            parsed = self.parse_command_simple(command_text)\n        \n        if not parsed:\n            self.get_logger().warn(f'❌ Could not understand command: \"{command_text}\"')\n            return False\n        \n        # Execute action\n        return self.execute_action(parsed)\n    \n    def parse_command_simple(self, text):\n        \"\"\"Simple rule-based command parsing\"\"\"\n        text = text.lower()\n        \n        # Go home\n        if 'home' in text or 'reset' in text:\n            return {'action': 'go_home'}\n        \n        # Pick commands\n        if 'pick' in text:\n            # Extract object type\n            objects = ['cube', 'sphere', 'cylinder', 'pyramid', 'bottle', 'cup']\n            for obj in objects:\n                if obj in text:\n                    # Extract placement if specified\n                    placement = 'box_a'  # default\n                    if 'box a' in text or 'boxa' in text:\n                        placement = 'box_a'\n                    elif 'box b' in text or 'boxb' in text:\n                        placement = 'box_b'\n                    elif 'bin' in text:\n                        placement = 'bin'\n                    \n                    return {\n                        'action': 'pick_and_place',\n                        'object': obj,\n                        'placement': placement\n                    }\n        \n        # Movement commands\n        movements = {\n            'left': {'action': 'move', 'direction': 'left'},\n            'right': {'action': 'move', 'direction': 'right'},\n            'up': {'action': 'move', 'direction': 'up'},\n            'down': {'action': 'move', 'direction': 'down'},\n            'forward': {'action': 'move', 'direction': 'forward'},\n            'back': {'action': 'move', 'direction': 'back'},\n        }\n        \n        for keyword, result in movements.items():\n            if keyword in text:\n                return result\n        \n        return None\n    \n    def parse_command_with_llm(self, text):\n        \"\"\"Use LLM to parse natural language command\"\"\"\n        try:\n            prompt = f\"\"\"Parse this robot command into JSON format. Return ONLY valid JSON.\n            \nCommand: \"{text}\"\n\nReturn format:\n{{\"action\": \"pick_and_place\" | \"move\" | \"go_home\", \"object\": \"cube|sphere|cylinder|pyramid\", \"placement\": \"box_a|box_b|bin\", \"direction\": \"left|right|up|down|forward|back\"}}\n\nExamples:\n\"pick the red cube\" -> {{\"action\": \"pick_and_place\", \"object\": \"cube\", \"placement\": \"box_a\"}}\n\"move left\" -> {{\"action\": \"move\", \"direction\": \"left\"}}\n\"go home\" -> {{\"action\": \"go_home\"}}\n\nJSON:\"\"\"\n            \n            response = requests.post(\n                self.llm_api,\n                json={\n                    'model': 'llama2',\n                    'prompt': prompt,\n                    'stream': False,\n                    'temperature': 0.1\n                },\n                timeout=5.0\n            )\n            \n            if response.status_code == 200:\n                result = response.json()\n                llm_output = result.get('response', '')\n                # Extract JSON from response\n                import re\n                json_match = re.search(r'\\{.*\\}', llm_output)\n                if json_match:\n                    return json.loads(json_match.group())\n            \n        except Exception as e:\n            self.get_logger().warn(f'LLM parsing failed: {e}, using simple parser')\n        \n        return self.parse_command_simple(text)\n    \n    # ============ ACTION EXECUTION ============\n    \n    def execute_action(self, parsed_command):\n        \"\"\"Execute parsed command\"\"\"\n        if self.is_busy:\n            self.get_logger().warn('⏳ Robot is busy, please wait...')\n            return False\n        \n        action = parsed_command.get('action')\n        \n        if action == 'go_home':\n            return self.go_home()\n        \n        elif action == 'move':\n            direction = parsed_command.get('direction')\n            return self.move_relative(direction)\n        \n        elif action == 'pick_and_place':\n            obj_type = parsed_command.get('object')\n            placement = parsed_command.get('placement', 'box_a')\n            return self.pick_and_place(obj_type, placement)\n        \n        return False\n    \n    def go_home(self):\n        \"\"\"Move robot to home position\"\"\"\n        self.get_logger().info('🏠 Going to home position...')\n        self.is_busy = True\n        \n        try:\n            x, y, z = self.home_pos\n            success = self.move_to_position(x, y, z, 'HOME')\n            self.current_position = list(self.home_pos)\n            self.status_pub.publish(String(data='at_home'))\n            return success\n        finally:\n            self.is_busy = False\n    \n    def move_relative(self, direction, step=0.05):\n        \"\"\"Move robot in specified direction\"\"\"\n        self.get_logger().info(f'↔️ Moving {direction}...')\n        self.is_busy = True\n        \n        try:\n            x, y, z = self.current_position\n            \n            if direction == 'left':\n                y += step\n            elif direction == 'right':\n                y -= step\n            elif direction == 'up':\n                z += step\n            elif direction == 'down':\n                z -= step\n            elif direction == 'forward':\n                x += step\n            elif direction == 'back':\n                x -= step\n            \n            success = self.move_to_position(x, y, z, direction.upper())\n            if success:\n                self.current_position = [x, y, z]\n            return success\n        finally:\n            self.is_busy = False\n    \n    def pick_and_place(self, object_type, placement):\n        \"\"\"Pick specified object and place it\"\"\"\n        self.get_logger().info(f'🎯 Pick {object_type} and place in {placement}')\n        self.is_busy = True\n        \n        try:\n            # Find object in current detections\n            target_det = None\n            for det in self.current_detections:\n                if object_type in det['class'].lower():\n                    target_det = det\n                    break\n            \n            if not target_det:\n                self.get_logger().error(f'❌ Object \"{object_type}\" not found in view!')\n                return False\n            \n            # Get suction position (already offset-compensated)\n            suction_x, suction_y, suction_z = target_det['suction_pos']\n            \n            self.get_logger().info(f'📸 Camera sees at: ({target_det[\"camera_pos\"][0]:.3f}, {target_det[\"camera_pos\"][1]:.3f}, {target_det[\"camera_pos\"][2]:.3f})')\n            self.get_logger().info(f'🔧 Suction moves to: ({suction_x:.3f}, {suction_y:.3f}, {suction_z:.3f})')\n            self.get_logger().info(f'   ⚙️ Compensated {self.camera_offset_x*1000:.0f}mm camera offset')\n            \n            # Move to pick position\n            if not self.move_to_position(suction_x, suction_y, suction_z, 'PICK'):\n                return False\n            \n            # Simulate gripper close\n            time.sleep(0.5)\n            self.get_logger().info('🤏 Closing gripper...')\n            \n            # Move up\n            if not self.move_to_position(suction_x, suction_y, suction_z + 0.1, 'LIFT'):\n                return False\n            \n            # Move to placement location\n            place_positions = {\n                'box_a': (0.3, 0.15, 0.15),\n                'box_b': (0.3, -0.15, 0.15),\n                'bin': (0.35, 0.0, 0.1)\n            }\n            place_x, place_y, place_z = place_positions.get(placement, place_positions['box_a'])\n            \n            if not self.move_to_position(place_x, place_y, place_z, 'PLACE'):\n                return False\n            \n            # Simulate gripper open\n            time.sleep(0.5)\n            self.get_logger().info('✋ Opening gripper...')\n            \n            # Record task\n            self.task_history.append({\n                'object': object_type,\n                'placement': placement,\n                'timestamp': time.time()\n            })\n            \n            self.get_logger().info(f'✅ Task complete! Picked {object_type} → {placement}')\n            \n            # Go home automatically\n            time.sleep(1.0)\n            return self.go_home()\n            \n        except Exception as e:\n            self.get_logger().error(f'❌ Pick and place failed: {e}')\n            return False\n        finally:\n            self.is_busy = False\n    \n    def move_to_position(self, x, y, z, description):\n        \"\"\"Send movement command to MoveIt (stub for now)\"\"\"\n        self.get_logger().info(f'🚀 Moving to: ({x:.3f}, {y:.3f}, {z:.3f}) [{description}]')\n        \n        # Publish target pose for visualization\n        pose_msg = PoseStamped()\n        pose_msg.header.frame_id = 'base_link'\n        pose_msg.header.stamp = self.get_clock().now().to_msg()\n        pose_msg.pose.position.x = x\n        pose_msg.pose.position.y = y\n        pose_msg.pose.position.z = z\n        pose_msg.pose.orientation.w = 1.0\n        self.target_pose_pub.publish(pose_msg)\n        \n        # Simulate movement (replace with actual MoveIt call)\n        time.sleep(1.0)\n        \n        self.status_pub.publish(String(data=f'moved_to_{description}'))\n        return True\n    \n    # ============ VOICE INPUT ============\n    \n    def listen_for_voice(self):\n        \"\"\"Listen for voice command\"\"\"\n        if not SPEECH_AVAILABLE:\n            self.get_logger().error('Voice recognition not available!')\n            return None\n        \n        with self.microphone as source:\n            self.get_logger().info('🎤 Listening...')\n            self.recognizer.adjust_for_ambient_noise(source, duration=0.5)\n            \n            try:\n                audio = self.recognizer.listen(source, timeout=5.0)\n                command = self.recognizer.recognize_google(audio)\n                self.get_logger().info(f'🔊 Heard: \"{command}\"')\n                return command\n            except sr.WaitTimeoutError:\n                self.get_logger().warn('⏱️ No speech detected')\n            except sr.UnknownValueError:\n                self.get_logger().warn('❓ Could not understand audio')\n            except sr.RequestError as e:\n                self.get_logger().error(f'❌ Speech recognition error: {e}')\n        \n        return None\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n    system = IntegratedPickPlaceSystem()\n    \n    # Spin in separate thread\n    spin_thread = threading.Thread(target=rclpy.spin, args=(system,), daemon=True)\n    spin_thread.start()\n    \n    print(\"\\n\" + \"=\" * 70)\n    print(\"🤖 INTEGRATED PICK-PLACE SYSTEM\")\n    print(\"=\" * 70)\n    print(\"Commands:\")\n    print(\"  • 'pick [object]' - Pick object (cube/sphere/cylinder/pyramid)\")\n    print(\"  • 'pick [object] and place in box a/b' - Pick and place\")\n    print(\"  • 'move left/right/up/down/forward/back' - Move robot\")\n    print(\"  • 'go home' - Return to home position\")\n    print(\"  • 'exit' / 'quit' - Exit system\")\n    print(\"=\" * 70)\n    print(\"\\n💡 Objects detected by YOLO will appear as colored markers in RViz\")\n    print(\"   • Sphere = detected object position (camera view)\")\n    print(\"   • Arrow = target suction position (offset-compensated)\")\n    print(\"=\" * 70)\n    \n    mode = input(\"\\nChoose mode - (1) Text, (2) Voice: \").strip()\n    \n    try:\n        while rclpy.ok():\n            if mode == '2' and SPEECH_AVAILABLE:\n                command = system.listen_for_voice()\n                if command:\n                    system.process_command(command)\n            else:\n                command = input('\\n💬 Command: ')\n                if command.lower() in ['exit', 'quit']:\n                    break\n                system.process_command(command)\n    except KeyboardInterrupt:\n        pass\n    \n    print(\"\\n👋 Shutting down...\")\n    system.destroy_node()\n    rclpy.shutdown()\n\n\nif __name__ == '__main__':\n    main()\n"}\n{"instruction": "Write a ROS2 Python node named run.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "\"\"\"Node to perform YOLO-based pick and place operations.\"\"\"\n\nimport copy\n\nfrom geometry_msgs.msg import Pose, Quaternion\n\nfrom moveit_msgs.action import MoveGroup\nfrom moveit_msgs.srv import GetPlanningScene\n\nimport numpy as np\n\nfrom omni_place.Interface import MotionPlanningInterface\nfrom omni_place.planning_scene import PlanningScene\nfrom omni_place.robot_state import RobotState as frRobotState\nfrom omni_place.yolo import YOLO_STATE, YoloDetector\n\nimport rclpy\nfrom rclpy.action import ActionClient\nfrom rclpy.callback_groups import MutuallyExclusiveCallbackGroup\nfrom rclpy.node import Node\n\nfrom std_srvs.srv import Trigger\n\nfrom tf_transformations import euler_from_quaternion, quaternion_from_euler\n\n\nclass GraspObject(Node):\n    \"\"\"\n    Node to perform multi-object pick-and-place.\n\n    Services\n    --------\n    Awesome_calibration : std_srvs/srv/Trigger\n        Perform one-time camera-to-robot calibration.\n\n    Awesome_scan : std_srvs/srv/Trigger\n        Run YOLO scan and populate detected objects/targets.\n\n    Awesome_pick : std_srvs/srv/Trigger\n        Execute full pick-and-place cycles for all detected objects.\n\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the GraspObject node, interfaces, and planning scene.\"\"\"\n        super().__init__('grasp_object')\n        self.objects = []\n        self.targets = []\n        self.detections = []\n\n        self.srv_group = MutuallyExclusiveCallbackGroup()\n        self.yolo_group = MutuallyExclusiveCallbackGroup()\n\n        self.yolo = YoloDetector(self, callback_group=self.yolo_group)\n\n        client = ActionClient(self, MoveGroup, '/move_action')\n\n        while not client.wait_for_server(timeout_sec=1.0):\n            self.get_logger().warn('move_action not ready... retrying...')\n\n        self.get_logger().info('move_action READY. Now creating MPI...')\n        self.mpi = MotionPlanningInterface(self)\n        self.fr_robot_state = frRobotState(self)\n\n        self.planning_scene = PlanningScene(self)\n        self.init_callibration = self.create_service(\n            Trigger,\n            'Awesome_calibration',\n            self.init_calibration_cb,\n            callback_group=self.srv_group,\n        )\n        self.init_scan_srv = self.create_service(\n            Trigger, 'Awesome_scan', self.yolo_cb,\n            callback_group=self.srv_group\n        )\n        self.pick_srv = self.create_service(\n            Trigger, 'Awesome_pick', self.pick_cb,\n            callback_group=self.srv_group\n        )\n\n        self.declare_parameter('scene_file', '')\n        self.scene_path = (\n            self.get_parameter('scene_file')\n            .get_parameter_value().string_value\n        )\n        self.declare_parameter('home_file', '')\n        self.home_path = (\n            self.get_parameter('home_file').get_parameter_value().string_value\n        )\n        self.get_logger().info(f'Using scene file: {self.scene_path}')\n\n        self.get_scene = self.create_client(GetPlanningScene,\n                                            'get_planning_scene')\n        while not self.get_scene.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info('Waiting for planning scene service...')\n\n        self.get_logger().info('Loading planning scene from YAML...')\n        self.mpi.scene.load_planning_scene(self.scene_path)\n\n    def init_calibration_cb(self, request, response):\n        \"\"\"Service callback to do camera-to-robot calibration.\"\"\"\n        self.get_logger().info('Starting one-time camera calibration...')\n        success = self.yolo.calibrate_camera_to_robot()\n\n        if success:\n            response.success = True\n            response.message = 'Calibration OK (camera -> robot).'\n        else:\n            response.success = False\n            response.message = 'Calibration FAILED. Check CameraCalibration.'\n\n        return response\n\n    async def open_gripper(self):\n        \"\"\"Open the Franka gripper.\"\"\"\n        result = await self.mpi.set_gripper_franka(\n            width=0.075, speed=0.05, adaptive_stop=False\n        )\n        return result\n\n    async def close_gripper(self):\n        \"\"\"Close the Franka gripper.\"\"\"\n        result = await self.mpi.set_gripper_franka(\n            width=0.001, speed=0.05, adaptive_stop=True\n        )\n        return result\n\n    async def scan_and_update(self):\n        \"\"\"Reset detection buffers and repopulates objects and targets.\"\"\"\n        self.get_logger().info('Re-scanning scene...')\n\n        # return to home so the camera has full visibility\n        await self.mpi.plan_path_named_pose(None, self.home_path, 'home1',\n                                            execute=True)\n\n        # run YOLO scan exactly as before\n        self.objects = []\n        self.targets = []\n        self.detections = []\n        self.yolo.clear_buffer()\n        self.get_logger().info('about to start scan')\n        self.yolo.start_scan()\n        self.get_logger().info('starting scan')\n        while self.yolo.yolo_state != YOLO_STATE.SCAN_COMPLETE:\n            rclpy.spin_once(self, timeout_sec=0.01)\n\n        detections = self.yolo.get_detections()\n\n        self.objects = [d for d in detections if d['type'] == 'object']\n        self.targets = [d for d in detections if d['type'] != 'object']\n\n        self.get_logger().info\n        (f'Updated objects = {len(self.objects)}, targets = {len(self.targets)\n                                                             }')\n\n    def yolo_cb(self, request, response):\n        \"\"\"Service callback to run YOLO scan and list found objects/targets.\"\"\"\n        self.get_logger().info('Initialization ...')\n\n        # Clear lists\n        self.objects = []\n        self.targets = []\n        self.detections = []\n        self.yolo.clear_buffer()\n\n        # Run YOLO scan\n        self.get_logger().info('about to start scan')\n        self.yolo.start_scan()\n        self.get_logger().info('starting scan')\n        while self.yolo.yolo_state != YOLO_STATE.SCAN_COMPLETE:\n            rclpy.spin_once(self, timeout_sec=0.01)\n\n        detections = self.yolo.get_detections()\n        if len(detections) == 0:\n            response.success = True\n            response.message = 'Initialization failed, please try again.'\n            return response\n\n        # get objects and targets from yolo scan\n        self.objects = [\n            item for item in detections if item['type'] == 'object']\n        self.targets = [\n            item for item in detections if item['type'] != 'object']\n\n        # Print detected object list\n        for obj in self.objects:\n            name = f\"{obj['yolo_id']}_{obj['act_id']}\"\n            self.get_logger().info(\n                f\"Detected: {name} at {obj['pose'].pose.position}\")\n\n        # update planning scene\n        response.success = True\n        response.message = 'Object detection complete.'\n        return response\n\n    async def pick_cb(self, request, response):\n        \"\"\"Service callback to run pick-and-place for all detected location.\"\"\"\n        # move robot to home\n        await self.mpi.plan_path_named_pose(None, self.home_path, 'home1',\n                                            execute=True)\n        self.mpi.scene.refresh_scene()\n        # calibrate robot\n        self.init_calibration_cb(Trigger.Request(), Trigger.Response())\n        # move to scan position\n        self.get_logger().info('moving to scan position')\n        await self.mpi.plan_path_named_pose(None, self.home_path, 'home1',\n                                            execute=True)\n        await self.scan_and_update()\n        self.get_logger().info('Opening gripper')\n        await self.open_gripper()\n\n        if not self.objects or not self.targets:\n            self.get_logger().error('No detections found!')\n            response.success = False\n            response.message = 'No objects/targets detected'\n            return response\n\n        success_count = 0\n        while self.objects:\n            obj = self.objects[0]   # always pick first object\n            tgt = self.find_target(obj)\n            if tgt is None:\n                self.get_logger().warn(f\"No target found for {obj['yolo_id']}\")\n                self.objects.pop(0)\n                continue\n\n            self.get_logger().info(\n                f\"Picking {obj['yolo_id']} → placing to target\")\n            ok = await self.execute_task(obj, tgt)\n\n            if ok:\n                success_count += 1\n            else:\n                self.get_logger().warn(f\"Failed to pick {obj['yolo_id']}\")\n\n            # Refresh scene after each attempt (success OR failure)\n            await self.scan_and_update()\n\n        await self.mpi.plan_path_named_pose(None, self.home_path, 'home1',\n                                            execute=True)\n        response.success = success_count > 0\n        response.message = f'Completed {success_count} pick-and-place cycles'\n        self.get_logger().info(f'{response.message}')\n        return response\n\n    def find_target(self, obj):\n        \"\"\"Return the first matching target detection for the given object.\"\"\"\n        for tgt in self.targets:\n            if (\n                tgt['type'] == 'target'\n                and obj['act_id'] == tgt['act_id']\n                and obj['yolo_id'] == tgt['yolo_id']\n            ):\n                return tgt\n\n    async def execute_task(self, obj, target):\n        \"\"\"Execute a single pick-and-place for one object–target pair.\"\"\"\n        try:\n            # extract initial object and target poses\n            # these are initial object poses (will move when obj is grasped)\n\n            obj_pose = obj['pose'].pose\n            obj_top_z = obj_pose.position.z + obj['size'][2] / 2\n            # target poses are fixed (robot doesn't move them)\n            target_pose = target['pose'].pose\n            target_top_z = target_pose.position.z + target['size'][2] / 2\n            name = f\"{obj['type']}_{obj['yolo_id']}_{obj['act_id']}\"\n\n            self.get_logger().info(\n                f\"Executing pick and place for {obj['yolo_id']} to target \\\n                {target['yolo_id']}\"\n            )\n\n            # Above object\n            pose_10 = Pose()\n            pose_10.position.x = obj_pose.position.x\n            pose_10.position.y = obj_pose.position.y\n            pose_10.position.z = obj_top_z + 0.1  # move 10 cm above object\n            pose_10.orientation = self.rotate_to_finger_frame(\n                obj_pose.orientation)\n\n            # Grasp object pose\n            pose_20 = Pose()\n            pose_20.position.x = obj_pose.position.x\n            pose_20.position.y = obj_pose.position.y\n            pose_20.position.z = obj_top_z - 0.01  # grasp 1cm below\n            pose_20.orientation = pose_10.orientation\n\n            # Above target destination\n            pose_30 = Pose()\n            pose_30.position.x = target_pose.position.x\n            pose_30.position.y = target_pose.position.y\n            pose_30.position.z = (\n                target_top_z + obj_top_z + 0.15\n            )  # move 20 cm above target\n            pose_30.orientation = pose_10.orientation\n\n            # destination\n            # Match target orientation\n            pose_40 = Pose()\n            pose_40.position.x = target_pose.position.x\n            pose_40.position.y = target_pose.position.y\n            pose_40.position.z = target_top_z + obj_top_z + 0.1\n            pose_40.orientation = self.rotate_to_finger_frame(\n                target_pose.orientation)\n\n            # Final placement pose\n            pose_50 = Pose()\n            pose_50.position.x = target_pose.position.x\n            pose_50.position.y = target_pose.position.y\n            pose_50.position.z = target_top_z + obj_top_z + 0.005\n            pose_50.orientation = pose_40.orientation\n\n            # Match target orientation\n            pose_60 = copy.deepcopy(pose_40)\n\n            # move robot directly over object\n            self.get_logger().info(f'[{name}] Moving to above object pose')\n            await self.mpi.plan_path_pose(pose_10, execute=True, speed=0.3)\n\n            self.get_logger().info(\n                f'[{name}] Moving to grasp object pose {pose_20.position.z}'\n            )\n            await self.mpi.plan_path_pose(pose_20, execute=True, speed=0.1)\n\n            self.get_logger().info('attaching object')\n            self.mpi.scene.attach_object(\n                f\"object_{obj['yolo_id']}_{obj['act_id']}\")\n\n            self.get_logger().info(f'[{name}] Closing gripper')\n            await self.close_gripper()\n            self.get_logger().info(f'[{name}] gripper closed')\n\n            # confirm we actually grasped the object\n            if not self.check_grasp():\n                self.get_logger().warn(f'[{name}] Grasp failed')\n                await self.mpi.plan_cartesian_path(pose_10, execute=True)\n                self.mpi.scene.detach_object(\n                    f\"object_{obj['yolo_id']}_{obj['act_id']}\")\n                await self.open_gripper()\n                return False\n\n            self.get_logger().info(f'[{name}] Lifting object')\n            await self.mpi.plan_cartesian_path(pose_10, execute=True)\n\n            self.get_logger().info(f'[{name}] Moving above target')\n            await self.mpi.plan_path_pose(pose_30, execute=True, speed=0.3)\n\n            self.get_logger().info(\n                f'[{name}] Matching target orientation {pose_40}')\n            await self.mpi.plan_path_pose(pose_40, execute=True, speed=0.3)\n\n            self.get_logger().info(f'[{name}] Moving to place pose {pose_50}')\n            await self.mpi.plan_path_pose(pose_50, execute=True, speed=0.1)\n\n            self.get_logger().info(f'[{name}] Opening gripper to release')\n            await self.open_gripper()\n\n            self.get_logger().info('detaching object')\n            self.mpi.scene.detach_object(\n                f\"object_{obj['yolo_id']}_{obj['act_id']}\")\n            self.get_logger().info('object detached')\n\n            self.get_logger().info(f'[{name}] Moving above target {pose_60}')\n            await self.mpi.plan_cartesian_path(pose_60, execute=True)\n\n            self.get_logger().info('moving to home pose')\n            await self.mpi.plan_path_named_pose(\n                None, self.home_path, 'home1', execute=True, speed=0.3\n            )\n\n            return True\n        except Exception as e:  # noqa: B902\n            self.get_logger().error(\n                f\"Exception in pick_and_place_one for '{name}': {e}\"\n            )\n            await self.mpi.plan_path_named_pose(\n                None, self.home_path, 'home1', execute=True, speed=0.3\n            )\n            self.get_logger().info(f'[{name}] Opening gripper to release')\n            await self.open_gripper()\n            return False\n\n    def rotate_to_finger_frame(self, q_in: Quaternion):\n        \"\"\"Rotate the input quaternion into the gripper finger frame.\"\"\"\n        q = q_in\n        quat = [q.x, q.y, q.z, q.w]\n        roll, pitch, yaw = euler_from_quaternion(quat)\n        qx, qy, qz, qw = quaternion_from_euler(roll + np.pi, pitch, yaw)\n        q_out = Quaternion(x=qx, y=qy, z=qz, w=qw)\n        return q_out\n\n    def check_grasp(self):\n        \"\"\"Check whether the gripper is holding an object based on finger \\\n            joint states.\"\"\"\n        while self.fr_robot_state.current_joint_state is None:\n            pass\n\n        current_state = self.fr_robot_state.current_joint_state\n        joint_names = ['fer_finger_joint1', 'fer_finger_joint2']\n        current_positions = [\n            current_state.position[current_state.name.index(j)]\n            for j in joint_names\n        ]\n        self.get_logger().info(f'{current_positions[0]}')\n        return current_positions[0] > 0.01\n\n\ndef main(args=None):\n    \"\"\"Run the GraspObject node.\"\"\"\n    rclpy.init(args=args)\n    node = GraspObject()\n    rclpy.spin(node)\n    node.destroy_node()\n    rclpy.shutdown()\n"}\n{"instruction": "Write a ROS2 Python node named xbox_teleop.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "#!/usr/bin/env python3\n\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import Joy\nfrom geometry_msgs.msg import TransformStamped\nfrom moveit_msgs.srv import GetPositionIK\nfrom trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint\nfrom control_msgs.action import FollowJointTrajectory\nfrom rclpy.action import ActionClient\nfrom builtin_interfaces.msg import Duration\nfrom scipy.spatial.transform import Rotation as R\nimport numpy as np\nfrom tf2_ros.buffer import Buffer\nfrom tf2_ros.transform_listener import TransformListener\n\n\nclass XboxTeleopNode(Node):\n    def __init__(self):\n        super().__init__('xbox_teleop_node')\n\n        self.translation_increment = 0.03\n        self.rotation_increment = 0.2\n\n        self.frame_id = 'fr3_link0'\n        self.ee_link = 'fr3_hand_tcp'\n        self.group_name = 'fr3_arm'\n\n        self.send_interval_sec = 0.05\n        self.home_pose = np.array([0.3, 0.0, 0.5, 1.0, 0.0, 0.0, 0.0])\n        self.go_to_home_time = 3.0\n\n        self.current_translation = None\n        self.current_rotation = None\n        self.last_pose_sent = None\n\n        self.max_speed = 0.01\n        self.min_duration = 0.3\n        self.max_duration = 3.0\n\n        self.ik_busy = False\n        self.joy_connected = False\n        self.initial_axes = None\n        self.home_pose_done = False\n        self.last_send_time = self.get_clock().now()\n        self.last_joy_time = self.get_clock().now()\n\n        self.ik_client = self.create_client(GetPositionIK, '/compute_ik')\n        self.ik_client.wait_for_service()\n\n        self.action_client = ActionClient(self, FollowJointTrajectory,\n                                          '/fr3_arm_controller/follow_joint_trajectory')\n        self.action_client.wait_for_server()\n\n        self.joy_sub = self.create_subscription(Joy, '/joy', self.joy_callback, 10)\n\n        self.create_timer(1.0, self.send_home_pose_once)\n        self.create_timer(2.0, self.check_joy_connection)\n\n        self.tf_buffer = Buffer()\n        self.tf_listener = TransformListener(self.tf_buffer, self)\n\n        self.get_logger().info('🕹️ Xbox teleoperation with Cartesian control initialized.')\n\n    def send_home_pose_once(self):\n        if not self.home_pose_done:\n            self.get_logger().info(\"🏠 Sending home pose...\")\n            self.current_translation = self.home_pose[0:3]\n            self.current_rotation = self.home_pose[3:7]\n            self.send_pose(is_home=True)\n\n            # ⏱️ 홈 포즈 duration(4초) 이후에 조이스틱 입력 허용\n            self.create_timer(self.go_to_home_time, self.set_home_pose_done_once)\n\n    def set_home_pose_done_once(self):\n        if not self.home_pose_done:\n            self.home_pose_done = True\n            self.get_logger().info(\"✅ Home pose duration elapsed. Ready for teleoperation.\")\n\n    def joy_callback(self, msg: Joy):\n        if not self.home_pose_done:\n            return\n\n        if not self.joy_connected:\n            self.get_logger().info('✅ Joystick connected!')\n            self.joy_connected = True\n            self.initial_axes = np.array(msg.axes)\n            return\n\n        self.last_joy_time = self.get_clock().now()\n\n        axes = np.array(msg.axes)\n        delta_axes = axes - self.initial_axes\n        dpos = np.array([delta_axes[1], delta_axes[0], -delta_axes[2] + delta_axes[5]]) * self.translation_increment\n\n        try:\n            transform: TransformStamped = self.tf_buffer.lookup_transform(\n                self.frame_id, self.ee_link, rclpy.time.Time())\n            pose = transform.transform\n            self.current_translation = np.array([\n                pose.translation.x, pose.translation.y, pose.translation.z]) + dpos\n            base_rot = R.from_quat([\n                pose.rotation.x, pose.rotation.y,\n                pose.rotation.z, pose.rotation.w])\n        except Exception as e:\n            self.get_logger().warn(f\"⚠️ TF lookup failed: {e}\")\n            return\n\n        drot_xyz = np.array([delta_axes[3], delta_axes[4], 0.0]) * self.rotation_increment\n        if np.linalg.norm(drot_xyz) > 1e-6:\n            delta_rot = R.from_euler('xyz', drot_xyz)\n            self.current_rotation = (delta_rot * base_rot).as_quat()\n\n        now = self.get_clock().now()\n        if (now - self.last_send_time).nanoseconds > self.send_interval_sec * 1e9:\n            if not self.ik_busy:\n                self.send_pose()\n                self.last_send_time = now\n\n    def check_joy_connection(self):\n        time_since_last = self.get_clock().now() - self.last_joy_time\n        if time_since_last.nanoseconds > 5e9 and self.joy_connected:\n            self.get_logger().warn('❌ Joystick disconnected!')\n            self.joy_connected = False\n\n    def send_pose(self, is_home=False):\n        self.ik_busy = True\n\n        if is_home:\n            self.current_duration_sec = self.go_to_home_time\n        else:\n            dist = np.linalg.norm(self.current_translation - self.last_pose_sent)\n            duration_sec = dist / self.max_speed\n            self.current_duration_sec = max(self.min_duration, min(duration_sec, self.max_duration))\n\n        request = GetPositionIK.Request()\n        request.ik_request.group_name = self.group_name\n        request.ik_request.pose_stamped.header.frame_id = self.frame_id\n        request.ik_request.ik_link_name = self.ee_link\n\n        pose = request.ik_request.pose_stamped.pose\n        pose.position.x, pose.position.y, pose.position.z = self.current_translation\n        pose.orientation.x, pose.orientation.y, pose.orientation.z, pose.orientation.w = self.current_rotation\n\n        future = self.ik_client.call_async(request)\n        future.add_done_callback(self.handle_ik_response)\n\n    def handle_ik_response(self, future):\n        try:\n            result = future.result()\n        except Exception as e:\n            self.get_logger().error(f'❌ IK service call failed: {e}')\n            self.ik_busy = False\n            return\n\n        joint_state = result.solution.joint_state\n        if not joint_state.name:\n            self.get_logger().error('❌ IK failed: No joint state returned.')\n            self.ik_busy = False\n            return\n\n        joint_order = [\n            \"fr3_joint1\", \"fr3_joint2\", \"fr3_joint3\",\n            \"fr3_joint4\", \"fr3_joint5\", \"fr3_joint6\", \"fr3_joint7\"\n        ]\n        name_to_position = dict(zip(joint_state.name, joint_state.position))\n        sorted_positions = [name_to_position[name] for name in joint_order]\n\n        traj = JointTrajectory()\n        traj.joint_names = joint_order\n        point = JointTrajectoryPoint()\n        point.positions = sorted_positions\n\n        sec_part = int(self.current_duration_sec)\n        nsec_part = int((self.current_duration_sec - sec_part) * 1e9)\n        if nsec_part >= 1e9:\n            sec_part += 1\n            nsec_part -= int(1e9)\n\n        point.time_from_start = Duration(sec=sec_part, nanosec=nsec_part)\n        traj.points.append(point)\n\n        goal = FollowJointTrajectory.Goal()\n        goal.trajectory = traj\n\n        self.action_client.send_goal_async(goal)\n        self.last_pose_sent = self.current_translation.copy()\n        self.ik_busy = False\n\n\ndef main():\n    rclpy.init()\n    node = XboxTeleopNode()\n    rclpy.spin(node)\n    node.destroy_node()\n    rclpy.shutdown()\n\n\nif __name__ == '__main__':\n    main()"}\n{"instruction": "Write a ROS2 Python node named ik_move_client.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "import rclpy \nfrom rclpy.node import Node\nfrom rclpy.action import ActionClient\n\nfrom geometry_msgs.msg import PoseStamped\nfrom moveit_msgs.action import MoveGroup\nfrom moveit_msgs.msg import Constraints, PositionConstraint, OrientationConstraint, MoveItErrorCodes\nfrom shape_msgs.msg import SolidPrimitive\n\nimport sys, termios, tty, select\n\n# not true reachability limits, they just filter out obviously impossible targets\nX_MIN, X_MAX = -0.3575, 0.3575\nY_MIN, Y_MAX = -0.3575, 0.3575\nZ_MIN, Z_MAX = 0.095331, 0.4525\n\ndef is_plausible_target(p):\n    return (\n        X_MIN <= p.x <= X_MAX and\n        Y_MIN <= p.y <= Y_MAX and\n        Z_MIN <= p.z <= Z_MAX\n    )\n\nclass IKMoveClient(Node):\n    def __init__(self):\n        super().__init__('ik_move_client')\n\n        self.named_poses = {\n            \"home\" : dict(x=0.0032001789659261703, y=-1.795403477444779e-05, z=0.4174376428127289),\n        }\n\n        self.client = ActionClient(self, MoveGroup, '/move_action')\n        self.get_logger().info('Waiting for MoveGroup action server...')\n        self.client.wait_for_server()\n\n        # self.move_to(z=0.3835, tol=0.05, constrain_orientation=True)\n        self.go_named_pose(\"home\")\n        self.keyboard_teleop()\n\n    def get_key(self, timeout=0.1):\n        fd = sys.stdin.fileno()\n        old_settings = termios.tcgetattr(fd)\n\n        try:\n            tty.setraw(fd)\n            rlist, _, _ = select.select([sys.stdin], [], [], timeout)\n            if rlist:\n                return sys.stdin.read(1)\n            return None\n        finally:\n            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)\n\n    def keyboard_teleop(self):\n        self.get_logger().info(\n            \"\\nKeyboard control:\\n\"\n            \"W/S -> +X/-X\\n\"\n            \"A/D -> +Y/-Y\\n\"\n            \"Q/E -> +Z/-Z\\n\"\n            \"H -> home\\n\"\n            \"X -> exit\\n\"\n            \"C -> enable/disable orientation constaint\"\n        )\n\n        self.target = dict(x=0.0032001789659261703, y=-1.795403477444779e-05, z=0.4174376428127289) # home\n\n        step = 0.02\n\n        while rclpy.ok():\n            key = self.get_key()\n            if key is None:\n                continue\n\n            moved = False\n            constrained = False\n            \n            if key == \"w\":\n                self.target[\"x\"] += step\n                moved = True\n            if key == \"s\":\n                self.target[\"x\"] -= step\n                moved = True\n            if key == \"a\":\n                self.target[\"y\"] += step\n                moved = True\n            if key == \"d\":\n                self.target[\"y\"] -= step\n                moved = True\n            if key == \"q\":\n                self.target[\"z\"] += step\n                moved = True\n            if key == \"e\":\n                self.target[\"z\"] -= step\n                moved = True\n            if key == \"h\":\n                self.go_named_pose(\"home\")\n                self.target = self.named_poses[\"home\"].copy()\n                continue\n            if key == 'x':\n                self.get_logger().info(\"exiting teleop\")\n                break\n            if key == 'c':\n                if constrained:\n                    self.get_logger().info(\"Enabled orientation constraint.\")\n                else:\n                    self.get_logger().info(\"Disabled orientation constraint.\")\n\n            if moved:\n                self.get_logger().info(\n                    f\"Target: x={self.target['x']:.3f}, y={self.target['y']:.3f}, z={self.target['z']:.3f}\"\n                )\n                self.move_to(x=self.target[\"x\"], y=self.target[\"y\"], z=self.target[\"z\"], tol=0.05, constrain_orientation=constrained)\n\n    def move_to(self, x=None, y=None, z=None, tol=0.05, constrain_orientation=False):\n        goal = MoveGroup.Goal()\n\n        goal.request.group_name = 'arm'\n        goal.request.num_planning_attempts = 5\n        goal.request.allowed_planning_time = 5.0\n        goal.request.max_velocity_scaling_factor = 1.0 # 0.3\n        goal.request.max_acceleration_scaling_factor = 1.0 # 0.3\n\n        pose = PoseStamped()\n        pose.header.frame_id = 'base_link'\n        pose.pose.position.x = x if x is not None else 0.0\n        pose.pose.position.y = y if y is not None else 0.0\n        pose.pose.position.z = z if z is not None else 0.0\n        pose.pose.orientation.w = 1.0\n\n        if not is_plausible_target(pose.pose.position):\n            self.get_logger().error('Target pose is outside plausible workspace')\n            return\n\n        pose_constraint = PositionConstraint()\n        pose_constraint.header = pose.header\n        pose_constraint.link_name = 'end_effector_link'\n\n        primitive = SolidPrimitive()\n        primitive.type = SolidPrimitive.BOX\n        primitive.dimensions = [tol, tol, tol]\n\n        pose_constraint.constraint_region.primitives.append(primitive)\n        pose_constraint.constraint_region.primitive_poses.append(pose.pose)\n        pose_constraint.weight = 1.0\n\n\n        constraints = Constraints()\n        constraints.position_constraints.append(pose_constraint)\n\n        if constrain_orientation:\n            ori_constraint = OrientationConstraint()\n            ori_constraint.header = pose.header\n            ori_constraint.link_name = 'end_effector_link'\n            ori_constraint.orientation = pose.pose.orientation\n            ori_constraint.absolute_x_axis_tolerance = 0.2\n            ori_constraint.absolute_y_axis_tolerance = 0.2\n            ori_constraint.absolute_z_axis_tolerance = 0.2\n            ori_constraint.weight = 1.0\n            constraints.orientation_constraints.append(ori_constraint)\n\n\n        goal.request.goal_constraints.append(constraints)\n\n        self.get_logger().info('Sending IK + planning goal...')\n        # self._action_client.send_goal_async(goal)\n        self._send_goal_future = self.client.send_goal_async(goal, feedback_callback=self.feedback_callback)\n        self._send_goal_future.add_done_callback(self.goal_response_callback)\n\n    def go_named_pose(self, name, tol=0.05):\n        if name not in self.named_poses:\n            self.get_logger().error(f\"Unknown named pose: {name}\")\n            return\n        \n        p = self.named_poses[name]\n        self.get_logger().info(f\"Going to named pose: {name}\")\n        self.move_to(x=p[\"x\"], y=p[\"y\"], z=p[\"z\"], tol=tol, constrain_orientation=True)\n\n    def goal_response_callback(self, future):\n        goal_handle = future.result()\n\n        if not goal_handle.accepted:\n            self.get_logger().error('Goal Rejected')\n            rclpy.shutdown()\n            return\n        \n        self.get_logger().info('Goal accepted, executing...')\n        self._get_result_future = goal_handle.get_result_async()\n        self._get_result_future.add_done_callback(self.result_callback)\n\n    def feedback_callback(self, feedback):\n        pass\n\n    def result_callback(self, future):\n        result = future.result().result\n        code = result.error_code.val\n\n        if code == MoveItErrorCodes.SUCCESS:\n            self.get_logger().info(\"Motion succeeded\")\n        elif code == MoveItErrorCodes.NO_IK_SOLUTION:\n            self.get_logger().error(\"No IK Solution found\")\n        elif code == MoveItErrorCodes.PLANNING_FAILED:\n            self.get_logger().error(\"Planning failed\")\n        else:\n            self.get_logger().info(f'Execution Result: {code}')\n        \n        rclpy.shutdown()\n\ndef main():\n    rclpy.init()\n    node = IKMoveClient()\n    rclpy.spin(node)\n\nif __name__ == \"__main__\":\n    main()"}\n{"instruction": "Write a ROS2 Python node named can_frame.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "import rclpy\nfrom rclpy.time import Time\nfrom rclpy.duration import Duration\nfrom rclpy.node import Node\nfrom tf2_ros.buffer import Buffer\nfrom tf2_ros.transform_listener import TransformListener\nfrom moveit_msgs.srv import GetPositionIK\nfrom sensor_msgs.msg import JointState\n\nimport numpy as np\nfrom scipy.spatial.transform import Rotation as R\n\n\nclass FrameListener(Node):\n    def __init__(self):\n        super().__init__('can_listener')\n        self.target_frame = self.declare_parameter('target_frame', 'base_link').get_parameter_value().string_value\n        self.tf_buffer = Buffer()\n        self.tf_listener = TransformListener(self.tf_buffer, self, spin_thread=True)\n        self.subscriber = self.create_subscription(JointState, '/joint_states', self.listener_callback, 10)\n        self.subscriber\n\n        self.look_transform()\n        self.call_service()\n\n\n    def look_transform(self):\n        try:\n            t= self.tf_buffer.lookup_transform(self.target_frame, 'can1', Time(), Duration(seconds=3.0))\n            self.tf_base_link_can = [t.transform.translation.x, t.transform.translation.y, t.transform.translation.z]\n            \n        except:\n            self.get_logger().info('cannot transform')\n\n    def joint_states_cb(self, joint_state):\n        global global_joint_states\n        global_joint_states = joint_state\n        self.joint_state = joint_state\n\n    def call_service(self):\n        client = self.create_client(GetPositionIK,'/compute_ik')\n    \n        while not client.wait_for_service(timeout_sec = 1.0):\n            self.get_logger().info('service not available, waiting again...')\n\n        #create a request, request to server, receive response from server\n        request = self.request()\n        self.future = client.call_async(request)\n        rclpy.spin_until_future_complete(self.node, self.future)\n        respone = self.future.result()\n        print(respone)\n\n    \n    def listener_callback(self, msg:JointState):\n        self.joint_state = msg\n\n    \n    def request(self):\n        request = GetPositionIK.Request()\n\n        request.ik_request.group_name = 'spot_ur3e_arm'\n        request.ik_request.timeout.sec = 5\n\n        request.ik_request.robot_state.joint_state = self.joint_state\n        request.ik_request.avoid_collisions = True\n\n        request.ik_request.pose_stamped.header.frame_id = 'base_link'\n        request.ik_request.pose_stamped.header.stamp = self.get_clock().now().to_msg()\n\n        rot_vert_base_link = 90 + np.rad2deg(np.arctan2(self.tf_base_link_can[1], self.tf_base_link_can[0])) * (-1)\n        dist_can = 0.1\n\n        # translation in 3 dimesions x,y,z\n        xyz = [self.tf_base_link_can[0],self.tf_base_link_can[1], self.tf_base_link_can[2]]        \n        request.ik_request.pose_stamped.pose.position.x = xyz[0] - dist_can * np.sin(np.deg2rad(rot_vert_base_link))\n        request.ik_request.pose_stamped.pose.position.y = xyz[1] - dist_can * np.cos(np.deg2rad(rot_vert_base_link))\n        request.ik_request.pose_stamped.pose.position.z = xyz[2] + 0.03\n\n        # rotation about z axis \"roll\"\n        abc = [180, 0, rot_vert_base_link]\n        r = R.from_euler('xyz', [np.deg2rad(a) for a in abc])\n        request.ik_request.pose_stamped.pose.orientation.x = r.as_quat()[0]\n        request.ik_request.pose_stamped.pose.orientation.y = r.as_quat()[1]\n        request.ik_request.pose_stamped.pose.orientation.z = r.as_quat()[2]\n        request.ik_request.pose_stamped.pose.orientation.w = r.as_quat()[3]\n\n        #print(request)\n        return request\n\n\n\n\ndef main():\n    rclpy.init()\n    node = FrameListener()\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        pass\n\n    rclpy.shutdown()\n"}\n{"instruction": "Write a ROS2 Python node named panda_follower.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "#!/usr/bin/env python3\n\nimport rclpy\nfrom rclpy.node import Node\n\nfrom sensor_msgs.msg import Image\nfrom cv_bridge import CvBridge\nfrom std_msgs.msg import Bool\nimport cv2\nimport numpy as np\nfrom geometry_msgs.msg import TwistStamped, Point\nfrom pymoveit2.robots import panda\nfrom std_srvs.srv import Trigger\nimport tf2_ros\nfrom visualization_msgs.msg import Marker\n\nclass ImageViewer(Node):\n    def __init__(self):\n        super().__init__('image_viewer')\n\n        self.bridge = CvBridge()\n\n        self.vel_pub = self.create_publisher(TwistStamped, \"/servo_node/panda/delta_twist_cmds\", 10)\n        self.marker_pub = self.create_publisher(Marker, \"/ee_marker_points\", 10)\n\n        self.create_subscription(Image, '/camera/image_raw', self.image_callback, 10)\n        self.create_subscription(Bool, \"/start_tracking\", self.track_object, 10)\n\n        self.start_servo_client = self.create_client(Trigger, \"/servo_node/start_servo\")\n        self.start_servo_timer = self.create_timer(0.5,  self.start_servo_once)\n\n        self.cy = 320\n        self.cz = 160\n        self.object_area = 0.0\n        self.vel_msg = TwistStamped()\n        self.vel_msg.header.frame_id = panda.base_link_name()\n\n        self.tf_buffer = tf2_ros.Buffer()\n        self.tf_listener = tf2_ros.TransformListener(self.tf_buffer, self)\n\n        self.marker = Marker()\n        self.marker.header.frame_id = \"panda_link0\"\n        self.marker.ns = \"camera_path\"\n        self.marker.id = 0\n        self.marker.type = Marker.POINTS\n        self.marker.action = Marker.ADD\n        self.marker.scale.x = 0.01\n        self.marker.scale.y = 0.01\n        self.marker.color.r = 1.0\n        self.marker.color.g = 0.0\n        self.marker.color.b = 0.0\n        self.marker.color.a = 1.0\n        self.marker.pose.orientation.w = 1.0\n\n        self.get_logger().info(\"PANDA FOLLOWER INITIALIZED\")\n    \n    # function to trigger the moveit servo node\n    def start_servo_once(self):\n        self.start_servo_timer.cancel()\n        if not self.start_servo_client.service_is_ready():\n            self.get_logger().warn(\"Servo start service not ready yet\")\n            return\n        self.start_servo_client.call_async(Trigger.Request())\n\n    # function to compute contour center and area\n    def image_callback(self, msg: Image):\n        try:\n            frame = self.bridge.imgmsg_to_cv2(msg, desired_encoding='bgr8')\n\n            hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)\n\n            lower_red_1 = np.array([0, 120, 70])\n            upper_red_1 = np.array([10, 255, 255])\n\n            lower_red_2 = np.array([170, 120, 70])\n            upper_red_2 = np.array([180, 255, 255])\n\n            mask1 = cv2.inRange(hsv, lower_red_1, upper_red_1)\n            mask2 = cv2.inRange(hsv, lower_red_2, upper_red_2)\n\n            mask = mask1 | mask2\n\n            kernel = np.ones((5, 5), np.uint8)\n            mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel)\n            mask = cv2.morphologyEx(mask, cv2.MORPH_DILATE, kernel)\n\n            contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\n            if contours:\n                largest_contour = max(contours, key=cv2.contourArea)\n\n                if cv2.contourArea(largest_contour) > 500:\n                    M = cv2.moments(largest_contour)\n                    if M[\"m00\"] != 0:\n                        self.cy = int(M[\"m10\"] / M[\"m00\"])\n                        self.cz = int(M[\"m01\"] / M[\"m00\"])\n                        self.object_area = cv2.contourArea(largest_contour)\n\n                        cv2.circle(frame, (self.cy, self.cz), 5, (0, 255, 0), -1)\n                        cv2.line(frame, (0, 160), (640, 160), (255, 255, 100), 2)\n                        cv2.line(frame, (320, 0), (320, 320), (255, 255, 100), 2)\n\n            cv2.imshow('Camera Image', frame)\n            cv2.waitKey(1)\n\n        except Exception as e:\n            self.get_logger().error(f'Image processing failed: {e}')\n\n    # function to compute controls based on contour center and area error\n    def track_object(self, msg: Bool):\n\n        if msg.data:\n            target = np.array([320, 160])\n            current = np.array([self.cy, self.cz])\n            \n            error = target - current\n            obj_ar_error = 1560 - self.object_area\n\n            max_vel = 0.35\n\n            vel_cmd = 0.008 * error\n            vel_cmd = np.clip(vel_cmd, -max_vel, max_vel)\n\n            vel_cmd_x = 0.003 * obj_ar_error\n            vel_cmd_x = np.clip(vel_cmd_x, -max_vel, max_vel)\n\n            self.vel_msg.header.stamp = self.get_clock().now().to_msg()\n            self.vel_msg.twist.linear.x = float(vel_cmd_x)\n            self.vel_msg.twist.linear.y = float(vel_cmd[0])\n            self.vel_msg.twist.linear.z = float(vel_cmd[1])\n\n            self.vel_pub.publish(self.vel_msg)\n\n            try:\n                tf = self.tf_buffer.lookup_transform(\n                    \"panda_link0\",\n                    \"camera_link\",\n                    rclpy.time.Time()\n                )\n\n                p = Point()\n                p.x = tf.transform.translation.x\n                p.y = tf.transform.translation.y\n                p.z = tf.transform.translation.z\n\n                self.marker.points.append(p)\n                self.marker.header.stamp = self.get_clock().now().to_msg()\n                self.marker_pub.publish(self.marker)\n\n            except Exception:\n                pass\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    node = ImageViewer()\n\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        pass\n\n    cv2.destroyAllWindows()\n    node.destroy_node()\n    rclpy.shutdown()\n\n\nif __name__ == '__main__':\n    main()\n"}\n{"instruction": "Write a ROS2 Python node named constrainedMovement.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "import rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import Image, CameraInfo\nimport cv2\nfrom showVideoFeed import CameraViewer\nfrom poseReader import PoseReader\nimport numpy as np\nfrom scipy.spatial.transform import Rotation as R\nimport subprocess\nfrom geometry_msgs.msg import Pose, TransformStamped, PoseStamped\nimport tf2_ros\nfrom rclpy.time import Time\nfrom tf2_geometry_msgs import do_transform_pose\nfrom poseReader import PoseReader \nimport sys\nimport time\nfrom geometry_msgs.msg import Point, Quaternion, Pose\nfrom tf_transformations import quaternion_from_euler, euler_from_quaternion\nfrom moveit_msgs.msg import PositionConstraint, BoundingVolume, SolidPrimitive\n\n\nclass constrainedMover(Node):\n\tdef __init__(self, poseReader: PoseReader):\n\t\tsuper().__init__('constrained_mover')\n\t\tself.poseReader = poseReader\n\t\tself.pose1 = np.array([0.35, 0.05, 0.45, 0, 0, 0])\n\t\tself.pose2 = np.array([0.35, -0.05, 0.45, 0, 0, 0])\n\n\t\tself.poseReader.moveit2.allowed_planning_time = 30.0\n\t\t#self.poseReader.moveit2.pipeline_id = \"ompl\"\n\t\t#self.poseReader.moveit2.planner_id = \"RRTConnectkConfigDefault\"\n\t\ttime.sleep(4.0)  # Wait for MoveIt2 to be ready\n\t\tself.moveBetweenPoses()\n\n\tdef moveBetweenPoses(self):\n\t\tfor i in range(10):\n\t\t\tpos1 = self.pose1[0:3]\n\t\t\tori1 = self.pose1[3:6]\n\t\t\tpos2 = self.pose2[0:3]\n\t\t\tori2 = self.pose2[3:6]\n\t\t\tself.move_to_pose_constrained(pos1, ori1)\n\t\t\ttime.sleep(0.5)  # Pause between steps\n\t\t\tself.move_to_pose_constrained(pos2, ori2)\n\t\t\ttime.sleep(0.5)  # Pause between steps\n\t\treturn\n\tdef move_to_pose_constrained(self, pos, euler):\n\t\t# Transform to bad frame and get quaternion\n\t\tbad_pos, bad_euler = self.poseReader.to_bad_frame(pos, euler)\n\t\tq = quaternion_from_euler(bad_euler[0], bad_euler[1], bad_euler[2])\n\t\tq_msg = Quaternion(x=q[0], y=q[1], z=q[2], w=q[3])\n\n\t\t# Set orientation constraint (constant orientation)\n\t\tself.poseReader.moveit2.set_path_orientation_constraint(\n\t\t\tquat_xyzw=q,\n\t\t\tframe_id=\"base_link\",  # or the appropriate frame\n\t\t\ttarget_link=self.poseReader.end_effector_name,\n\t\t\ttolerance=0.15  # Increase tolerance for path constraints\n\t\t)\n\n\t\t# Move to pose with constraint\n\t\tself.poseReader.moveit2.move_to_pose(position=Point(x=bad_pos[0], y=bad_pos[1], z=bad_pos[2]), quat_xyzw=q_msg)\n\t\tself.poseReader.moveit2.wait_until_executed()\n\n\t\t# Clear path constraints after movement\n\t\tself.poseReader.moveit2.clear_path_constraints()\n\n\tdef add_movement_constraint(self, constraint_type, value):\n\t\t\"\"\"\n\t\tAdd a path constraint without moving.\n\t\tconstraint_type: 'orientation' or 'x', 'y', 'z'\n\t\tvalue: for 'orientation', tuple (x,y,z,w) quaternion\n\t\t\t   for 'x','y','z', float value to constrain to\n\t\t\"\"\"\n\t\tif constraint_type == 'orientation':\n\t\t\t# Assume value is (x,y,z,w) quaternion tuple\n\t\t\tself.poseReader.moveit2.set_path_orientation_constraint(\n\t\t\t\tquat_xyzw=value,\n\t\t\t\tframe_id=\"base_link\",\n\t\t\t\ttarget_link=self.poseReader.end_effector_name,\n\t\t\t\ttolerance=0.15\n\t\t\t)\n\t\telif constraint_type in ['x', 'y', 'z']:\n\t\t\t# Get current position\n\t\t\tself.poseReader.get_fk()\n\t\t\tcurrent_pos = self.poseReader.pose[:3]  # [x, y, z]\n\t\t\taxis_index = {'x': 0, 'y': 1, 'z': 2}[constraint_type]\n\t\t\t\n\t\t\t# Set constrained position\n\t\t\tconstrained_pos = current_pos.copy()\n\t\t\tconstrained_pos[axis_index] = value\n\t\t\t\n\t\t\t# Create position constraint with box for anisotropic tolerance\n\t\t\tconstraint = PositionConstraint()\n\t\t\tconstraint.header.frame_id = \"base_link\"\n\t\t\tconstraint.link_name = self.poseReader.end_effector_name\n\t\t\tconstraint.constraint_region = BoundingVolume()\n\t\t\tconstraint.constraint_region.primitives.append(SolidPrimitive())\n\t\t\tconstraint.constraint_region.primitives[0].type = 1  # BOX\n\t\t\t# Dimensions: half-sizes\n\t\t\ttol_small = 0.001  # tight constraint on the axis\n\t\t\ttol_large = 10.0   # loose on others\n\t\t\tdimensions = [tol_large, tol_large, tol_large]\n\t\t\tdimensions[axis_index] = tol_small\n\t\t\tconstraint.constraint_region.primitives[0].dimensions = dimensions\n\t\t\tconstraint.constraint_region.primitive_poses.append(Pose())\n\t\t\tconstraint.constraint_region.primitive_poses[0].position.x = constrained_pos[0]\n\t\t\tconstraint.constraint_region.primitive_poses[0].position.y = constrained_pos[1]\n\t\t\tconstraint.constraint_region.primitive_poses[0].position.z = constrained_pos[2]\n\t\t\tconstraint.weight = 1.0\n\t\t\t\n\t\t\t# Append to path constraints\n\t\t\tself.poseReader.moveit2._MoveIt2__move_action_goal.request.path_constraints.position_constraints.append(constraint)\n\t\telse:\n\t\t\tself.get_logger().error(f\"Unknown constraint type: {constraint_type}\")\n\t\n\trclpy.init(args=argv)\n\t\n\tposeReader = PoseReader(enable_pose_print=False)\n\tnode = constrainedMover(poseReader)\n\ttry:\n\t\trclpy.spin(node)\n\texcept KeyboardInterrupt:\n\t\tpass\n\tfinally:\n\t\tnode.destroy_node()\n\t\trclpy.shutdown()\n\n\nif __name__ == \"__main__\":\n\tmain(sys.argv)"}\n{"instruction": "Write a ROS2 Python node named proc_monitor.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "#BSD 3-Clause License\n#\n#Copyright (c) 2021, Florent Audonnet\n#All rights reserved.\n#\n#Redistribution and use in source and binary forms, with or without\n#modification, are permitted provided that the following conditions are met:\n#\n#1. Redistributions of source code must retain the above copyright notice, this\n#   list of conditions and the following disclaimer.\n#\n#2. Redistributions in binary form must reproduce the above copyright notice,\n#   this list of conditions and the following disclaimer in the documentation\n#   and/or other materials provided with the distribution.\n#\n#3. Neither the name of the copyright holder nor the names of its\n#   contributors may be used to endorse or promote products derived from\n#   this software without specific prior written permission.\n#\n#THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n#AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n#IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n#DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n#FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n#DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n#SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n#CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n#OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n#OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nimport os\nimport signal\nimport sys\nfrom collections import defaultdict\n\nimport psutil\nimport rclpy\nfrom rclpy.node import Node\n\n\nclass ProcMonitor(Node):\n    \"\"\"\n    Create the main window and connect the menu bar slots.\n    \"\"\"\n\n    def __init__(self, allowed, idx, sim_name):\n        super().__init__('proccess_monitor')\n        self.cpu_dict = defaultdict(list)\n        self.ram_dict = defaultdict(list)\n        self.allowed = allowed\n        self.procs = {}\n        self.pids = {}\n        self.counter = 0\n        self.current_length = 0\n        self.update_missing()\n        self.timer = self.create_timer(0.1, self.animate)\n        self.idx = idx\n        self.sim_name = sim_name\n\n    def update_missing(self):\n        length = len(self.procs.keys())\n        if self.counter < 10:\n            if self.current_length >= length:\n                self.counter += 1\n            else:\n                self.counter = 0\n                self.current_length = length\n\n            for proc in psutil.process_iter():\n                p = proc.name()\n                if p in self.allowed and proc.pid not in self.procs.keys():\n                    self.procs[proc.pid] = proc\n                    self.pids[proc.pid] = proc.name()\n                    proc.cpu_percent()  # discard value\n                    proc.cpu_percent()  # discard value\n\n    def animate(self):\n        self.update_missing()\n        for pid, p in self.procs.items():\n            try:\n                with p.oneshot():\n                    cpu_usage = p.cpu_percent()\n                    if cpu_usage > 2400:\n                        print(\"Error : High Cpu Usage\")\n                        cpu_usage = 2400\n                    ram_usage = p.memory_info().rss / (1024*1024)\n                    self.cpu_dict[pid].append(cpu_usage)\n                    self.ram_dict[pid].append(ram_usage)\n            except:\n                pass\n\n    def dump_values(self):\n        self.name = {}\n        for pid, name in self.pids.items():\n            new_p = name\n            counter = 0\n            while new_p in self.name.keys():\n                counter += 1\n                new_p = new_p + \"_\" + str(counter)\n            if counter != 0:\n                name = name+\"_\"+str(counter)\n            self.name[pid] = name\n\n        path = \"/home/ubb/Documents/PersonalProject/VrController/sim_recorder/data/\"\n        with open(path + f\"{self.sim_name}/cpu/cpu_{self.idx}.csv\", \"w\") as f:\n            for pid, el in self.cpu_dict.items():\n                f.write(f\"{self.name[pid]},{','.join(str(v) for v in el)}\\n\")\n        with open(path + f\"{self.sim_name}/ram/ram_{self.idx}.csv\", \"w\") as f:\n            for pid, el in self.ram_dict.items():\n                f.write(f\"{self.name[pid]},{','.join(str(v) for v in el)}\\n\")\n        sys.exit(0)\n\n\nallowed_gazebo = [\n    \"throw_moveit\",\n    \"fake_joint_driver_node\",\n    \"gzclient\",\n    \"gzserver\",\n    \"mongod\",\n    \"move_group\",\n    \"moveit_collision\",\n    \"python3\",\n    \"robot_state_publisher\",\n    \"ros2\",\n    \"rviz2\",\n    \"static_transform_publisher\",\n    \"run_recording\",\n    \"moveit_controller\",\n]\n\nallowed_webots = [\n    \"throw_moveit\",\n    \"fake_joint_driver_node\",\n    \"mongod\",\n    \"move_group\",\n    \"python3\",\n    \"robot_state_publisher\",\n    \"ros2\",\n    \"rviz2\",\n    \"static_transform_publisher\",\n    \"webots\",\n    \"webots-bin\",\n    \"moveit_collision\",\n    \"run_recording\",\n    \"moveit_controller\",\n]\nallowed_ignition = [\n    \"move_group\",\n    \"parameter_bridge\",\n    \"python3\",\n    \"ros2\",\n    \"ruby\",\n    \"rviz2\",\n    \"run_recording\"\n]\nallowed_vr = [\n\"fake_joint_driver_node\",\n\"parameter_bridge\",\n\"republisher\",\n\"robot_state_publisher\",\n\"ros2\",\n\"ruby\",\n\"rviz2\",\n\"servo_pose_tracking_demo\",\n\"static_transform_publisher\",\n\"run_recording\"\n]\n\n\ndef run(simulator=\"webots\", idx=0, args=None):\n\n    rclpy.init(args=args)\n    if \"webots\" == simulator:\n        allowed = allowed_webots[1:]\n    elif \"gazebo\" == simulator:\n        allowed = allowed_gazebo[1:]\n    elif \"webots_throw\" == simulator:\n        allowed = allowed_webots[:-1]\n    elif \"gazebo_throw\" == simulator:\n        allowed = allowed_gazebo[:-1]\n    elif \"vr\" == simulator:\n        allowed = allowed_vr\n    else:\n        allowed = allowed_ignition\n\n    monitor = ProcMonitor(allowed, idx, simulator)\n    signal.signal(signal.SIGINT, lambda sig, frame: monitor.dump_values())\n    signal.signal(signal.SIGTERM, lambda sig, frame: monitor.dump_values())\n\n    rclpy.spin(monitor)\n    rclpy.shutdown()\n\n\ndef main(args=None):\n    run(args=args)\n\n\nif __name__ == '__main__':\n    main()\n"}\n{"instruction": "Write a ROS2 Python node named GUI_commander.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "import sys\nimport os\n\n# --- ROS 1/2 COMPATIBILITY FIX ---\n# Remove ROS 1 paths from sys.path to prevent conflicts (e.g. cv_bridge, sensor_msgs)\n# This must be done BEFORE importing any ROS packages\nsys.path = [p for p in sys.path if \"/opt/ros/noetic\" not in p and \"/opt/ros/melodic\" not in p]\n# ---------------------------------\n\nimport yaml\nimport rclpy\nfrom rclpy.node import Node\nimport tkinter as tk\nfrom tkinter import ttk, messagebox\nimport threading\nfrom threading import Thread, Lock, Event\nfrom functools import partial\nfrom geometry_msgs.msg import PoseStamped\nfrom moveit_msgs.action import MoveGroup\nfrom moveit_msgs.msg import MoveItErrorCodes\nfrom rclpy.action import ActionClient\nfrom sensor_msgs.msg import JointState\nfrom trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint\nfrom control_msgs.action import FollowJointTrajectory\nfrom controller_manager_msgs.srv import ListControllers\nfrom tf2_ros import Buffer, TransformListener, LookupException, ConnectivityException, ExtrapolationException\nfrom scipy.spatial.transform import Rotation as R\nimport time  # ADD THIS LINE\nfrom threading import Lock, Thread  # Update this line\nimport numpy as np\nfrom ament_index_python.packages import get_package_share_directory\nimport logging\nimport serial\nimport subprocess as sp  # For xdotool commands\nimport cv2\nimport math\nfrom std_msgs.msg import Bool, String, Empty\nfrom sensor_msgs.msg import Image as RosImage\nfrom cv_bridge import CvBridge\n\n\nfrom PIL import Image, ImageTk \nfrom moveit_msgs.srv import GetPositionIK\nfrom geometry_msgs.msg import PoseStamped\nfrom scipy.spatial.transform import Rotation as R\nfrom moveit_msgs.srv import GetPositionFK\nfrom moveit_msgs.msg import RobotState\nfrom moveit_msgs.srv import GetPositionIK, GetPositionFK\nfrom moveit_msgs.msg import RobotState, Constraints, PositionIKRequest\nfrom geometry_msgs.msg import PoseStamped, Pose\n\nimport serial \n\n# PegasusCommander import removed - using ROS topics instead\n# current_dir = os.path.dirname(os.path.abspath(__file__))\n# pegasus_script_path = os.path.abspath(os.path.join(current_dir, \"../../src/update_pegasus_description/scripts\"))\n# sys.path.append(pegasus_script_path)\n# from pegasus_commander import PegasusCommander as ExternalPegasusCommander\n\n# Import socket server\nfrom socket_server import SocketServer, RemoteCommand, CommandID\n\nportname = '/tmp/virtual_arduino_sim'\n\n# Workspace limits calculated from URDF (conservative estimates)\nWORKSPACE_LIMITS = {\n    'x': (0.05, 0.65),\n    'y': (-0.40, 0.40),   \n    'z': (0.05, 0.60),    \n    'roll': (-3.14, 3.14),\n    'pitch': (-1.57, 1.57),\n    'yaw': (-3.14, 3.14)\n}\n\n\n\nMOVEIT_ERROR_CODES = {\n    MoveItErrorCodes.SUCCESS: \"Success\",\n    MoveItErrorCodes.FAILURE: \"Failure\",\n    MoveItErrorCodes.PLANNING_FAILED: \"Planning failed\",\n    MoveItErrorCodes.INVALID_MOTION_PLAN: \"Invalid motion plan\",\n    MoveItErrorCodes.MOTION_PLAN_INVALIDATED_BY_ENVIRONMENT_CHANGE: \"Plan invalidated by environment change\",\n    MoveItErrorCodes.CONTROL_FAILED: \"Control failed\",\n    MoveItErrorCodes.UNABLE_TO_AQUIRE_SENSOR_DATA: \"Unable to acquire sensor data\",\n    MoveItErrorCodes.TIMED_OUT: \"Operation timed out\",\n    MoveItErrorCodes.PREEMPTED: \"Operation preempted\",\n    MoveItErrorCodes.START_STATE_IN_COLLISION: \"Start state in collision\",\n    MoveItErrorCodes.START_STATE_VIOLATES_PATH_CONSTRAINTS: \"Start state violates path constraints\",\n    MoveItErrorCodes.GOAL_IN_COLLISION: \"Goal in collision\",\n    MoveItErrorCodes.GOAL_VIOLATES_PATH_CONSTRAINTS: \"Goal violates path constraints\",\n    MoveItErrorCodes.GOAL_CONSTRAINTS_VIOLATED: \"Goal constraints violated\",\n    MoveItErrorCodes.INVALID_GROUP_NAME: \"Invalid group name\",\n    MoveItErrorCodes.INVALID_GOAL_CONSTRAINTS: \"Invalid goal constraints\",\n    MoveItErrorCodes.INVALID_ROBOT_STATE: \"Invalid robot state\",\n    MoveItErrorCodes.INVALID_LINK_NAME: \"Invalid link name\",\n    MoveItErrorCodes.INVALID_OBJECT_NAME: \"Invalid object name\",\n    MoveItErrorCodes.FRAME_TRANSFORM_FAILURE: \"Frame transform failure\",\n    MoveItErrorCodes.COLLISION_CHECKING_UNAVAILABLE: \"Collision checking unavailable\",\n    MoveItErrorCodes.ROBOT_STATE_STALE: \"Robot state stale\",\n    MoveItErrorCodes.SENSOR_INFO_STALE: \"Sensor info stale\",\n    MoveItErrorCodes.COMMUNICATION_FAILURE: \"Communication failure\",\n    MoveItErrorCodes.NO_IK_SOLUTION: \"No IK solution\"\n}\n\ndef clamp_to_workspace(x, y, z, roll=None, pitch=None, yaw=None):\n    \"\"\"Clamp Cartesian pose to workspace boundaries.\n    Returns (clamped_x, clamped_y, clamped_z, clamped_roll, clamped_pitch, clamped_yaw, was_clamped)\n    \"\"\"\n    was_clamped = False\n    \n    # Clamp position\n    x_clamped = np.clip(x, WORKSPACE_LIMITS['x'][0], WORKSPACE_LIMITS['x'][1])\n    y_clamped = np.clip(y, WORKSPACE_LIMITS['y'][0], WORKSPACE_LIMITS['y'][1])\n    z_clamped = np.clip(z, WORKSPACE_LIMITS['z'][0], WORKSPACE_LIMITS['z'][1])\n    \n    if x != x_clamped or y != y_clamped or z != z_clamped:\n        was_clamped = True\n    \n    # Clamp orientation if provided\n    roll_clamped = pitch_clamped = yaw_clamped = None\n    if roll is not None:\n        roll_clamped = np.clip(roll, WORKSPACE_LIMITS['roll'][0], WORKSPACE_LIMITS['roll'][1])\n        if roll != roll_clamped:\n            was_clamped = True\n    if pitch is not None:\n        pitch_clamped = np.clip(pitch, WORKSPACE_LIMITS['pitch'][0], WORKSPACE_LIMITS['pitch'][1])\n        if pitch != pitch_clamped:\n            was_clamped = True\n    if yaw is not None:\n        yaw_clamped = np.clip(yaw, WORKSPACE_LIMITS['yaw'][0], WORKSPACE_LIMITS['yaw'][1])\n        if yaw != yaw_clamped:\n            was_clamped = True\n    \n    return x_clamped, y_clamped, z_clamped, roll_clamped, pitch_clamped, yaw_clamped, was_clamped\n\n\n\nclass HandTrackingDisplay(ttk.LabelFrame):\n    \"\"\"Widget to display real-time hand tracking data in a compact horizontal layout\"\"\"\n    \n    def __init__(self, parent):\n        super().__init__(parent, text=\"Hand Tracking\", padding=\"5\")\n        \n        # Create main horizontal container\n        main_container = ttk.Frame(self)\n        main_container.pack(fill=tk.X, expand=False)\n        \n        # Left side: Position display (horizontal layout)\n        position_frame = ttk.Frame(main_container)\n        position_frame.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)\n        \n        ttk.Label(position_frame, text=\"Position:\", font=(\"Helvetica\", 9, \"bold\")).pack(side=tk.LEFT, padx=(0, 5))\n        \n        self.x_label = ttk.Label(position_frame, text=\"X: --\", font=(\"Courier\", 8))\n        self.x_label.pack(side=tk.LEFT, padx=3)\n        \n        self.y_label = ttk.Label(position_frame, text=\"Y: --\", font=(\"Courier\", 8))\n        self.y_label.pack(side=tk.LEFT, padx=3)\n        \n        self.z_label = ttk.Label(position_frame, text=\"Z: --\", font=(\"Courier\", 8))\n        self.z_label.pack(side=tk.LEFT, padx=3)\n        \n        # Middle: Gesture display\n        gesture_frame = ttk.Frame(main_container)\n        gesture_frame.pack(side=tk.LEFT, padx=10)\n        \n        ttk.Label(gesture_frame, text=\"Gesture:\", font=(\"Helvetica\", 9, \"bold\")).pack(side=tk.LEFT, padx=(0, 5))\n        \n        self.gesture_var = tk.StringVar(value=\"None\")\n        self.gesture_label = ttk.Label(\n            gesture_frame, \n            textvariable=self.gesture_var,\n            font=(\"Courier\", 10, \"bold\"),\n            foreground=\"#00AA00\"\n        )\n        self.gesture_label.pack(side=tk.LEFT)\n        \n        # Right side: Connection status\n        status_frame = ttk.Frame(main_container)\n        status_frame.pack(side=tk.LEFT, padx=10)\n        \n        self.status_var = tk.StringVar(value=\"Disconnected\")\n        status_label = ttk.Label(status_frame, textvariable=self.status_var, font=(\"Helvetica\", 8))\n        status_label.pack(side=tk.LEFT)\n        \n    def update_position(self, x: float, y: float, z: float):\n        \"\"\"Update position display\"\"\"\n        self.x_label.config(text=f\"X: {x:6.1f}\")\n        self.y_label.config(text=f\"Y: {y:6.1f}\")\n        self.z_label.config(text=f\"Z: {z:6.3f}\")\n        self.status_var.set(\"Connected\")\n    \n    def update_gesture(self, gesture: str):\n        \"\"\"Update gesture display\"\"\"\n        self.gesture_var.set(gesture)\n        # Change color based on gesture\n        color_map = {\n            \"Open_Palm\": \"#0066FF\",\n            \"Closed_Fist\": \"#FF0000\",\n            \"Thumb_Up\": \"#00AA00\",\n            \"Thumb_Down\": \"#FFA500\",\n            \"None\": \"#888888\"\n        }\n        self.gesture_label.config(foreground=color_map.get(gesture, \"#888888\"))\n    \n    def set_disconnected(self):\n        \"\"\"Mark as disconnected\"\"\"\n        self.status_var.set(\"⚫ Disconnected\")\n        self.x_label.config(text=\"X: --\")\n        self.y_label.config(text=\"Y: --\")\n        self.z_label.config(text=\"Z: --\")\n        self.gesture_var.set(\"None\")\n\n\n\n\n\nclass PegasusArmGUI:\n    \"\"\"GUI class (NOT a ROS node to avoid blocking initialization)\"\"\"\n\n\n    def __init__(self, root, node=None, wait_for_services=False):\n        self.root = root\n        self.node = node  # Store the ROS node\n        # Use print for logging since we're not a ROS node\n        \n        class SimpleLogger:\n            def info(self, msg):\n                print(f\"[GUI] {msg}\")\n            def error(self, msg):\n                print(f\"[GUI ERROR] {msg}\")\n            def warn(self, msg):\n                print(f\"[GUI WARN] {msg}\")\n            def debug(self, msg):\n                pass  # Silent debug logs\n        \n        self.logger = SimpleLogger()\n\n        # Initialize status variables\n        self.timestamp_var = tk.StringVar(value=\"Timestamp: --:--:--\")\n        self.tf_status_var = tk.StringVar(value=\"TF Status: Checking...\")\n\n        # Joint info\n        self.joint_names = ['joint1', 'joint2', 'joint3', 'joint4', 'joint5']\n        self._current_values = [0.0] * len(self.joint_names)\n        \n        # Default joint limits (min, max)\n        self.joint_limits = {\n            'joint1': (-3.14, 3.14),\n            'joint2': (-0.61, 0.61),\n            'joint3': (-1.75, 1.75),\n            'joint4': (-1.31, 1.31),\n            'joint5': (-6.28, 6.28)\n        }\n\n        # Frames for TF and planning\n        self.base_frame = \"base_link\"\n        self.end_effector_link = \"tool0\"\n        self.end_effector_frame = \"tool0\"\n        # Cartesian active trackers (new)\n        self.cartesian_slider_active = {}  # e.g., {'X': False, 'Y': False, 'Z': False}\n        self.orientation_slider_active = {}  # e.g., {'Roll': False, ...}\n        # Status flags\n        self.moveit_enabled = tk.BooleanVar(value=False)\n        self.controller_manager_available = False\n        self.tf_available = False\n        self.action_server_available = False\n        self.controller_available = False\n        self.joint_states_available = False\n        self.use_orientation = tk.BooleanVar(value=True)  # Enable RPY sliders by default\n        \n        # Add control mode (new - was missing)\n        self.control_mode = tk.StringVar(value=\"joint\")\n        self.control_mode.trace('w', self.on_control_mode_changed)\n        \n        # Cartesian active trackers (updated: init as dicts with defaults)\n        self.cartesian_slider_active = {'X': False, 'Y': False, 'Z': False}\n        self.orientation_slider_active = {'Roll': False, 'Pitch': False, 'Yaw': False}\n        \n        # Joint active tracker (new - was missing)\n        self.slider_active = [False] * len(self.joint_names)\n        self.slider_touched = [False] * len(self.joint_names)  # Track if user has moved slider\n        \n        # Add these missing attributes\n        self.movement_in_progress = Event()\n        self.lock = Lock()\n        self.goal_lock = Lock()  # Added missing lock for thread-safety\n        self.last_command_time = 0\n        self.command_cooldown = 0.1\n        self.error_dialog_active = False\n        self.controller_name = \"pegasus_arm_controller\"\n        self.current_joint_positions = None\n        self.current_joint_time = 0\n        \n        # Debouncing for Cartesian sliders\n        self.last_cartesian_plan_time = 0\n        self.cartesian_plan_cooldown = 0.1  # 100ms between plans\n        self.hand_control_enabled = tk.BooleanVar(value=False)\n        self.hand_control_active = False\n        self.last_hand_command_time = 0\n        self.hand_command_cooldown = 0.05  # Seconds between hand commands (20Hz)\n        \n        # Subscribe to hand control topics (will be created when commander initializes)\n        self.hand_cartesian_sub = None\n        self.hand_gesture_sub = None\n        self.hand_active_sub = None\n\n        # Initialize commander as a separate PegasusCommander instance\n        try:\n            print(\"[GUI] Initializing ExternalPegasusCommander...\")\n            sys.stdout.flush()\n            \n            # DO NOT INITIALIZE EXTERNAL COMMANDER - IT BLOCKS!\n            # We'll skip it and the GUI will work without it\n            self.commander = None\n            # Hand tracking initialization\n            self.hand_tracker = None\n            self.last_hand_update = 0\n            self.hand_tracking_enabled = tk.BooleanVar(value=False)  # Disabled by default\n            \n            # Initialize CvBridge for camera feed\n            self.bridge = CvBridge()\n            \n            # RViz positioning vars\n            # self.rviz_window_title = \"Pegasus Arm RViz\"  # Matches launcher env var\n            self.auto_position_rviz = tk.BooleanVar(value=True)  # Toggle for auto-snap\n            self.rviz_position_timer = None  # For periodic checks\n            self.rviz_placeholder = None  # Ref to hide placeholder\n            print(\"[GUI] ℹ ExternalPegasusCommander will be initialized in background...\")\n            sys.stdout.flush()\n                \n        except Exception as e:\n            print(f\"[GUI] ✗ Warning: Failed to initialize ExternalPegasusCommander: {e}\")\n            import traceback\n            traceback.print_exc()\n            sys.stdout.flush()\n        # Initialize ROS publishers for remote control\n        if self.node:\n            self.joint_cmd_pub = self.node.create_publisher(JointState, '/pegasus/command/joint_target', 10)\n            self.pose_cmd_pub = self.node.create_publisher(PoseStamped, '/pegasus/command/pose_target', 10)\n            self.stop_cmd_pub = self.node.create_publisher(Empty, '/pegasus/command/stop', 10) # Need to import Empty\n            \n            # Subscribe to status\n            self.execution_status_sub = self.node.create_subscription(Bool, '/pegasus/status/execution', self.execution_status_callback, 10)\n            self.pose_status_sub = self.node.create_subscription(PoseStamped, '/pegasus/status/pose', self.pose_status_callback, 10)\n            \n            # Subscribe to joint feedback (from Listener)\n            self.latest_feedback = None\n            self.feedback_sub = self.node.create_subscription(JointState, '/joint_states_feedback', self.feedback_callback, 10)\n        else:\n            print(\"[GUI] ⚠ No ROS node provided - running in offline mode\")\n            self.joint_cmd_pub = None\n            self.pose_cmd_pub = None\n            self.stop_cmd_pub = None\n        \n        self.commander = None # No direct commander object\n        \n        # Hand tracking initialization\n        self.hand_tracker = None\n        self.last_hand_update = 0\n        self.hand_tracking_enabled = tk.BooleanVar(value=False)  # Disabled by default\n\n        # Named poses\n        self.named_poses = {\n            'home': [0.0, -0.26, 0.0, 0.0, 0.0],\n            'extended': [-6.2, -0.2676, -0.1221, 0.3017, -6.2]\n        }\n\n        # Publishers (moved up for query_robot_positions dependency)\n        print(\"[GUI] Creating joint_state publisher...\")\n        sys.stdout.flush()\n        self.joint_state_pub = None  # Skip - not a ROS node\n\n        # Query initial positions at startup for MoveIt starting state (moved after publishers)\n        print(\"[GUI] Querying robot positions...\")\n        sys.stdout.flush()\n        self.query_robot_positions()\n\n        # Initialize socket server for remote control (do this after GUI setup to avoid blocking)\n        print(\"[GUI] Initializing socket server placeholder...\")\n        sys.stdout.flush()\n        self.socket_server = None\n        self.remote_source = None  # Track source of remote commands\n\n        # TF listener\n        print(\"[GUI] Creating TF buffer and listener...\")\n        sys.stdout.flush()\n        try:\n            self.tf_buffer = Buffer()\n            self.tf_listener = None  # Skip - not a ROS node\n            self.tf_available = False\n        except Exception as e:\n            print(f\"[GUI] Warning: TF unavailable at init: {e}\")\n            sys.stdout.flush()\n\n        # Check controller manager (non-blocking)\n        print(\"[GUI] Creating controller manager client...\")\n        sys.stdout.flush()\n        try:\n            self.cm_client = None  # Skip - not a ROS node\n            self.controller_manager_available = False\n        except Exception:\n            print(\"[GUI] Warning: Controller manager client creation failed\")\n            sys.stdout.flush()\n\n        # GUI\n        print(\"[GUI] Setting up GUI...\")\n        sys.stdout.flush()\n        self.setup_gui()\n        print(\"[GUI] GUI setup complete\")\n        sys.stdout.flush()\n        \n        print(\"[GUI] Starting display updates...\")\n        sys.stdout.flush()\n        self.update_displays()\n        \n        # Initialize socket server after GUI is up (in background)\n        print(\"[GUI] Scheduling socket server initialization...\")\n        sys.stdout.flush()\n        self.init_socket_server_async()\n        \n        # Setup hand control subscriptions\n        print(\"[GUI] Setting up hand control subscriptions...\")\n        sys.stdout.flush()\n        self.setup_hand_control_subscriptions()\n        \n        print(\"[GUI] PegasusArmGUI initialization COMPLETE\")\n        sys.stdout.flush()\n\n\n\n\n    def setup_hand_control_subscriptions(self):\n        \"\"\"Setup ROS2 subscriptions for hand control data from cv_pegasus_bridge.\"\"\"\n        if not self.node:\n            self.log_action(\"⚠ No ROS node available for hand control setup\")\n            return\n        \n        try:\n            # Subscribe to Cartesian commands from bridge\n            self.hand_cartesian_sub = self.node.create_subscription(\n                PoseStamped,\n                '/hand_control/cartesian_command',\n                self.hand_cartesian_callback,\n                10\n            )\n            \n            # Gesture subscription REMOVED\n            self.hand_gesture_sub = None\n            \n            # Subscribe to tracking active status\n            self.hand_active_sub = self.node.create_subscription(\n                Bool,\n                '/hand_control/control_active',\n                self.hand_active_callback,\n                10\n            )\n            \n            self.log_action(\"✓ Hand control subscriptions created\")\n            \n        except Exception as e:\n            self.log_action(f\"✗ Hand control setup error: {e}\")\n            # Retry on error too, just in case\n            self.root.after(5000, self.setup_hand_control_subscriptions)\n\n\n\n    def execution_status_callback(self, msg):\n        \"\"\"Update execution status from headless commander\"\"\"\n        is_executing = msg.data\n        # Update GUI state if needed\n        # For example, disable buttons if executing\n        pass\n\n    def pose_status_callback(self, msg):\n        \"\"\"Update current pose from headless commander\"\"\"\n        # Update internal state\n        # msg is PoseStamped\n        x = msg.pose.position.x\n        y = msg.pose.position.y\n        z = msg.pose.position.z\n        \n        # Convert quat to RPY\n        r = R.from_quat([msg.pose.orientation.x, msg.pose.orientation.y, msg.pose.orientation.z, msg.pose.orientation.w])\n        roll, pitch, yaw = r.as_euler('xyz', degrees=False)\n        \n        # Update displays if not dragging sliders\n        # This logic was partly in update_displays, but we can do it here too or cache it\n        self.current_pose_cache = [x, y, z, roll, pitch, yaw]\n        \n        # Update TF status to \"OK\" since we are getting data\n        self.tf_status_var.set(\"TF Status: OK (Remote)\")\n\n    def feedback_callback(self, msg):\n        \"\"\"Store latest feedback from robot\"\"\"\n        self.latest_feedback = msg\n\n    def sync_home_from_robot(self):\n        \"\"\"Read current robot position and set as Home\"\"\"\n        if self.latest_feedback:\n            # Update Home preset\n            # Assuming joint order: joint1, joint2, joint3, joint4, joint5\n            # Feedback msg.position has them in this order\n            \n            # Deep copy to avoid reference issues\n            new_home = list(self.latest_feedback.position)\n            \n            # Update preset\n            self.named_poses['home'] = new_home\n            \n            # Update sliders if in joint mode\n            if self.control_mode.get() == \"joint\":\n                for i in range(min(len(new_home), 5)):\n                    self.joint_vars[i].set(new_home[i])\n            \n            # Reset touched status since we synced\n            self.slider_touched = [False] * len(self.joint_names)\n                    \n            self.log_action(f\" Home synced to: {[f'{x:.2f}' for x in new_home]}\")\n            messagebox.showinfo(\"Sync Complete\", \"Home position updated to current robot state.\")\n        else:\n            self.log_action(\"✗ No feedback received yet\")\n            messagebox.showwarning(\"Sync Failed\", \"No feedback received from robot yet.\\nIs the listener running?\")\n\n    def hand_cartesian_callback(self, msg):\n        \"\"\"Handle incoming Cartesian commands from hand tracking.\"\"\"\n        # Check if hand control is enabled in GUI\n        if not self.hand_control_enabled.get():\n            return\n        \n        # Check if in Cartesian mode\n        if self.control_mode.get() != \"cartesian\":\n            # print(f\"[DEBUG] Hand control ignored: Mode is {self.control_mode.get()}\")\n            return\n        \n        # Check if hand control is active (from bridge)\n        if not self.hand_control_active:\n            return\n            \n        # Rate limiting\n        current_time = time.time()\n        if current_time - self.last_hand_command_time < self.hand_command_cooldown:\n            return\n        \n        self.last_hand_command_time = current_time\n        \n        try:\n            # Extract position\n            x = msg.pose.position.x\n            y = msg.pose.position.y\n            z = msg.pose.position.z\n            \n            # Extract orientation\n            q = [msg.pose.orientation.x, msg.pose.orientation.y, msg.pose.orientation.z, msg.pose.orientation.w]\n            r = R.from_quat(q)\n            roll, pitch, yaw = r.as_euler('xyz', degrees=False)\n            \n            # Update GUI sliders (in main thread)\n            def update_sliders():\n                if hasattr(self, 'xyz_vars'):\n                    self.xyz_vars['X'].set(x)\n                    self.xyz_vars['Y'].set(y)\n                    self.xyz_vars['Z'].set(z)\n                    \n                    # Update displays\n                    self.xyz_values_display['X'].config(text=f\"{x:.3f}\")\n                    self.xyz_values_display['Y'].config(text=f\"{y:.3f}\")\n                    self.xyz_values_display['Z'].config(text=f\"{z:.3f}\")\n                \n                if hasattr(self, 'rpy_vars') and self.use_orientation.get():\n                    self.rpy_vars['Roll'].set(roll)\n                    self.rpy_vars['Pitch'].set(pitch)\n                    self.rpy_vars['Yaw'].set(yaw)\n                    \n                    # Update displays\n                    self.rpy_values_display['Roll'].config(text=f\"{roll:.3f}\")\n                    self.rpy_values_display['Pitch'].config(text=f\"{pitch:.3f}\")\n                    self.rpy_values_display['Yaw'].config(text=f\"{yaw:.3f}\")\n            \n            self.root.after(0, update_sliders)\n\n            # Removed: self.hand_control_active = True (Strictly controlled by bridge now)\n\n            # Auto-plan if tracking is active and not executing (moved from gesture callback)\n            # We use the same rate limiting as above (self.last_hand_command_time)\n            # Auto-plan if tracking is active (Robust version)\n            if self.hand_control_active:\n                # Check if not already executing (using internal flag)\n                # Fix: Check if commander exists before accessing attributes\n                is_executing = False\n                if self.commander and hasattr(self.commander, 'is_executing'):\n                    is_executing = self.commander.is_executing\n                \n                if not is_executing:\n                    # self.log_action(f\" Auto-planning from cartesian update\")\n                    # print(\"[DEBUG] Triggering plan_current_mode from hand callback\")\n                    self.root.after(0, self.plan_current_mode)\n            else:\n                 pass\n            \n        except Exception as e:\n            self.logger.debug(f\"Hand cartesian callback error: {e}\")\n\n    def setup_hand_control_toggle(self):\n        \"\"\"Add hand control enable/disable toggle to GUI.\"\"\"\n        if not hasattr(self, 'control_frame'):\n            return\n        \n        # Create frame for hand control toggle\n        hand_control_frame = ttk.LabelFrame(\n            self.control_frame, \n            text=\"Hand Control\", \n            padding=\"5\"\n        )\n        hand_control_frame.pack(fill=tk.X, pady=(5,5))\n        \n        # Enable/disable checkbox\n        hand_toggle = ttk.Checkbutton(\n            hand_control_frame,\n            text=\"Enable Hand Tracking Control\",\n            variable=self.hand_control_enabled,\n            command=self.on_hand_control_toggle\n        )\n        hand_toggle.pack(side=tk.LEFT, padx=5)\n        \n        # Status label\n        self.hand_status_label = ttk.Label(\n            hand_control_frame,\n            text=\"Status: Disabled\",\n            font=(\"Helvetica\", 9)\n        )\n        self.hand_status_label.pack(side=tk.LEFT, padx=10)\n\n\n\n    def on_hand_control_toggle(self):\n        \"\"\"Handle hand control enable/disable toggle.\"\"\"\n        if self.hand_control_enabled.get():\n            self.log_action(\" Hand control ENABLED\")\n            self.hand_status_label.config(text=\"Status: Enabled\")\n            \n            # Switch to Cartesian mode if not already\n            if self.control_mode.get() != \"cartesian\":\n                self.control_mode.set(\"cartesian\")\n                self.on_control_mode_changed()\n        else:\n            self.log_action(\"⏸ Hand control DISABLED\")\n            self.hand_status_label.config(text=\"Status: Disabled\")\n            self.hand_control_active = False\n\n\n\n\n    def hand_active_callback(self, msg):\n        \"\"\"Update hand control active status.\"\"\"\n        self.hand_control_active = msg.data\n\n\n\n    def position_rviz_window(self):\n        \"\"\"Enhanced RViz window positioning with action log feedback\"\"\"\n        try:\n            if self.robot_view_frame.winfo_width() <= 0 or self.robot_view_frame.winfo_height() <= 0:\n                self.log_action(\" RViz frame not ready, retrying...\")\n                return False\n\n            frame_x = self.robot_view_frame.winfo_rootx()\n            frame_y = self.robot_view_frame.winfo_rooty()\n            frame_width = self.robot_view_frame.winfo_width()\n            frame_height = self.robot_view_frame.winfo_height()\n            \n            # Find RViz window\n            find_cmd = [\"xdotool\", \"search\", \"--class\", \"rviz\"]\n            result = sp.run(find_cmd, capture_output=True, text=True)\n            win_ids = result.stdout.strip().split('\\n')\n            \n            if not win_ids or win_ids == ['']:\n                # Only log every 5 attempts to reduce spam\n                if not hasattr(self, '_rviz_search_count'):\n                    self._rviz_search_count = 0\n                self._rviz_search_count += 1\n                if self._rviz_search_count % 5 == 0:\n                    self.log_action(f\" Searching for RViz window... (attempt {self._rviz_search_count})\")\n                return False\n\n            # Find main window (largest)\n            main_window = None\n            max_size = 0\n            \n            for win_id in win_ids:\n                try:\n                    geom_result = sp.run(\n                        [\"xdotool\", \"getwindowgeometry\", win_id],\n                        capture_output=True, text=True\n                    )\n                    \n                    if \"Geometry:\" in geom_result.stdout:\n                        geom_line = [l for l in geom_result.stdout.split('\\n') if 'Geometry:' in l][0]\n                        size_str = geom_line.split('Geometry:')[1].strip()\n                        w, h = map(int, size_str.split('x'))\n                        area = w * h\n                        \n                        if area > max_size:\n                            max_size = area\n                            main_window = win_id\n                except Exception:\n                    continue\n            \n            if not main_window:\n                main_window = win_ids[0]\n\n            # Get Tkinter frame window ID\n            frame_wid = self.robot_view_frame.winfo_id()\n            frame_x11_id = hex(frame_wid)\n\n            # Reparent RViz into frame\n            try:\n                sp.run([\"xdotool\", \"windowunmap\", main_window], timeout=1)\n                sp.run([\"wmctrl\", \"-i\", \"-r\", main_window, \"-b\", \"remove,maximized_vert,maximized_horz\"], timeout=1)\n                sp.run([\"xdotool\", \"windowreparent\", main_window, frame_x11_id], timeout=2)\n                sp.run([\"xdotool\", \"windowmap\", main_window], timeout=1)\n            except Exception as e:\n                self.log_action(f\" Reparenting failed: {e}\")\n\n            # Position and resize\n            sp.run([\"xdotool\", \"windowmove\", main_window, \"0\", \"0\"])\n            sp.run([\"xdotool\", \"windowsize\", main_window, str(frame_width), str(frame_height)])\n\n            try:\n                sp.run([\"wmctrl\", \"-i\", \"-r\", main_window, \"-b\", \"add,above\"], timeout=1)\n            except:\n                pass\n\n            sp.run([\"xdotool\", \"windowactivate\", main_window])\n\n            if self.rviz_placeholder:\n                self.rviz_placeholder.pack_forget()\n\n            self.log_action(f\" RViz positioned ({frame_width}x{frame_height})\")\n            \n            # Store window ID and stop auto-positioning\n            self.positioned_rviz_window_id = main_window\n            \n            if hasattr(self, 'rviz_position_timer') and self.rviz_position_timer:\n                self.root.after_cancel(self.rviz_position_timer)\n                self.rviz_position_timer = None\n                self.log_action(\"ℹ RViz auto-positioning stopped\")\n            \n            return True\n            \n        except FileNotFoundError:\n            self.log_action(\" xdotool not found - install with 'sudo apt install xdotool'\")\n            return False\n        except Exception as e:\n            self.log_action(f\" RViz positioning failed: {e}\")\n            return False\n\n\n\n\n\n\n\n\n    def start_rviz_positioning(self):\n        \"\"\"Poll for RViz and position it (initial setup).\"\"\"\n        def poll_loop():\n            # Skip if already positioned\n            if hasattr(self, 'positioned_rviz_window_id'):\n                self.log_action(\"RViz already positioned, skipping poll\")\n                return\n            \n            success = self.position_rviz_window()\n            \n            if success:\n                self.log_action(\" RViz positioned successfully on first attempt\")\n                # Start periodic checks ONLY if auto-position is enabled\n                if self.auto_position_rviz.get():\n                    self.periodic_rviz_reposition()\n            else:\n                # Retry every 2s if not found\n                self.log_action(\" RViz not found, retrying in 2s...\")\n                self.root.after(2000, poll_loop)\n\n        # Initial poll after 1s delay (for GUI render)\n        self.root.after(1000, poll_loop)\n\n\n\n\n    def manual_position_rviz(self):\n        \"\"\"Manual positioning with reset option\"\"\"\n        # Clear any previous positioning record\n        if hasattr(self, 'positioned_rviz_window_id'):\n            delattr(self, 'positioned_rviz_window_id')\n        \n        # Force immediate positioning\n        success = self.position_rviz_window()\n        \n        if not success:\n            self.log_action(\" Manual positioning failed - ensure RViz is running\")\n            \n\n\n    def periodic_rviz_reposition(self):\n        \"\"\"Auto-snap RViz every 5s if enabled - BUT stop if already positioned.\"\"\"\n        if not self.auto_position_rviz.get():\n            return  # User disabled it\n        \n        # Check if we already successfully positioned it\n        if hasattr(self, 'positioned_rviz_window_id'):\n            # Verify the window still exists\n            try:\n                result = sp.run(\n                    [\"xdotool\", \"getwindowname\", self.positioned_rviz_window_id],\n                    capture_output=True, text=True, timeout=1\n                )\n                if result.returncode == 0:\n                    # Window still exists, no need to reposition\n                    return\n                else:\n                    # Window was closed, reset and try again\n                    delattr(self, 'positioned_rviz_window_id')\n            except Exception:\n                # Error checking, assume window is gone\n                delattr(self, 'positioned_rviz_window_id')\n        \n        # Try to position\n        success = self.position_rviz_window()\n        \n        # Only schedule next check if positioning failed\n        if not success and self.auto_position_rviz.get():\n            self.rviz_position_timer = self.root.after(5000, self.periodic_rviz_reposition)\n\n\n\n\n\n    def auto_position_rviz_handler(self):\n        \"\"\"Toggle auto-reposition.\"\"\"\n        if self.auto_position_rviz.get():\n            if not self.rviz_position_timer:\n                self.periodic_rviz_reposition()\n            self.log_action(\" RViz auto-reposition: Enabled\")\n        else:\n            if self.rviz_position_timer:\n                self.root.after_cancel(self.rviz_position_timer)\n                self.rviz_position_timer = None\n            self.log_action(\" RViz auto-reposition: Disabled\")\n\n\n\n\n\n\n    def update_hand_tracking_display(self):\n        \"\"\"Update hand tracking display widget periodically. Log status changes.\"\"\"\n        try:\n            if not hasattr(self, 'hand_display') or self.hand_display is None:\n                self.root.after(50, self.update_hand_tracking_display)\n                return\n\n            # Fix: Reference hand_display's vars, not self's\n            prev_gesture = self.hand_display.gesture_var.get()\n            prev_connected = self.hand_display.status_var.get() == \"🟢 Connected\"\n\n            if not self.hand_tracker:\n                if prev_connected:\n                    self.log_action(\" Hand Tracking: Disconnected\")\n                self.hand_display.set_disconnected()\n                self.root.after(50, self.update_hand_tracking_display)\n                return\n\n            # Get current pose and gesture (unchanged)\n            pose = self.hand_tracker.get_current_pose()\n            gesture = self.hand_tracker.get_current_gesture()\n\n            # Update display (unchanged)\n            if pose:\n                self.hand_display.update_position(pose.x, pose.y, pose.z)\n                self.last_hand_update = time.time()\n            else:\n                if time.time() - self.last_hand_update > 2.0:\n                    self.log_action(\"Hand Tracking: Stale/Disconnected\")\n                    self.hand_display.set_disconnected()\n\n            if gesture and gesture.gesture != prev_gesture:\n                self.log_action(f\"Hand Gesture: {gesture.gesture} at ({pose.x:.1f}, {pose.y:.1f}, {pose.z:.1f})\" if pose else f\"👋 Hand Gesture: {gesture.gesture}\")\n                self.hand_display.update_gesture(gesture.gesture)\n\n            # Real-time Cartesian update (unchanged)\n            if self.hand_tracking_enabled.get() and pose and self.control_mode.get() == \"cartesian\":\n                self._update_cartesian_from_hand(pose)\n\n            if not prev_connected and self.hand_display.status_var.get() == \"🟢 Connected\":\n                self.log_action(\"Hand Tracking: Connected\")\n\n        except Exception as e:\n            self.logger.error(f\"Error updating hand tracking display: {e}\")\n            if not hasattr(self, '_hand_error_logged'):\n                self.log_action(f\" Hand Tracking ERROR: {str(e)}\")\n                self._hand_error_logged = True\n                self.root.after(5000, lambda: setattr(self, '_hand_error_logged', False))\n\n        self.root.after(50, self.update_hand_tracking_display)\n\n\n\n\n    def _update_cartesian_from_hand(self, pose):\n        \"\"\"Update Cartesian slider positions from hand tracking (optional real-time mode)\"\"\"\n        try:\n            # Check if any Cartesian slider is being dragged\n            if any(self.cartesian_slider_active):\n                return\n            \n            # Get normalized pose\n            pose_norm = self.hand_tracker.get_normalized_pose()\n            if pose_norm is None:\n                return\n            \n            x_norm, y_norm, z_norm = pose_norm\n            \n            # Map to robot workspace\n            x = 0.05 + x_norm * 0.60\n            y = -0.40 + (1.0 - y_norm) * 0.80\n            z = 0.05 + z_norm * 0.55\n            \n            # Update sliders (but don't trigger planning)\n            if hasattr(self, 'xyz_vars'):\n                self.xyz_vars['X'].set(x)\n                self.xyz_vars['Y'].set(y)\n                self.xyz_vars['Z'].set(z)\n                self.xyz_values_display['X'].config(text=f\"{x:.3f}\")\n                self.xyz_values_display['Y'].config(text=f\"{y:.3f}\")\n                self.xyz_values_display['Z'].config(text=f\"{z:.3f}\")\n        \n        except Exception as e:\n            self.logger.debug(f\"Error updating Cartesian from hand: {e}\")\n\n\n\n\n\n    # Gesture methods REMOVED\n\n\n\n\n\n\n    def setup_settings_tab(self, parent_frame):\n        \"\"\"Placeholder for settings tab setup.\"\"\"\n        settings_frame = ttk.Frame(parent_frame, padding=\"10\")\n        settings_frame.pack(fill=tk.BOTH, expand=True)\n        ttk.Label(settings_frame, text=\"Settings tab placeholder.\").pack(pady=20)\n\n\n\n\n\n\n    def init_socket_server_async(self):\n        \"\"\"Initialize socket server in background thread\"\"\"\n        def setup_server():\n            try:\n                self.log_action(\" Starting socket server...\")\n                self.socket_server = SocketServer(host='0.0.0.0', port=5000)\n                \n                from socket_server import HandTracker\n                self.hand_tracker = HandTracker()\n                self.socket_server.hand_tracker = self.hand_tracker\n                \n                self._setup_socket_handlers()\n                self._setup_gesture_controls()\n                \n                self.socket_server.start()\n                self.log_action(\" Socket server started on port 5000\")\n                \n                # Setup hand control subscriptions after commander is ready\n                self.root.after(2000, self.setup_hand_control_subscriptions)\n                \n            except Exception as e:\n                self.log_action(f\" Socket server failed: {e}\")\n        \n        threading.Thread(target=setup_server, daemon=True).start()\n\n\n\n\n\n\n    def _setup_gesture_controls(self):\n            \"\"\"Map hand gestures to robot actions - REMOVED\"\"\"\n            pass\n\n    # _gesture_move_to_position REMOVED\n\n\n\n\n    def _setup_socket_handlers(self):\n        \"\"\"Setup socket server handlers for remote commands\"\"\"\n        if not self.socket_server:\n            return\n        \n        try:\n            # Register remote command handlers\n            self.socket_server.register_command_handler(\n                CommandID.MOVE_JOINTS, self._handle_remote_move_joints)\n            self.socket_server.register_command_handler(\n                CommandID.MOVE_HOME, self._handle_remote_move_home)\n            self.socket_server.register_command_handler(\n                CommandID.MOVE_EXTENDED, self._handle_remote_move_extended)\n            self.socket_server.register_command_handler(\n                CommandID.MOVE_CARTESIAN, self._handle_remote_move_cartesian)\n            self.socket_server.register_command_handler(\n                CommandID.EMERGENCY_STOP, self._handle_remote_emergency_stop)\n            self.socket_server.register_command_handler(\n                CommandID.SET_VELOCITY, self._handle_remote_set_velocity)\n            self.socket_server.register_command_handler(\n                CommandID.CANCEL_GOAL, self._handle_remote_cancel_goal)\n            \n            # Register callbacks\n            self.socket_server.on_client_connected = self._on_remote_client_connected\n            self.socket_server.on_client_disconnected = self._on_remote_client_disconnected\n            self.socket_server.get_robot_state = self._get_robot_state\n            \n        except Exception as e:\n            print(f\"[GUI] Error setting up socket handlers: {e}\")\n\n\n\n\n\n\n    def _handle_remote_move_joints(self, command: RemoteCommand) -> dict:\n        \"\"\"Handle remote move joints command. Enhanced socket logging.\"\"\"\n        try:\n            if not command.joint_values:\n                raise ValueError(\"No joint values provided\")\n\n            self.remote_source = \"socket\"\n            incoming_data = f\"Joints: {[f'{v:.3f}' for v in command.joint_values]}, Velocity: {command.velocity or 0.3}\"\n            self.log_action(f\" Socket RX: Move Joints - {incoming_data}\")\n\n            velocity = command.velocity or 0.3\n            success, error_code = self.move_to_joint_positions(command.joint_values, velocity)\n\n            # Update GUI sliders if successful\n            if success:\n                self.root.after(0, lambda: self._update_sliders_from_joints(command.joint_values))\n                self.log_action(f\" Socket TX: Joint move SUCCEEDED (code: {error_code})\")\n\n            else:\n                self.log_action(f\" Socket TX: Joint move FAILED (code: {error_code})\")\n\n            return {'success': success, 'error_code': error_code}\n        except Exception as e:\n            self.logger.error(f\"Remote move joints error: {e}\")\n            self.log_action(f\" Socket ERROR: {str(e)}\")\n            return {'success': False, 'error': str(e)}\n\n\n\n\n\n    def _handle_remote_move_home(self, command: RemoteCommand) -> dict:\n        \"\"\"Handle remote move home command\"\"\"\n        try:\n            self.remote_source = \"socket\"\n            self.log_action(\" Remote command: Moving to Home position\")\n            success, error_code = self.move_to_named_target(\"home\", 0.3)\n            \n            if success:\n                home_pos = self.named_poses['home']\n                self.root.after(0, lambda: self._update_sliders_from_joints(home_pos))\n            \n            return {'success': success, 'error_code': error_code}\n        except Exception as e:\n            self.logger.error(f\"Remote move home error: {e}\")\n            return {'success': False, 'error': str(e)}\n\n    def _handle_remote_move_extended(self, command: RemoteCommand) -> dict:\n        \"\"\"Handle remote move extended command\"\"\"\n        try:\n            self.remote_source = \"socket\"\n            self.log_action(\" Remote command: Moving to Extended position\")\n            success, error_code = self.move_to_named_target(\"extended\", 0.3)\n            \n            if success:\n                extended_pos = self.named_poses['extended']\n                self.root.after(0, lambda: self._update_sliders_from_joints(extended_pos))\n            \n            return {'success': success, 'error_code': error_code}\n        except Exception as e:\n            self.logger.error(f\"Remote move extended error: {e}\")\n            return {'success': False, 'error': str(e)}\n\n    def _handle_remote_move_cartesian(self, command: RemoteCommand) -> dict:\n        \"\"\"Handle remote move to cartesian pose command\"\"\"\n        try:\n            if not command.cartesian_pose:\n                raise ValueError(\"No cartesian pose provided\")\n            \n            velocity = command.velocity or 0.3\n            self.remote_source = \"socket\"\n            \n            # Extract position and orientation\n            x, y, z = command.cartesian_pose[0:3]\n            roll, pitch, yaw = command.cartesian_pose[3:6] if len(command.cartesian_pose) >= 6 else (0.0, 0.0, 0.0)\n            \n            # Execute move using the correct method\n            success, error_code = self.commander.plan_to_cartesian_pose(x, y, z, roll, pitch, yaw)\n            \n            if success:\n                self.log_action(f\" Remote command: Moving to cartesian pose {[f'{v:.3f}' for v in command.cartesian_pose]}\")\n            \n            return {\n                'success': success,\n                'error_code': error_code if isinstance(error_code, int) else 0\n            }\n        except Exception as e:\n            self.logger.error(f\"Remote move cartesian error: {e}\")\n            return {'success': False, 'error': str(e)}\n\n    def _handle_remote_emergency_stop(self, command: RemoteCommand) -> dict:\n        \"\"\"Handle remote emergency stop command\"\"\"\n        try:\n            self.remote_source = \"socket\"\n            self.log_action(\" Remote command: EMERGENCY STOP\")\n            self.emergency_stop()\n            return {'success': True}\n        except Exception as e:\n            self.logger.error(f\"Remote emergency stop error: {e}\")\n            return {'success': False, 'error': str(e)}\n\n    def _handle_remote_set_velocity(self, command: RemoteCommand) -> dict:\n        \"\"\"Handle remote set velocity command\"\"\"\n        try:\n            if command.velocity is None:\n                raise ValueError(\"No velocity value provided\")\n            \n            # Clamp velocity between 0.1 and 1.0\n            velocity = max(0.1, min(1.0, command.velocity))\n            self.velocity_scale.set(velocity)\n            \n            self.log_action(f\" Remote command: Velocity set to {velocity:.2f}\")\n            return {'success': True, 'velocity': velocity}\n        except Exception as e:\n            self.logger.error(f\"Remote set velocity error: {e}\")\n            return {'success': False, 'error': str(e)}\n\n    def _handle_remote_cancel_goal(self, command: RemoteCommand) -> dict:\n        \"\"\"Handle remote cancel goal command\"\"\"\n        try:\n            self.remote_source = \"socket\"\n            self.log_action(\" Remote command: Cancelling active goal\")\n            self.cancel_current_goals()\n            return {'success': True}\n        except Exception as e:\n            self.logger.error(f\"Remote cancel goal error: {e}\")\n            return {'success': False, 'error': str(e)}\n\n    def _get_robot_state(self) -> dict:\n        \"\"\"Get current robot state for remote clients\"\"\"\n        try:\n            joint_values = self.get_current_joint_values()\n            pose = self.get_current_pose()\n            \n            return {\n                'joint_values': joint_values,\n                'pose': pose,\n                'joint_names': self.joint_names,\n                'connected': True\n            }\n        except Exception as e:\n            self.logger.error(f\"Get robot state error: {e}\")\n            return {'connected': False, 'error': str(e)}\n\n    def _on_remote_client_connected(self, client_id: int, address: tuple):\n        \"\"\"Callback when remote client connects\"\"\"\n        self.log_action(f\"Remote client {client_id} connected from {address}\")\n\n    def _on_remote_client_disconnected(self, client_id: int, address: tuple):\n        \"\"\"Callback when remote client disconnects\"\"\"\n        self.log_action(f\"Remote client {client_id} disconnected\")\n\n    def _update_sliders_from_joints(self, joint_values: list):\n        \"\"\"Update GUI sliders from joint values\"\"\"\n        try:\n            if not hasattr(self, 'joint_vars'):\n                return\n            \n            for i, (var, value) in enumerate(zip(self.joint_vars, joint_values)):\n                if i < len(joint_values):\n                    var.set(value)\n                    if i < len(self.joint_values):\n                        self.joint_values[i].config(text=f\"{value:.3f}\")\n        except Exception as e:\n            self.logger.error(f\"Error updating sliders: {e}\")\n\n    def setup_camera_tab(self, parent_frame):\n        \"\"\"Placeholder for camera tab setup.\"\"\"\n        camera_frame = ttk.Frame(parent_frame, padding=\"10\")\n        camera_frame.pack(fill=tk.BOTH, expand=True)\n        ttk.Label(camera_frame, text=\"Camera tab placeholder.\").pack(pady=20)\n\n    def update_tf_status(self):\n        \"\"\"Update TF status display.\"\"\"\n        if self.tf_available:\n            self.tf_status_var.set(f\"TF Status: Connected (Base: {self.base_frame} → {self.end_effector_frame})\")\n        else:\n            self.tf_status_var.set(f\"TF Status: Disconnected\")\n        self.root.after(5000, self.update_tf_status)\n\n    def refresh_tf_status(self):\n        \"\"\"Refresh TF status and frames.\"\"\"\n        new_base_frame = self.base_frame_var.get()\n        if new_base_frame != self.base_frame:\n            self.base_frame = new_base_frame\n        self.check_tf_availability()\n        self.update_tf_status()\n\n\n\n\n\n    def on_closing(self):\n        \"\"\"Handle GUI closing with action log feedback\"\"\"\n        if messagebox.askokcancel(\"Quit\", \"Do you want to quit?\"):\n            self.log_action(\" Shutting down Pegasus Arm Controller...\")\n            \n            # Stop movements\n            self.cancel_current_goals()\n            self.log_action(\"Movement goals cancelled\")\n            \n            # Stop camera\n            if hasattr(self, 'camera_active') and self.camera_active:\n                self.stop_camera_feed()\n                self.log_action(\" Camera stopped\")\n            \n            # Stop socket server\n            if hasattr(self, 'socket_server') and self.socket_server:\n                self.socket_server.stop()\n                self.log_action(\" Socket server stopped\")\n            \n            # Cancel RViz timer\n            if hasattr(self, 'rviz_position_timer') and self.rviz_position_timer:\n                self.root.after_cancel(self.rviz_position_timer)\n            \n            # Minimize RViz\n            try:\n                sp.run([\"xdotool\", \"search\", \"--class\", \"rviz\", \"windowminimize\"], timeout=1)\n            except:\n                pass\n            \n            self.log_action(\" Goodbye!\")\n            self.root.destroy()\n\n\n\n\n\n\n\n\n\n    def query_robot_positions(self):\n        \"\"\"Initialize joint states with home position for MoveIt.\"\"\"\n        try:\n            # Use home position as starting point\n            current_pos = self.named_poses['home']\n            \n            # Update internal state (thread-safe)\n            self.set_current_joint_values(current_pos)\n            \n            # Skip publishing - GUI is not a ROS node\n            return True\n            \n        except Exception as e:\n            print(f\"Warning: Error initializing positions: {str(e)}\")\n            return False\n\n\n\n    def update_displays(self):\n        \"\"\"Update all GUI displays with current values. Log key status changes.\"\"\"\n        try:\n            # Only update displays if they've been initialized\n            if hasattr(self, 'joint_values') and self.joint_values:\n                # Update joint value displays\n                joint_values = self.get_current_joint_values()\n                for i, value in enumerate(joint_values):\n                    if i < len(self.joint_values):\n                        self.joint_values[i].config(text=f\"{value:.3f}\")\n\n            # Update timestamp\n            current_time = time.strftime(\"%H:%M:%S\")\n            self.timestamp_var.set(f\"Timestamp: {current_time}\")\n\n            # Update TF status (log changes)\n            prev_tf = getattr(self, '_last_tf_logged', False)\n            self.update_tf_status()\n            if self.tf_available != prev_tf:\n                self.log_action(f\"TF Status Updated: {'Available' if self.tf_available else 'Unavailable'}\")\n                self._last_tf_logged = self.tf_available\n\n            # Start hand tracking display updates if not already started\n            if not hasattr(self, '_hand_tracking_started'):\n                self._hand_tracking_started = True\n                self.root.after(50, self.update_hand_tracking_display)\n\n            # Schedule next update\n            self.root.after(100, self.update_displays)  # Update every 100ms\n\n        except Exception as e:\n            self.logger.error(f\"Error updating displays: {str(e)}\")\n            # Still schedule next update even if there's an error\n            self.root.after(100, self.update_displays)\n\n            \n\n    def _wait_for_moveit_services(self):\n        \"\"\"Placeholder for waiting for MoveIt2 services.\"\"\"\n        self.logger.info(\"Simulated wait for MoveIt2 services (stub).\")\n\n          \n\n    def setup_gui(self):\n        \"\"\"Main window layout - simplified without multiple terminal logging\"\"\"\n        \n        def on_gui_configure(event):\n            \"\"\"Called when GUI window moves or resizes\"\"\"\n            if hasattr(self, 'positioned_rviz_window_id'):\n                self.root.after(50, self.position_rviz_window)\n\n        self.root.bind('<Configure>', on_gui_configure)\n\n        self.root.geometry(\"900x800\")\n        self.root.resizable(True, True)\n        self.root.title(\"Pegasus Arm Controller\")\n        self.root.protocol(\"WM_DELETE_WINDOW\", self.on_closing)\n\n        # --- MAIN WRAPPER FRAME ---\n        main_frame = ttk.Frame(self.root, padding=\"5\")\n        main_frame.pack(fill=tk.BOTH, expand=True)\n\n        # --- STATUS BAR (TOP) ---\n        status_frame = ttk.Frame(main_frame)\n        status_frame.pack(fill=tk.X, pady=2)\n\n        self.tf_status_var = tk.StringVar(value=\"TF Status: Checking...\")\n        status_style = \"Success.TLabel\" if self.tf_available else \"Alert.TLabel\"\n        self.tf_status_label = ttk.Label(status_frame, textvariable=self.tf_status_var, style=status_style)\n        self.tf_status_label.pack(fill=tk.X, pady=2)\n\n        # --- MAIN PANELS (LEFT / CENTER / RIGHT) ---\n        panels = ttk.Frame(main_frame)\n        panels.pack(fill=tk.BOTH, expand=True)\n\n        # LEFT PANEL (controls)\n        self.left_panel = ttk.Frame(panels)\n        self.left_panel.pack(side=tk.LEFT, fill=tk.Y, padx=(5,5), pady=5)\n\n        # CENTER PANEL (robot view)\n        self.center_panel = ttk.Frame(panels)\n        self.center_panel.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=5, pady=5)\n\n        # RIGHT PANEL (action log)\n        self.right_panel = ttk.Frame(panels)\n        self.right_panel.config(width=260)\n        self.right_panel.pack_propagate(False)\n        self.right_panel.pack(side=tk.RIGHT, fill=tk.Y, padx=5, pady=5)\n\n        # --- NOTEBOOK (left side) ---\n        self.notebook = ttk.Notebook(self.left_panel)\n        self.notebook.pack(fill=tk.BOTH, expand=True)\n\n        self.control_tab = ttk.Frame(self.notebook)\n        self.settings_tab = ttk.Frame(self.notebook)\n        self.camera_tab = ttk.Frame(self.notebook)\n\n        self.notebook.add(self.control_tab, text=\"Joint Control\")\n        self.notebook.add(self.settings_tab, text=\"Settings\")\n        self.notebook.add(self.camera_tab, text=\"Camera\")\n\n        self.control_frame = ttk.Frame(self.control_tab)\n        self.control_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)\n\n        # --- ROBOT VIEW (center) ---\n        self.robot_view_frame = ttk.LabelFrame(self.center_panel, text=\"Robot View\", padding=5)\n        self.robot_view_frame.pack(fill=tk.BOTH, expand=True)\n\n        rviz_placeholder = ttk.Label(self.robot_view_frame, text=\"Robot/3D View Placeholder\", anchor=\"center\")\n        rviz_placeholder.pack(fill=tk.BOTH, expand=True)\n        self.rviz_placeholder = rviz_placeholder\n\n        # RViz Controls\n        rviz_controls = ttk.Frame(self.center_panel)\n        rviz_controls.pack(fill=tk.X, pady=5)\n\n        ttk.Button(rviz_controls, text=\"Position RViz Now\", \n        command=self.manual_position_rviz).pack(side=tk.LEFT, padx=5)\n\n        ttk.Checkbutton(rviz_controls, text=\"Auto-reposition RViz\", variable=self.auto_position_rviz,\n                        command=self.auto_position_rviz_handler).pack(side=tk.LEFT, padx=5)\n\n        # --- ACTION LOG (RIGHT) - Clear on startup ---\n        log_frame = ttk.LabelFrame(self.right_panel, text=\"Action Log\", padding=5)\n        log_frame.pack(fill=tk.BOTH, expand=True)\n\n        self.log_text = tk.Text(log_frame, height=20, state=tk.DISABLED, wrap=tk.WORD)\n        self.log_text.pack(fill=tk.BOTH, expand=True)\n\n        scrollbar = ttk.Scrollbar(self.log_text, orient=\"vertical\", command=self.log_text.yview)\n        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)\n        self.log_text.configure(yscrollcommand=scrollbar.set)\n\n        # Clear log and add startup message\n        self.log_text.config(state=tk.NORMAL)\n        self.log_text.delete(1.0, tk.END)\n        self.log_text.config(state=tk.DISABLED)\n        self.log_action(\" Pegasus Arm Controller started\")\n        self.log_action(\" Initializing systems...\")\n\n        # --- SETTINGS & CAMERA TABS ---\n        self.setup_settings_tab(self.settings_tab)\n        self.setup_camera_tab(self.camera_tab)\n\n        # --- CONTROLS ---\n        self.setup_control_buttons()\n\n        # Start hand tracking updates\n        if hasattr(self, 'hand_display'):\n            self.root.after(50, self.update_hand_tracking_display)\n\n        # Start RViz positioning\n        self.root.after(1000, self.start_rviz_positioning)\n        \n        self.log_action(\" GUI initialization complete\")\n\n\n\n\n\n\n\n\n    def on_control_mode_changed(self, *args):\n        \"\"\"Rebuilds sliders and manages layout for both modes. Logs mode change.\"\"\"\n        mode = self.control_mode.get()\n        self.log_action(f\" Control mode switched to: {mode.upper()}\")\n\n        # Safe-create frames if missing (redundant now, but safe)\n        if not hasattr(self, 'joint_frame'):\n            self.joint_frame = ttk.LabelFrame(self.control_frame, text=\"Joint Positions (rad)\", padding=\"5\")\n        if not hasattr(self, 'cartesian_input_frame'):\n            self.cartesian_input_frame = ttk.LabelFrame(self.control_frame, text=\"Cartesian Pose\", padding=\"5\")\n\n        # Clear old widgets\n        for frame in [self.joint_frame, self.cartesian_input_frame]:\n            for widget in frame.winfo_children():\n                widget.destroy()\n        self.joint_labels = []\n        self.joint_values = []\n        self.joint_sliders = []\n        self.joint_vars = []\n        self.slider_active = [False] * len(self.get_joint_names() if hasattr(self, 'get_joint_names') else self.joint_names)  # Reset, safe fallback\n        self.xyz_vars = {}\n        self.rpy_vars = {}\n        self.cartesian_slider_active = {'X': False, 'Y': False, 'Z': False}\n        self.orientation_slider_active = {'Roll': False, 'Pitch': False, 'Yaw': False}\n\n        # Get current values (safe fallbacks)\n        joint_values = self.get_current_joint_values() if hasattr(self, 'get_current_joint_values') else [0.0] * len(self.joint_names)\n        current_pose = self.get_current_pose() if hasattr(self, 'get_current_pose') else [0.3, 0.0, 0.3, 0.0, 0.0, 0.0]\n        if current_pose is None:\n            current_pose = [0.3, 0.0, 0.3, 0.0, 0.0, 0.0]  # Explicit fallback for None\n\n        # JOINT MODE\n        if mode == \"joint\":\n            self.log_action(\" Displaying Joint Space sliders\")\n            self.setup_joint_sliders(joint_values)\n            self.preset_frame.pack(fill=tk.X, pady=(5,10))\n            self.joint_frame.pack(fill=tk.X)\n            self.cartesian_input_frame.pack_forget()\n            if hasattr(self, 'plan_button'):\n                self.plan_button.pack(fill=tk.X, pady=10)\n\n        # CARTESIAN MODE\n        else:\n            self.log_action(\" Displaying Cartesian Space sliders\")\n            self.setup_cartesian_sliders(current_pose)\n            self.preset_frame.pack(fill=tk.X, pady=(5,10))\n            self.joint_frame.pack_forget()\n            self.cartesian_input_frame.pack(fill=tk.BOTH, expand=True, pady=(5,10))\n            if hasattr(self, 'plan_button'):\n                self.plan_button.pack(fill=tk.X, pady=10)\n\n        # Update TF/controller status in log if changed\n        if self.tf_available != getattr(self, '_last_tf_status', False):\n            tf_msg = \"🟢\" if self.tf_available else \"🔴\"\n            self.log_action(f\"{tf_msg} TF Status: {'Available' if self.tf_available else 'Unavailable'}\")\n            self._last_tf_status = self.tf_available\n        if self.controller_available != getattr(self, '_last_controller_status', False):\n            ctrl_msg = \"🟢\" if self.controller_available else \"🔴\"\n            self.log_action(f\"{ctrl_msg} Controller Status: {'Active' if self.controller_available else 'Inactive'}\")\n            self._last_controller_status = self.controller_available\n\n        if hasattr(self, '_update_scroll_region'):\n            self.root.after(100, self._update_scroll_region)\n\n\n\n\n\n    def setup_cartesian_sliders(self, current_pose):\n        \"\"\"Setup Cartesian sliders (X/Y/Z + optional RPY). Initializes from current pose.\"\"\"\n        # Position frame (X/Y/Z)\n        pos_frame = ttk.LabelFrame(self.cartesian_input_frame, text=\"Position (m)\", padding=\"5\")\n        pos_frame.pack(fill=tk.X, pady=5)\n\n        self.xyz_vars = {}\n        self.xyz_values_display = {}\n        xyz_labels = ['X', 'Y', 'Z']\n        xyz_limits = {\n            'X': WORKSPACE_LIMITS['x'],\n            'Y': WORKSPACE_LIMITS['y'],\n            'Z': WORKSPACE_LIMITS['z']\n        }\n\n        for i, label in enumerate(xyz_labels):\n            row = ttk.Frame(pos_frame)\n            row.pack(fill=tk.X, pady=2)\n\n            ttk.Label(row, text=f\"{label}:\", width=8).pack(side=tk.LEFT)\n            value_label = ttk.Label(row, text=f\"{current_pose[i]:.3f}\", width=8)\n            value_label.pack(side=tk.LEFT, padx=5)\n            self.xyz_values_display[label] = value_label\n\n            var = tk.DoubleVar(value=current_pose[i])\n            self.xyz_vars[label] = var\n\n            min_lim, max_lim = xyz_limits[label]\n            slider = ttk.Scale(\n                row, from_=min_lim, to=max_lim, orient=tk.HORIZONTAL,\n                variable=var, command=lambda v, lbl=label: self.handle_cartesian_slider_continuous(lbl)\n            )\n            slider.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)\n\n            # Track active sliders (update handler for drag state)\n            slider.bind(\"<ButtonPress-1>\", lambda e, lbl=label: self.cartesian_slider_pressed(lbl))\n            slider.bind(\"<ButtonRelease-1>\", lambda e, lbl=label: self.cartesian_slider_released(lbl))\n\n        # Add orientation toggle checkbox (new: place in pos_frame for visibility)\n        orient_check_frame = ttk.Frame(pos_frame)\n        orient_check_frame.pack(fill=tk.X, pady=5)\n        ttk.Checkbutton(\n            orient_check_frame,\n            text=\"Use Orientation (RPY)\",\n            variable=self.use_orientation,\n            command=self.toggle_orientation_inputs\n        ).pack(side=tk.LEFT)\n\n        # Orientation frame (Roll/Pitch/Yaw) - conditional\n        self.orientation_frame = ttk.LabelFrame(self.cartesian_input_frame, text=\"Orientation (rad)\", padding=\"5\")\n        \n        # Safe fallback if use_orientation missing (shouldn't happen after init)\n        if not hasattr(self, 'use_orientation'):\n            self.use_orientation = tk.BooleanVar(value=True)\n        \n        if self.use_orientation.get():\n            self.orientation_frame.pack(fill=tk.X, pady=5)\n\n            self.rpy_vars = {}\n            self.rpy_values_display = {}\n            rpy_labels = ['Roll', 'Pitch', 'Yaw']\n            rpy_limits = {\n                'Roll': WORKSPACE_LIMITS['roll'],\n                'Pitch': WORKSPACE_LIMITS['pitch'],\n                'Yaw': WORKSPACE_LIMITS['yaw']\n            }\n\n            for i, label in enumerate(rpy_labels):\n                row = ttk.Frame(self.orientation_frame)\n                row.pack(fill=tk.X, pady=2)\n\n                ttk.Label(row, text=f\"{label}:\", width=8).pack(side=tk.LEFT)\n                value_label = ttk.Label(row, text=f\"{current_pose[3+i]:.3f}\", width=8)\n                value_label.pack(side=tk.LEFT, padx=5)\n                self.rpy_values_display[label] = value_label\n\n                var = tk.DoubleVar(value=current_pose[3+i])\n                self.rpy_vars[label] = var\n\n                min_lim, max_lim = rpy_limits[label]\n                slider = ttk.Scale(\n                    row, from_=min_lim, to=max_lim, orient=tk.HORIZONTAL,\n                    variable=var, command=lambda v, lbl=label: self.handle_orientation_slider_continuous(lbl)\n                )\n                slider.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)\n\n                slider.bind(\"<ButtonPress-1>\", lambda e, lbl=label: self.orientation_slider_pressed(lbl))\n                slider.bind(\"<ButtonRelease-1>\", lambda e, lbl=label: self.orientation_slider_released(lbl))\n        else:\n            self.rpy_vars = {}\n            self.rpy_values_display = {}\n\n        # Bind trace if not already (moved here for safety)\n        if not hasattr(self, '_orientation_bound'):\n            self.use_orientation.trace('w', self.toggle_orientation_inputs)\n            self._orientation_bound = True\n        \n        # Initial toggle call to set visibility\n        self.toggle_orientation_inputs()\n        \n        # Log setup complete\n        self.log_action(\" Cartesian sliders setup complete (RPY: Enabled)\")\n\n\n\n    def handle_cartesian_slider_continuous(self, label):\n        \"\"\"Update display during Cartesian slider drag (no planning).\"\"\"\n        if label in self.xyz_vars:\n            value = self.xyz_vars[label].get()\n            self.xyz_values_display[label].config(text=f\"{value:.3f}\")\n\n    def cartesian_slider_pressed(self, label):\n        \"\"\"Mark Cartesian slider as active (for hand tracking pause).\"\"\"\n        self.cartesian_slider_active[label] = True  # Assuming self.cartesian_slider_active = {} initialized in init\n\n    def cartesian_slider_released(self, label):\n        \"\"\"Mark Cartesian slider as inactive.\"\"\"\n        self.cartesian_slider_active[label] = False\n\n    def handle_orientation_slider_continuous(self, label):\n        \"\"\"Update display during orientation slider drag.\"\"\"\n        if label in self.rpy_vars:\n            value = self.rpy_vars[label].get()\n            self.rpy_values_display[label].config(text=f\"{value:.3f}\")\n\n    def orientation_slider_pressed(self, label):\n        \"\"\"Mark orientation slider as active.\"\"\"\n        self.orientation_slider_active[label] = True  # Assuming self.orientation_slider_active = {} in init\n\n    def orientation_slider_released(self, label):\n        \"\"\"Mark orientation slider as inactive.\"\"\"\n        self.orientation_slider_active[label] = False\n\n\n\n    def setup_joint_sliders(self, joint_values):\n        \"\"\"Setup joint sliders (extracted for modularity).\"\"\"\n        joint_names = self.get_joint_names()\n        joint_limits = self.get_joint_limits()\n        num_joints = len(joint_values)\n        display_names = [\"Base\", \"Shoulder\", \"Elbow\", \"Wrist\", \"Gripper\"]\n\n        for i in range(num_joints):\n            row = ttk.Frame(self.joint_frame)\n            row.pack(fill=tk.X, pady=2)\n\n            name = display_names[i] if i < len(display_names) else joint_names[i]\n            ttk.Label(row, text=f\"{name}:\", width=18).pack(side=tk.LEFT)\n\n            value_label = ttk.Label(row, text=f\"{joint_values[i]:.3f}\", width=8)\n            value_label.pack(side=tk.LEFT)\n            self.joint_values.append(value_label)\n\n            var = tk.DoubleVar(value=joint_values[i])\n            self.joint_vars.append(var)\n\n            min_lim, max_lim = joint_limits.get(joint_names[i], (-3.14, 3.14))\n            slider = ttk.Scale(\n                row, from_=min_lim, to=max_lim, orient=tk.HORIZONTAL,\n                variable=var, command=lambda v, idx=i: self.handle_slider_continuous(idx)\n            )\n            slider.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)\n\n            slider.bind(\"<ButtonPress-1>\", lambda e, idx=i: self.slider_pressed(idx))\n            slider.bind(\"<ButtonRelease-1>\", lambda e, idx=i: self.slider_released(idx))\n\n            self.joint_sliders.append(slider)\n\n\n    def toggle_orientation_inputs(self, *args):\n        \"\"\"Toggle visibility of orientation (RPY) sliders based on checkbox.\"\"\"\n        if not hasattr(self, 'orientation_frame'):\n            return  # Not in Cartesian mode yet\n        \n        if self.use_orientation.get():\n            self.orientation_frame.pack(fill=tk.X, pady=5)\n            self.log_action(\" Orientation sliders: Enabled\")\n        else:\n            self.orientation_frame.pack_forget()\n            self.log_action(\"Orientation sliders: Disabled\")\n        \n        # Re-pack Cartesian frame to adjust layout\n        if hasattr(self, 'cartesian_input_frame'):\n            self.cartesian_input_frame.pack_configure(fill=tk.BOTH, expand=True)\n\n\n\n    def get_joint_names(self):\n        \"\"\"Return the list of joint names.\"\"\"\n        return self.joint_names.copy()\n\n    def get_current_joint_values(self):\n        \"\"\"Return current joint values.\"\"\"\n        if hasattr(self, 'current_joint_positions') and self.current_joint_positions is not None:\n            return self.current_joint_positions.copy()\n        return self._current_values.copy()\n\n    def set_current_joint_values(self, values):\n        \"\"\"Update current joint values (thread-safe).\"\"\"\n        with self.goal_lock:\n            self._current_values = values.copy()\n            self.current_joint_positions = values.copy()\n\n    def get_joint_limits(self):\n        \"\"\"Return joint limits from commander.\"\"\"\n        if self.commander and hasattr(self.commander, 'get_joint_limits'):\n            return self.commander.get_joint_limits()\n        # Fallback limits matching PegasusCommander joint names\n        return {\n            'joint1': (-3.14, 3.14),\n            'joint2': (-0.61, 0.61),\n            'joint3': (-1.75, 1.75),\n            'joint4': (-1.31, 1.31),\n            'joint5': (-6.28, 6.28)\n        }\n        \n\n\n    def get_current_pose(self):\n        \"\"\"Get current end effector pose.\"\"\"\n        if self.commander:\n            return self.commander.get_current_pose()\n        return None\n\n    def move_to_joint_positions(self, joint_goal, velocity):\n        \"\"\"Delegate to commander's move method.\"\"\"\n        if self.commander:\n            return self.commander.move_to_joint_positions(joint_goal, velocity)\n        return False, MoveItErrorCodes.FAILURE\n\n    def move_to_pose(self, pose, velocity):\n        \"\"\"Wrapper for moving to a Cartesian pose.\"\"\"\n        if self.commander and hasattr(self.commander, 'move_to_pose'):\n            return self.commander.move_to_pose(pose, velocity)\n        elif self.commander and hasattr(self.commander, 'plan_to_cartesian_pose'):\n            # Fallback: use plan_to_cartesian_pose if available\n            x, y, z = pose[0:3]\n            roll, pitch, yaw = pose[3:6] if len(pose) >= 6 else (0.0, 0.0, 0.0)\n            result = self.commander.plan_to_cartesian_pose(x, y, z, roll, pitch, yaw)\n            return result.get('success', False), MoveItErrorCodes.SUCCESS if result.get('success') else MoveItErrorCodes.FAILURE\n        return False, MoveItErrorCodes.FAILURE\n\n    def move_to_named_target(self, target_name, velocity):\n        \"\"\"Move to a named target pose.\"\"\"\n        if target_name in self.named_poses:\n            joint_goal = self.named_poses[target_name]\n            return self.move_to_joint_positions(joint_goal, velocity)\n        return False, MoveItErrorCodes.INVALID_GOAL_CONSTRAINTS\n\n    def send_joints_to_arduino(self, joint_values):\n        \"\"\"Delegate to commander's Arduino method.\"\"\"\n        if self.commander:\n            return self.commander.send_joints_to_arduino(joint_values)\n        return False\n\n    def cancel_current_goals(self):\n        \"\"\"Cancel any active goals.\"\"\"\n        # Publish stop command to headless commander\n        if self.node:\n            msg = Empty()\n            self.stop_cmd_pub.publish(msg)\n            self.log_action(\"Stop command sent\")\n        else:\n            self.log_action(\"Cannot send stop command: Node not ready\")\n\n    def get_available_frames(self):\n        \"\"\"Get available TF frames.\"\"\"\n        if self.commander:\n            return self.commander.get_available_frames()\n        return []\n\n    def check_tf_availability(self, level_check=False):\n        \"\"\"Check TF availability.\"\"\"\n        if self.commander:\n            self.commander.check_tf_availability(level_check)\n            self.tf_available = self.commander.tf_available\n\n\n\n\n    def setup_control_buttons(self):\n        \"\"\"Control mode selector + presets + frames setup.\"\"\"\n        \n        # Control mode selector\n        mode_frame = ttk.LabelFrame(self.control_frame, text=\"Control Mode\", padding=5)\n        mode_frame.pack(fill=tk.X, pady=(0,5))\n\n        if not hasattr(self, 'control_mode'):\n            self.control_mode = tk.StringVar(value=\"joint\")\n            self.control_mode.trace('w', self.on_control_mode_changed)\n\n        ttk.Radiobutton(\n            mode_frame, text=\"Joint Space\",\n            variable=self.control_mode, value=\"joint\",\n            command=self.on_control_mode_changed\n        ).pack(side=tk.LEFT, padx=10)\n\n        ttk.Radiobutton(\n            mode_frame, text=\"Cartesian Space\",\n            variable=self.control_mode, value=\"cartesian\",\n            command=self.on_control_mode_changed\n        ).pack(side=tk.LEFT, padx=10)\n        \n        # ADD HAND CONTROL TOGGLE HERE\n        self.setup_hand_control_toggle()\n\n        # PRESETS (always top)\n        self.preset_frame = ttk.LabelFrame(self.control_frame, text=\"Presets\", padding=5)\n        self.preset_frame.pack(fill=tk.X, pady=(5,10))\n\n        ttk.Button(self.preset_frame, text=\"Home\", style=\"Rounded.TButton\",\n                command=self.plan_home).pack(side=tk.LEFT, padx=5, expand=True, fill=tk.X)\n\n        ttk.Button(self.preset_frame, text=\"Sync Home\", style=\"Rounded.TButton\",\n                command=self.sync_home_from_robot).pack(side=tk.LEFT, padx=5, expand=True, fill=tk.X)\n\n        ttk.Button(self.preset_frame, text=\"Extended\", style=\"Rounded.TButton\",\n                command=self.plan_extended).pack(side=tk.LEFT, padx=5, expand=True, fill=tk.X)\n\n        # Mode-specific frames (create here, but populate in mode change)\n        self.joint_frame = ttk.LabelFrame(self.control_frame, text=\"Joint Positions (rad)\", padding=\"5\")\n        self.cartesian_input_frame = ttk.LabelFrame(self.control_frame, text=\"Cartesian Pose\", padding=\"5\")\n\n        # PLAN BUTTON (create BEFORE initial mode call)\n        self.plan_button = ttk.Button(\n            self.control_frame, text=\"PLAN & EXECUTE\",\n            style=\"Success.TButton\", command=self.plan_current_mode\n        )\n\n        # Initial mode setup (AFTER all creation, to avoid AttributeErrors)\n        self.on_control_mode_changed()\n\n\n\n    def on_slider_change(self, idx):\n        \"\"\"Called when slider values change - removed arm display update\"\"\"\n        pass  # Schematic removed, no visualization to update\n\n    def _update_scroll_region(self):\n        \"\"\"Force update of scroll region after layout changes\"\"\"\n        if hasattr(self, 'main_canvas'):\n            self.main_canvas.configure(scrollregion=self.main_canvas.bbox(\"all\"))\n\n    def slider_pressed(self, idx):\n        \"\"\"Called when a joint slider is clicked\"\"\"\n        self.slider_active[idx] = True\n        self.slider_touched[idx] = True  # Mark as touched by user\n\n    def slider_released(self, idx):\n        \"\"\"Called when a joint slider is released\"\"\"\n        self.slider_active[idx] = False\n\n    def cartesian_slider_pressed(self, idx):\n        \"\"\"Called when a Cartesian slider is clicked\"\"\"\n        self.cartesian_slider_active[idx] = True\n\n    def cartesian_slider_released(self, idx):\n        \"\"\"Called when a Cartesian slider is released\"\"\"\n        self.cartesian_slider_active[idx] = False\n\n\n    def handle_cartesian_slider_continuous(self, idx):\n        \"\"\"Handle continuous Cartesian slider movement - UPDATE DISPLAY ONLY\"\"\"\n        if not hasattr(self, 'cartesian_slider_active') or not self.cartesian_slider_active[idx]:\n            return\n        \n        try:\n            # Get values\n            x = self.xyz_vars['X'].get()\n            y = self.xyz_vars['Y'].get()\n            z = self.xyz_vars['Z'].get()\n            \n            # Update display labels ONLY\n            xyz_labels = ['X', 'Y', 'Z']\n            self.xyz_values_display[xyz_labels[idx]].config(text=f\"{[x, y, z][idx]:.3f}\")\n            \n            # Get orientation if enabled\n            if self.use_orientation.get():\n                roll = self.rpy_vars['Roll'].get()\n                pitch = self.rpy_vars['Pitch'].get()\n                yaw = self.rpy_vars['Yaw'].get()\n                \n                # Update orientation displays too\n                if idx < 3:  # Only update if dragging XYZ sliders\n                    self.rpy_values_display['Roll'].config(text=f\"{roll:.3f}\")\n                    self.rpy_values_display['Pitch'].config(text=f\"{pitch:.3f}\")\n                    self.rpy_values_display['Yaw'].config(text=f\"{yaw:.3f}\")\n            \n            # NO IK computation or publishing during drag!\n            # User must press \"PLAN & EXECUTE\" button to apply changes\n            \n        except Exception as e:\n            self.logger.debug(f\"Error in cartesian slider update: {str(e)}\")\n\n    def orientation_slider_pressed(self, idx):\n        \"\"\"Called when an orientation slider is clicked\"\"\"\n        self.orientation_slider_active[idx] = True\n\n    def orientation_slider_released(self, idx):\n        \"\"\"Called when an orientation slider is released\"\"\"\n        self.orientation_slider_active[idx] = False\n\n\n\n    def handle_orientation_slider_continuous(self, idx):\n        \"\"\"Handle continuous orientation slider movement - UPDATE DISPLAY ONLY\"\"\"\n        if not hasattr(self, 'orientation_slider_active') or not self.orientation_slider_active[idx]:\n            return\n        \n        try:\n            # Get RPY values\n            roll = self.rpy_vars['Roll'].get()\n            pitch = self.rpy_vars['Pitch'].get()\n            yaw = self.rpy_vars['Yaw'].get()\n            \n            # Update display labels ONLY\n            rpy_labels = ['Roll', 'Pitch', 'Yaw']\n            current_vals = [roll, pitch, yaw]\n            self.rpy_values_display[rpy_labels[idx]].config(text=f\"{current_vals[idx]:.3f}\")\n            \n            # NO planning or IK during drag!\n            # User must press \"PLAN & EXECUTE\" button to apply changes\n            \n        except Exception as e:\n            self.logger.debug(f\"Error in orientation slider update: {str(e)}\")\n\n\n    def toggle_orientation_inputs(self):\n        \"\"\"Show/hide orientation input fields\"\"\"\n        if self.use_orientation.get():\n            self.orientation_frame.pack(fill=tk.X, pady=5)\n        else:\n            self.orientation_frame.pack_forget()\n\n\n    def read_current_cartesian_pose(self):\n        \"\"\"Read current end effector pose and populate input fields\"\"\"\n        try:\n            if not hasattr(self, 'current_pose_cache') or self.current_pose_cache is None:\n                self.log_action(\"Cannot read pose: No data received yet\")\n                return\n            \n            pose = self.current_pose_cache\n            # pose = [x, y, z, roll, pitch, yaw]\n            \n            self.xyz_vars['X'].set(round(pose[0], 4))\n            self.xyz_vars['Y'].set(round(pose[1], 4))\n            self.xyz_vars['Z'].set(round(pose[2], 4))\n            \n            # Update displays\n            self.xyz_values_display['X'].config(text=f\"{pose[0]:.3f}\")\n            self.xyz_values_display['Y'].config(text=f\"{pose[1]:.3f}\")\n            self.xyz_values_display['Z'].config(text=f\"{pose[2]:.3f}\")\n            \n            if self.use_orientation.get():\n                self.rpy_vars['Roll'].set(round(pose[3], 4))\n                self.rpy_vars['Pitch'].set(round(pose[4], 4))\n                self.rpy_vars['Yaw'].set(round(pose[5], 4))\n                \n                self.rpy_values_display['Roll'].config(text=f\"{pose[3]:.3f}\")\n                self.rpy_values_display['Pitch'].config(text=f\"{pose[4]:.3f}\")\n                self.rpy_values_display['Yaw'].config(text=f\"{pose[5]:.3f}\")\n            \n            self.log_action(f\"✓ Current pose: X={pose[0]:.3f}, Y={pose[1]:.3f}, Z={pose[2]:.3f}\")\n            \n        except Exception as e:\n            self.log_action(f\"✗ Error reading pose: {str(e)}\")\n            messagebox.showerror(\"Error\", f\"Failed to read current pose: {str(e)}\")\n\n\n    def plan_current_mode(self):\n        \"\"\"Plan in current mode and execute motion. Enhanced logging for success/failure.\"\"\"\n        if not self.node:\n            self.log_action(\"✗ ROS Node not available - planning aborted\")\n            messagebox.showerror(\"Error\", \"ROS Node not initialized.\")\n            return\n\n        #  ADD THIS CHECK - Prevent planning during execution\n        # Note: We rely on status feedback for this now, but for async commands we might just send it\n        # if hasattr(self.commander, 'is_executing') and self.commander.is_executing:\n        #     self.log_action(\"⚠ Execution in progress, please wait...\")\n        #     return\n\n        mode = self.control_mode.get()\n        # self.log_action(f\" Initiating {mode.upper()} planning...\")\n        print(f\"[DEBUG] plan_current_mode called. Mode: {mode}\")\n        self.log_action(f\" [DEBUG] Planning started for mode: {mode}\")\n\n        try:\n            if mode == \"joint\":\n                # Smart slider logic: Use feedback if slider not touched\n                target_joints = []\n                for i, var in enumerate(self.joint_vars):\n                    # If user hasn't touched this slider AND we have valid feedback\n                    if not self.slider_touched[i] and self.latest_feedback and i < len(self.latest_feedback.position):\n                        # Use actual robot position (prevents unwanted movement)\n                        actual_pos = self.latest_feedback.position[i]\n                        target_joints.append(actual_pos)\n                        # Auto-update slider to match reality\n                        var.set(actual_pos)\n                        if i < len(self.joint_values):\n                            self.joint_values[i].config(text=f\"{actual_pos:.3f}\")\n                    else:\n                        # Use slider value\n                        target_joints.append(var.get())\n                \n                self.log_action(f\" Joint targets: {[f'{v:.3f}' for v in target_joints]}\")\n                \n                if self.joint_cmd_pub:\n                    msg = JointState()\n                    msg.name = self.joint_names\n                    msg.position = target_joints\n                    self.joint_cmd_pub.publish(msg)\n                    self.log_action(\" Joint command published\")\n                else:\n                    self.log_action(\"✗ Joint command publisher not available\")\n\n            elif mode == \"cartesian\":\n                x = float(self.xyz_vars['X'].get())\n                y = float(self.xyz_vars['Y'].get())\n                z = float(self.xyz_vars['Z'].get())\n                self.log_action(f\" Cartesian position targets: X={x:.3f}, Y={y:.3f}, Z={z:.3f}\")\n\n                roll = pitch = yaw = 0.0\n                if self.use_orientation.get():\n                    roll = float(self.rpy_vars['Roll'].get())\n                    pitch = float(self.rpy_vars['Pitch'].get())\n                    yaw = float(self.rpy_vars['Yaw'].get())\n                    self.log_action(f\" Orientation targets: Roll={roll:.3f}, Pitch={pitch:.3f}, Yaw={yaw:.3f}\")\n\n                # Clamp to workspace (log if clamped)\n                x_c, y_c, z_c, r_c, p_c, y_c, was_clamped = clamp_to_workspace(x, y, z, roll, pitch, yaw)\n                if was_clamped:\n                    self.log_action(f\"⚠ Targets clamped: ({x:.3f},{y:.3f},{z:.3f}) → ({x_c:.3f},{y_c:.3f},{z_c:.3f})\")\n\n                    # Update GUI with clamped values\n                    self.xyz_vars['X'].set(round(x_c, 4))\n                    self.xyz_vars['Y'].set(round(y_c, 4))\n                    self.xyz_vars['Z'].set(round(z_c, 4))\n                    self.xyz_values_display['X'].config(text=f\"{x_c:.3f}\")\n                    self.xyz_values_display['Y'].config(text=f\"{y_c:.3f}\")\n                    self.xyz_values_display['Z'].config(text=f\"{z_c:.3f}\")\n\n                    if self.use_orientation.get():\n                        self.rpy_vars['Roll'].set(round(r_c or 0.0, 4))\n                        self.rpy_vars['Pitch'].set(round(p_c or 0.0, 4))\n                        self.rpy_vars['Yaw'].set(round(y_c or 0.0, 4))\n                        self.rpy_values_display['Roll'].config(text=f\"{r_c or 0.0:.3f}\")\n                        self.rpy_values_display['Pitch'].config(text=f\"{p_c or 0.0:.3f}\")\n                        self.rpy_values_display['Yaw'].config(text=f\"{y_c or 0.0:.3f}\")\n\n                # Plan (log result)\n                if self.pose_cmd_pub:\n                    msg = PoseStamped()\n                    msg.header.frame_id = self.base_frame\n                    msg.header.stamp = self.node.get_clock().now().to_msg()\n                    msg.pose.position.x = x_c\n                    msg.pose.position.y = y_c\n                    msg.pose.position.z = z_c\n                    \n                    # Convert RPY to Quaternion\n                    q = R.from_euler('xyz', [r_c or 0.0, p_c or 0.0, y_c or 0.0], degrees=False).as_quat()\n                    msg.pose.orientation.x = q[0]\n                    msg.pose.orientation.y = q[1]\n                    msg.pose.orientation.z = q[2]\n                    msg.pose.orientation.w = q[3]\n                    \n                    self.pose_cmd_pub.publish(msg)\n                    self.log_action(\" Cartesian command published\")\n                else:\n                    self.log_action(\"✗ Pose command publisher not available\")\n\n        except ValueError as e:\n            self.log_action(f\"✗ Invalid input values: {str(e)}\")\n            messagebox.showerror(\"Error\", f\"Invalid input values: {str(e)}\")\n        except Exception as e:\n            self.log_action(f\"✗ Planning exception: {str(e)}\")\n            import traceback\n            traceback.print_exc()\n            messagebox.showerror(\"Error\", f\"Planning failed: {str(e)}\")\n\n\n\n\n    def plan_joint_positions(self):\n        \"\"\"Plan to joint positions - REMOVED, use plan_home/plan_extended instead\"\"\"\n        self.log_action(\"This method is deprecated. Use preset buttons instead.\")\n        return False\n\n    def setup_pose_display(self):\n        self.pose_labels = {}\n        for coord in [\"X\", \"Y\", \"Z\", \"Roll\", \"Pitch\", \"Yaw\"]:\n            pose_row = ttk.Frame(self.pose_frame)\n            pose_row.pack(fill=tk.X, pady=5)\n\n            label = ttk.Label(pose_row, text=f\"{coord}:\", width=10, font=(\"Helvetica\", 10))\n            label.pack(side=tk.LEFT)\n\n            value = ttk.Label(pose_row, text=\"N/A\" if not self.tf_available else \"0.000\", width=10, font=(\"Helvetica\", 10))\n            value.pack(side=tk.LEFT)\n            self.pose_labels[coord] = value\n\n    def setup_cartesian_controls(self, parent_frame):\n        cartesian_controls = ttk.Frame(parent_frame)\n        cartesian_controls.pack(pady=10)\n        \n        linear_frame = ttk.LabelFrame(cartesian_controls, text=\"Linear Motion\", padding=\"5\")\n        linear_frame.pack(side=tk.LEFT, padx=10, fill=tk.Y)\n        \n        self.cart_buttons = {}\n        cartesian_dirs = [\n            (\"x_pos\", \"X+\", 0, 2), (\"x_neg\", \"X-\", 0, 0),\n            (\"y_pos\", \"Y+\", 1, 2), (\"y_neg\", \"Y-\", 1, 0),\n            (\"z_pos\", \"Z+\", 2, 2), (\"z_neg\", \"Z-\", 2, 0)\n        ]\n        \n        for dir_key, label, row, col in cartesian_dirs:\n            self.cart_buttons[dir_key] = ttk.Button(\n                linear_frame,\n                text=label,\n                width=5,\n                style=\"Rounded.TButton\",\n                command=partial(self.move_cartesian, dir_key)\n            )\n            self.cart_buttons[dir_key].grid(row=row, column=col, padx=5, pady=5)\n        \n        rotation_frame = ttk.LabelFrame(cartesian_controls, text=\"Rotation\", padding=\"5\")\n        rotation_frame.pack(side=tk.LEFT, padx=10, fill=tk.Y)\n        \n        rotation_dirs = [\n            (\"roll_pos\", \"Roll+\", 0, 2), (\"roll_neg\", \"Roll-\", 0, 0),\n            (\"pitch_pos\", \"Pitch+\", 1, 2), (\"pitch_neg\", \"Pitch-\", 1, 0),\n            (\"yaw_pos\", \"Yaw+\", 2, 2), (\"yaw_neg\", \"Yaw-\", 2, 0)\n        ]\n        \n        for dir_key, label, row, col in rotation_dirs:\n            self.cart_buttons[dir_key] = ttk.Button(\n                rotation_frame,\n                text=label,\n                width=7,\n                style=\"Rounded.TButton\",\n                command=partial(self.move_cartesian, dir_key)\n            )\n            self.cart_buttons[dir_key].grid(row=row, column=col, padx=5, pady=5)\n\n        step_frame = ttk.Frame(parent_frame)\n        step_frame.pack(pady=5)\n        \n        ttk.Label(step_frame, text=\"Cartesian Step (m/rad):\").pack(side=tk.LEFT, padx=5)\n        self.cart_step_size = tk.DoubleVar(value=0.01)\n        cart_step_sizes = [0.005, 0.01, 0.02, 0.05, 0.1]\n        cart_step_dropdown = ttk.Combobox(\n            step_frame,\n            textvariable=self.cart_step_size,\n            values=cart_step_sizes,\n            state=\"readonly\",\n            width=5,\n            font=(\"Helvetica\", 10)\n        )\n        cart_step_dropdown.pack(side=tk.LEFT, padx=5)\n\n    def setup_settings_tab(self, parent_frame):\n        settings_frame = ttk.Frame(parent_frame, padding=\"10\")\n        settings_frame.pack(fill=tk.BOTH, expand=True)\n        \n        ttk.Label(settings_frame, text=\"Controller Name:\").pack(anchor=\"w\", padx=5, pady=5)\n        self.controller_name_var = tk.StringVar(value=self.controller_name)\n        controller_entry = ttk.Entry(settings_frame, textvariable=self.controller_name_var, width=30)\n        controller_entry.pack(anchor=\"w\", padx=5)\n        \n        update_controller_button = ttk.Button(\n            settings_frame,\n            text=\"Update Controller\",\n            style=\"Rounded.TButton\",\n            command=self.update_controller_name\n        )\n        update_controller_button.pack(anchor=\"w\", padx=5, pady=5)\n        \n        # FIXED: Changed from self.load_joint_limits to self.reload_joint_limits\n        reload_limits_button = ttk.Button(\n            settings_frame,\n            text=\"Reload Joint Limits\",\n            style=\"Rounded.TButton\",\n            command=self.reload_joint_limits  # <-- CHANGED THIS LINE\n        )\n        reload_limits_button.pack(anchor=\"w\", padx=5, pady=5)\n\n        # Add MoveIt toggle checkbox\n        moveit_toggle = ttk.Checkbutton(\n            settings_frame,\n            text=\"Enable MoveIt (disable for direct Arduino control)\",\n            variable=self.moveit_enabled,\n            command=self.on_moveit_toggle\n        )\n        moveit_toggle.pack(anchor=\"w\", padx=5, pady=5)\n\n\n    def setup_camera_tab(self, parent_frame):\n        \"\"\"Setup the camera tab with live feed and controls\"\"\"\n        self.camera_frame = ttk.Frame(parent_frame, padding=\"10\")\n        self.camera_frame.pack(fill=tk.BOTH, expand=True)\n        \n        # Camera control frame\n        control_frame = ttk.Frame(self.camera_frame)\n        control_frame.pack(fill=tk.X, pady=5)\n        \n        # Start/Stop camera button\n        self.camera_active = False\n        self.start_camera_button = ttk.Button(\n            control_frame,\n            text=\"Start Live Feed\",\n            style=\"Success.TButton\",\n            command=self.toggle_camera_feed\n        )\n        self.start_camera_button.pack(side=tk.LEFT, padx=5)\n        \n        # Camera mode selection (REMOVED - RGB only)\n        # self.camera_mode = tk.StringVar(value=\"RGB\")\n        \n        # Camera display frame\n        display_frame = ttk.LabelFrame(self.camera_frame, text=\"Camera Feed\", padding=\"10\")\n        display_frame.pack(fill=tk.BOTH, expand=True, pady=10)\n        \n        # Camera display label\n        self.camera_display = ttk.Label(\n            display_frame, \n            text=\"Camera feed will appear here\\nClick 'Start Live Feed' to begin\",\n            anchor=\"center\",\n            font=(\"Helvetica\", 12)\n        )\n        self.camera_display.pack(expand=True, fill=tk.BOTH)\n        \n        # Initialize camera variables\n        self.camera = None\n        self.camera_thread = None\n        self.camera_running = False\n\n    def toggle_camera_feed(self):\n        \"\"\"Start or stop the camera feed\"\"\"\n        if not self.camera_active:\n            self.start_camera_feed()\n        else:\n            self.stop_camera_feed()\n\n    def start_camera_feed(self):\n        \"\"\"Start the camera feed by subscribing to ROS topic\"\"\"\n        try:\n            if not self.node:\n                self.log_action(\"Cannot start camera: ROS node not ready\")\n                return\n\n            # Subscribe to /cv_image topic\n            self.camera_sub = self.node.create_subscription(\n                RosImage,\n                '/cv_image',\n                self.image_callback,\n                10\n            )\n            \n            self.camera_active = True\n            self.start_camera_button.config(text=\"Stop Live Feed\", style=\"Danger.TButton\")\n            \n            self.log_action(\"Camera feed started (Topic: /cv_image)\")\n            \n        except Exception as e:\n            self.log_action(f\"Error starting camera: {str(e)}\")\n            messagebox.showerror(\"Error\", f\"Failed to start camera: {str(e)}\")\n\n    def stop_camera_feed(self):\n        \"\"\"Stop the camera feed by destroying subscription\"\"\"\n        try:\n            self.camera_active = False\n            \n            if hasattr(self, 'camera_sub') and self.camera_sub:\n                self.node.destroy_subscription(self.camera_sub)\n                self.camera_sub = None\n            \n            self.start_camera_button.config(text=\"Start Live Feed\", style=\"Success.TButton\")\n            self.camera_display.config(\n                image=\"\",\n                text=\"Camera feed stopped\\nClick 'Start Live Feed' to restart\"\n            )\n            \n            self.log_action(\"Camera feed stopped\")\n            \n        except Exception as e:\n            self.log_action(f\"Error stopping camera: {str(e)}\")\n\n    def image_callback(self, msg):\n        \"\"\"Process incoming ROS image\"\"\"\n        if not self.camera_active:\n            return\n            \n        try:\n            # Convert ROS Image to OpenCV\n            cv_image = self.bridge.imgmsg_to_cv2(msg, desired_encoding='bgr8')\n            \n            # Resize and convert to Tkinter format\n            # Resize frame to fit display\n            height, width = cv_image.shape[:2]\n            max_width, max_height = 640, 480\n            \n            if width > max_width or height > max_height:\n                scale = min(max_width/width, max_height/height)\n                new_width = int(width * scale)\n                new_height = int(height * scale)\n                cv_image = cv2.resize(cv_image, (new_width, new_height))\n            \n            # Convert to RGB for Tkinter\n            rgb_image = cv2.cvtColor(cv_image, cv2.COLOR_BGR2RGB)\n            pil_image = Image.fromarray(rgb_image)\n            tk_image = ImageTk.PhotoImage(image=pil_image)\n            \n            # Update label\n            self.camera_display.configure(image=tk_image)\n            self.camera_display.image = tk_image  # Keep reference\n            \n        except Exception as e:\n            # self.logger.error(f\"Image callback error: {e}\")\n            pass\n\n    # camera_loop REMOVED\n    # Obsolete camera methods REMOVED\n    # Remaining obsolete camera methods REMOVED\n\n\n\n    def setup_keyboard_shortcuts(self):\n        self.root.bind(\"<Up>\", lambda e: self.handle_key_press(\"up\"))\n        self.root.bind(\"<Down>\", lambda e: self.handle_key_press(\"down\"))\n        self.root.bind(\"<Left>\", lambda e: self.handle_key_press(\"left\"))\n        self.root.bind(\"<Right>\", lambda e: self.handle_key_press(\"right\"))\n        self.root.bind(\"<h>\", lambda e: self.go_to_home())\n        self.root.bind(\"<z>\", lambda e: self.go_to_zero())\n        self.root.bind(\"<Escape>\", lambda e: self.emergency_stop())\n        self.root.bind(\"<F5>\", lambda e: self.refresh_tf_status())\n\n\n\n\n    def log_action(self, message):\n        \"\"\"Enhanced log action with emoji filtering and deduplication\"\"\"\n        try:\n            timestamp = time.strftime('%H:%M:%S')\n            \n            # Log to console for debugging\n            print(f\"[{timestamp}] {message}\")\n            sys.stdout.flush()\n            \n            # Check for duplicate (prevent spam)\n            if hasattr(self, '_last_log_message') and self._last_log_message == message:\n                if hasattr(self, '_duplicate_count'):\n                    self._duplicate_count += 1\n                    if self._duplicate_count > 3:  # Only log first 3 duplicates\n                        return\n                else:\n                    self._duplicate_count = 1\n            else:\n                self._last_log_message = message\n                self._duplicate_count = 0\n            \n            # Log to GUI text widget\n            if hasattr(self, 'log_text') and self.log_text:\n                self.log_text.config(state=tk.NORMAL)\n                self.log_text.insert(tk.END, f\"[{timestamp}] {message}\\n\")\n                self.log_text.see(tk.END)\n                \n                # Limit log size (keep last 500 lines)\n                line_count = int(self.log_text.index('end-1c').split('.')[0])\n                if line_count > 500:\n                    self.log_text.delete('1.0', f'{line_count - 500}.0')\n                \n                self.log_text.config(state=tk.DISABLED)\n                \n        except Exception as e:\n            # Fallback to console if GUI logging fails\n            print(f\"[LOG ERROR] {message} (GUI log failed: {e})\")\n            sys.stdout.flush()\n\n\n\n\n\n\n    def show_temporary_error(self, message):\n        \"\"\"Show a temporary error message that disappears after 2 seconds\"\"\"\n        # Prevent multiple error dialogs from showing simultaneously\n        if self.error_dialog_active:\n            return\n        \n        self.error_dialog_active = True\n        \n        # Create a temporary error window\n        error_window = tk.Toplevel(self.root)\n        error_window.title(\"Error\")\n        error_window.geometry(\"400x150\")\n        error_window.resizable(False, False)\n        \n        # Center the error window on the main window\n        self.root.update_idletasks()\n        x = self.root.winfo_x() + (self.root.winfo_width() // 2) - 200\n        y = self.root.winfo_y() + (self.root.winfo_height() // 2) - 75\n        error_window.geometry(f\"400x150+{x}+{y}\")\n        \n        # Make window visible first, then grab focus\n        error_window.transient(self.root)\n        error_window.focus_set()\n        \n        # Delay grab_set until window is fully visible\n        def set_grab():\n            try:\n                if error_window.winfo_exists():\n                    error_window.grab_set()\n            except Exception:\n                pass  # Ignore grab errors\n        \n        error_window.after(50, set_grab)  # Delay grab by 50ms\n        \n        # Error message\n        error_frame = ttk.Frame(error_window, padding=\"20\")\n        error_frame.pack(fill=tk.BOTH, expand=True)\n        \n        error_label = ttk.Label(\n            error_frame, \n            text=message, \n            wraplength=350,\n            justify=\"center\",\n            font=(\"Helvetica\", 10),\n            foreground=\"red\"\n        )\n        error_label.pack(expand=True, fill=tk.BOTH)\n        \n        # Countdown label\n        countdown_var = tk.StringVar(value=\"Auto-closing in 2 seconds...\")\n        countdown_label = ttk.Label(\n            error_frame, \n            textvariable=countdown_var,\n            font=(\"Helvetica\", 9, \"italic\")\n        )\n        countdown_label.pack(pady=(10, 0))\n        \n        # Close button\n        close_button = ttk.Button(\n            error_frame,\n            text=\"Close\",\n            command=lambda: self.close_error_window(error_window),\n            style=\"Rounded.TButton\"\n        )\n        close_button.pack(pady=(10, 0))\n        \n        # Auto-close after 2 seconds with countdown\n        def countdown(seconds_left):\n            try:\n                if seconds_left > 0 and error_window.winfo_exists():\n                    countdown_var.set(f\"Auto-closing in {seconds_left} second{'s' if seconds_left != 1 else ''}...\")\n                    error_window.after(1000, lambda: countdown(seconds_left - 1))\n                elif error_window.winfo_exists():\n                    self.close_error_window(error_window)\n            except Exception:\n                pass  # Ignore any countdown errors\n        \n        # Start countdown\n        countdown(2)\n        \n        # Handle window close event\n        error_window.protocol(\"WM_DELETE_WINDOW\", lambda: self.close_error_window(error_window))\n\n\n    def close_error_window(self, window):\n        \"\"\"Close error window and reset flag\"\"\"\n        try:\n            if window and window.winfo_exists():\n                window.grab_release()  # Release grab first\n                window.destroy()\n        except Exception:\n            pass  # Ignore any closing errors\n        finally:\n            self.error_dialog_active = False\n\n    def status_check(self):\n        status = []\n        if self.action_server_available:\n            status.append(\"MoveIt OK\")\n        else:\n            status.append(\"MoveIt Disconnected\")\n        if self.controller_available:\n            status.append(\"Controller OK\")\n        else:\n            status.append(\"Controller Disconnected\")\n        if self.joint_states_available:\n            status.append(\"Joints OK\")\n        else:\n            status.append(\"Joints Disconnected\")\n        if self.tf_available:\n            status.append(\"TF OK\")\n        else:\n            status.append(\"TF Disconnected\")\n        self.status_var.set(\" | \".join(status))\n        self.root.after(1000, self.status_check)\n\n    def update_tf_status(self):\n        if self.tf_available:\n            self.tf_status_var.set(f\"TF Status: Connected (Base: {self.base_frame} → {self.end_effector_frame})\")\n            self.tf_status_label.configure(style=\"Success.TLabel\")\n        else:\n            self.tf_status_var.set(f\"TF Status: Disconnected (Base: {self.base_frame} → {self.end_effector_frame})\")\n            self.tf_status_label.configure(style=\"Alert.TLabel\")\n        self.root.after(5000, self.update_tf_status)\n\n    def refresh_tf_status(self):\n        new_base_frame = self.base_frame_var.get()\n        if new_base_frame != self.base_frame:\n            self.base_frame = new_base_frame\n            self.log_action(f\"Changed base frame to '{new_base_frame}'\")\n        \n        self.check_tf_availability(level_check=True)\n        self.update_tf_status()\n        \n        frames = self.get_available_frames()\n        if frames:\n            self.base_frame_dropdown['values'] = frames\n            self.log_action(f\"Available frames: {', '.join(frames)}\")\n        else:\n            self.log_action(\"No TF frames available. Check 'robot_state_publisher'.\")\n\n    def retry_controllers(self):\n        self.log_action(\"Attempting to activate controllers...\")\n        success = self.activate_controllers()\n        if success:\n            self.log_action(\"Controllers activated successfully\")\n            messagebox.showinfo(\"Success\", \"Controllers activated successfully\")\n        else:\n            self.log_action(\"Failed to activate controllers. Check controller_manager.\")\n            messagebox.showerror(\"Error\", \"Failed to activate controllers. Please check logs.\")\n\n    def update_controller_name(self):\n        new_controller = self.controller_name_var.get()\n        if new_controller != self.controller_name:\n            self.update_controller_name(new_controller)\n            self.log_action(f\"Updated controller name to '{new_controller}'\")\n            messagebox.showinfo(\"Success\", f\"Controller name updated to '{new_controller}'\")\n\n    def on_moveit_toggle(self):\n        enabled = self.moveit_enabled.get()\n        self.set_moveit_enabled(enabled)\n        state = \"enabled\" if enabled else \"disabled\"\n        self.log_action(f\"MoveIt {state}\")\n\n\n    def reload_joint_limits(self):\n        \"\"\"Reload joint limits from the commander\"\"\"\n        if self.commander:\n            self.commander.load_joint_limits()\n            self.log_action(\"Joint limits reloaded\")\n            messagebox.showinfo(\"Success\", \"Joint limits reloaded successfully\")\n        else:\n            self.log_action(\"Commander not available\")\n            messagebox.showerror(\"Error\", \"Commander not initialized\")\n\n\n\n    def get_selected_joint_index(self):\n        joint_name = self.selected_joint.get()\n        joint_names = self.get_joint_names()\n        return joint_names.index(joint_name) if joint_name in joint_names else -1\n\n\n    def emergency_stop_all_publishing(self):\n        \"\"\"Emergency stop - cancel all active publishing\"\"\"\n        try:\n            if self.commander:\n                # Stop trajectory execution\n                if hasattr(self.commander, 'is_executing'):\n                    self.commander.is_executing = False\n                \n                # Stop any timers\n                if hasattr(self.commander, 'execution_timer') and self.commander.execution_timer:\n                    self.commander.execution_timer.cancel()\n                \n                self.log_action(\" Emergency stop: All publishing halted\")\n            \n            # Clear movement flag\n            if hasattr(self, 'movement_in_progress'):\n                self.movement_in_progress.clear()\n                \n        except Exception as e:\n            self.log_action(f\"Error in emergency stop: {e}\")\n\n    # Bind to ESC key\n    def setup_keyboard_shortcuts(self):\n        self.root.bind(\"<Escape>\", lambda e: self.emergency_stop_all_publishing())\n        # ... other shortcuts ...\n\n\n    def check_joint_state_sources(self):\n        \"\"\"Diagnostic: Check what's publishing to /joint_states\"\"\"\n        try:\n            if not self.commander:\n                return\n            \n            # Get list of publishers on /joint_states topic\n            topic_info = self.commander.get_publishers_info_by_topic('/joint_states')\n            \n            self.log_action(f\"Publishers on /joint_states: {len(topic_info)}\")\n            for pub in topic_info:\n                self.log_action(f\"  - Node: {pub.node_name}, Namespace: {pub.node_namespace}\")\n        except Exception as e:\n            self.log_action(f\"Error checking publishers: {e}\")\n\n\n    def handle_slider_continuous(self, joint_index):\n        \"\"\"Handle continuous slider movement - UPDATE DISPLAY ONLY, NO PLANNING\"\"\"\n        if not hasattr(self, 'slider_active') or not self.slider_active[joint_index]:\n            return\n        \n        try:\n            joint_goal = [var.get() for var in self.joint_vars]\n            joint_name = self.get_joint_names()[joint_index]\n            joint_limits = self.get_joint_limits()\n            min_limit, max_limit = joint_limits.get(joint_name, (-3.14, 3.14))\n            joint_goal[joint_index] = np.clip(joint_goal[joint_index], min_limit, max_limit)\n            \n            # Update display label ONLY\n            if joint_index < len(self.joint_values):\n                self.joint_values[joint_index].config(text=f\"{joint_goal[joint_index]:.3f}\")\n            \n            # Store positions for later use\n            self.current_joint_positions = joint_goal.copy()\n            \n            #  REMOVE ANY PLANNING/PUBLISHING HERE - User must press button\n            \n        except Exception as e:\n            self.logger.error(f\"Error in slider continuous update: {str(e)}\")\n\n\n\n    def handle_slider(self, joint_index):\n        \"\"\"Handle slider movement from button presses or other discrete actions\"\"\"\n        if self.movement_in_progress.is_set():\n            return\n        with self.lock:\n            if self.movement_in_progress.is_set():\n                return\n            self.movement_in_progress.set()\n        try:\n            joint_goal = [var.get() for var in self.joint_vars]\n            joint_name = self.get_joint_names()[joint_index]\n            joint_limits = self.get_joint_limits()\n            min_limit, max_limit = joint_limits.get(joint_name, (-3.14, 3.14))\n            joint_goal[joint_index] = np.clip(joint_goal[joint_index], min_limit, max_limit)\n            self.current_joint_positions = joint_goal.copy()\n            self.current_joint_time = time.time()\n            self.joint_vars[joint_index].set(joint_goal[joint_index])\n            if self.moveit_enabled.get():\n                velocity = self.velocity_scale.get()\n                success, error_code = self.move_to_joint_positions(joint_goal, velocity)\n                if success:\n                    try:\n                        self.set_current_joint_values(joint_goal)\n                    except Exception:\n                        pass\n            else:\n                success = self.send_joints_to_arduino(joint_goal)\n                if success:\n                    try:\n                        self.set_current_joint_values(joint_goal)\n                    except Exception:\n                        pass\n        except Exception as e:\n            print(f\"Error during slider movement: {str(e)}\")\n        finally:\n            self.movement_in_progress.clear()\n\n    def plan_named_pose(self, pose_name):\n        \"\"\"Set sliders to a named pose and invoke the planner.\"\"\"\n        if not hasattr(self, 'named_poses') or pose_name not in self.named_poses:\n            self.log_action(f\"Named pose '{pose_name}' not found\")\n            return False\n        pose = self.named_poses[pose_name]\n        # Update sliders without triggering continuous sends\n        for i, val in enumerate(pose):\n            if i < len(self.joint_vars):\n                self.joint_vars[i].set(val)\n        # Give UI a moment to update\n        self.root.update_idletasks()\n        # Call existing plan flow\n        return self.plan_joint_positions()\n\n\n    def plan_home(self):\n        \"\"\"Move to home position\"\"\"\n        if not self.commander:\n            self.log_action(\" Commander not available\")\n            messagebox.showerror(\"Error\", \"Commander not initialized. Please wait.\")\n            return\n        \n        self.log_action(\" Planning to Home pose\")\n        try:\n            home_joints = self.named_poses['home']\n            \n            # Update sliders to show target\n            for i, val in enumerate(home_joints):\n                if i < len(self.joint_vars):\n                    self.joint_vars[i].set(val)\n            \n            self.root.update_idletasks()  # Update GUI\n            \n            # Plan using commander\n            result = self.commander.plan_to_joint_values(home_joints)\n            \n            if result.get('success'):\n                # Execute trajectory\n                self.commander.execute_live_trajectory(result)\n                self.log_action(\"Moving to Home position\")\n            else:\n                error_msg = result.get('message', 'Unknown error')\n                self.log_action(f\" Planning failed: {error_msg}\")\n                messagebox.showerror(\"Planning Error\", f\"Failed to plan: {error_msg}\")\n                \n        except Exception as e:\n            self.log_action(f\" Error moving to home: {str(e)}\")\n            import traceback\n            traceback.print_exc()\n            messagebox.showerror(\"Error\", f\"Failed to move to home: {str(e)}\")\n\n    def plan_extended(self):\n        \"\"\"Move to extended position\"\"\"\n        if not self.commander:\n            self.log_action(\" Commander not available\")\n            messagebox.showerror(\"Error\", \"Commander not initialized. Please wait.\")\n            return\n        \n        self.log_action(\" Planning to Extended pose\")\n        try:\n            # Get extended position and clamp to limits\n            extended_joints = self.named_poses['extended'].copy()\n            limits = self.get_joint_limits()\n            \n            # Clamp each joint to its limits\n            for i, (val, name) in enumerate(zip(extended_joints, self.joint_names)):\n                min_lim, max_lim = limits.get(name, (-3.14, 3.14))\n                extended_joints[i] = float(np.clip(val, min_lim, max_lim))\n            \n            # Update sliders to show target\n            for i, val in enumerate(extended_joints):\n                if i < len(self.joint_vars):\n                    self.joint_vars[i].set(val)\n            \n            self.root.update_idletasks()  # Update GUI\n            \n            # Plan using commander\n            result = self.commander.plan_to_joint_values(extended_joints)\n            \n            if result.get('success'):\n                # Execute trajectory\n                self.commander.execute_live_trajectory(result)\n                self.log_action(\" Moving to Extended position\")\n            else:\n                error_msg = result.get('message', 'Unknown error')\n                self.log_action(f\" Planning failed: {error_msg}\")\n                messagebox.showerror(\"Planning Error\", f\"Failed to plan: {error_msg}\")\n                \n        except Exception as e:\n            self.log_action(f\" Error moving to extended: {str(e)}\")\n            import traceback\n            traceback.print_exc()\n            messagebox.showerror(\"Error\", f\"Failed to move to extended: {str(e)}\")\n\n\n\n\n\n\n    def move_direction(self, direction):\n        current_time = time.time()\n        if current_time - self.last_command_time < self.command_cooldown:\n            print(\"Command too soon, please wait...\")\n            return\n        if self.movement_in_progress.is_set():\n            print(\"Movement in progress, please wait...\")\n            return\n                \n        with self.lock:\n            if self.movement_in_progress.is_set():\n                return\n            self.movement_in_progress.set()\n            \n        self.last_command_time = current_time\n        try:\n            joint_index = self.get_selected_joint_index()\n            step = self.step_size.get()\n            joint_goal = self.get_current_joint_values()\n            joint_limits = self.get_joint_limits()\n            joint_name = self.get_joint_names()[joint_index]\n            if joint_index < 0 or joint_index >= len(joint_goal):\n                print(f\"Invalid joint index: {joint_index}\")\n                return\n            if direction in [\"up\", \"right\"]:\n                joint_goal[joint_index] += step\n            elif direction in [\"down\", \"left\"]:\n                joint_goal[joint_index] -= step\n            min_limit, max_limit = joint_limits.get(joint_name, (-3.14, 3.14))\n            joint_goal[joint_index] = np.clip(joint_goal[joint_index], min_limit, max_limit)\n            \n            # Store joint positions in a placeholder for later use\n            self.current_joint_positions = joint_goal.copy();\n            \n            if self.moveit_enabled.get():\n                velocity = self.velocity_scale.get()\n                success, error_code = self.move_to_joint_positions(joint_goal, velocity)\n                if success and not self.slider_active[joint_index]:\n                    self.joint_vars[joint_index].set(joint_goal[joint_index])\n                if success:\n                    try:\n                        self.set_current_joint_values(joint_goal)\n                    except Exception:\n                        pass\n            else:\n                success = self.send_joints_to_arduino(joint_goal)\n                if success and not self.slider_active[joint_index]:\n                    self.joint_vars[joint_index].set(joint_goal[joint_index])\n                if success:\n                    try:\n                        self.set_current_joint_values(joint_goal)\n                    except Exception:\n                        pass\n        except Exception as e:\n            print(f\"Error during movement: {str(e)}\")\n        finally:\n            self.movement_in_progress.clear()\n\n\n\n    def go_to_home(self):\n        if self.movement_in_progress.is_set():\n            print(\"Movement in progress, please wait...\")\n            return\n\n        self.movement_in_progress.set()\n        self.last_command_time = time.time()\n\n        try:\n            success, error_code = self.move_to_named_target(\"home\", self.velocity_scale.get())\n            if success:\n                joint_values = self.get_current_joint_values()\n                # Store joint positions in a placeholder for later use\n                self.current_joint_positions = joint_values.copy()\n                # Update sliders only if not being manipulated\n                for i, (var, value) in enumerate(zip(self.joint_vars, joint_values)):\n                    if not self.slider_active[i]:\n                        var.set(value)\n        except Exception as e:\n            print(f\"Error moving to home: {str(e)}\")\n        finally:\n            self.movement_in_progress.clear()\n\n    def go_to_zero(self):\n        if self.movement_in_progress.is_set():\n            print(\"Movement in progress, please wait...\")\n            return\n\n        self.movement_in_progress.set()\n        self.last_command_time = time.time()\n\n        try:\n            zero_position = [0.0] * len(self.get_joint_names())\n            velocity = self.velocity_scale.get()\n            success, error_code = self.move_to_joint_positions(zero_position, velocity)\n            if success:\n                # Store joint positions in a placeholder for later use\n                self.current_joint_positions = zero_position.copy()\n                try:\n                    self.set_current_joint_values(zero_position)\n                except Exception:\n                    pass\n                # Update sliders only if not being manipulated\n                for i, (var, value) in enumerate(zip(self.joint_vars, zero_position)):\n                    if not self.slider_active[i]:\n                        var.set(value)\n        except Exception as e:\n            print(f\"Error moving to zero: {str(e)}\")\n        finally:\n            self.movement_in_progress.clear()\n\n\n    def move_cartesian(self, direction):\n        if self.movement_in_progress.is_set():\n            self.log_action(\"Movement in progress, please wait...\")\n            return\n\n        self.movement_in_progress.set()\n        self.last_command_time = time.time()\n\n        try:\n            step = self.cart_step_size.get()\n            direction_map = {\n                \"x_pos\": [step, 0, 0], \"x_neg\": [-step, 0, 0],\n                \"y_pos\": [0, step, 0], \"y_neg\": [0, -step, 0],\n                \"z_pos\": [0, 0, step], \"z_neg\": [0, 0, -step],\n                \"roll_pos\": [step, 0, 0], \"roll_neg\": [-step, 0, 0],\n                \"pitch_pos\": [0, step, 0], \"pitch_neg\": [0, -step, 0],\n                \"yaw_pos\": [0, 0, step], \"yaw_neg\": [0, 0, -step]\n            }\n            is_rotation = direction.startswith((\"roll\", \"pitch\", \"yaw\"))\n            delta = direction_map.get(direction, [0, 0, 0])\n\n            self.log_action(f\"Moving end effector {'rotation' if is_rotation else 'position'} ({direction})...\")\n            success, error_code = self.move_cartesian(delta, is_rotation, self.velocity_scale.get())\n            if success:\n                self.log_action(f\"Cartesian movement ({direction}) completed\")\n            else:\n                error_msg = MOVEIT_ERROR_CODES.get(error_code, \"Unknown error\")\n                self.log_action(f\"Cartesian movement failed: {error_msg}\")\n                self.show_temporary_error(f\"Cartesian movement failed: {error_msg}\")\n        except Exception as e:\n            self.log_action(f\"Error during Cartesian movement: {str(e)}\")\n            self.show_temporary_error(f\"Cartesian movement error: {str(e)}\")\n        finally:\n            self.movement_in_progress.clear()\n\n\n    def handle_button_press(self, direction):\n        button = self.buttons.get(direction)\n        if button:\n            button.state(['pressed'])\n            self.root.update_idletasks()\n        self.move_direction(direction)\n        self.root.after(100, lambda: button.state(['!pressed']) if button else None)\n\n    def handle_key_press(self, direction):\n        button = self.buttons.get(direction)\n        if button:\n            button.state(['pressed'])\n            self.root.update_idletasks()\n        self.move_direction(direction)\n        self.root.after(100, lambda: button.state(['!pressed']) if button else None)\n\n\n\n    def emergency_stop(self):\n        self.log_action(\"EMERGENCY STOP ACTIVATED\")\n        self.cancel_current_goals()\n        self.movement_in_progress.clear()\n        self.root.after(1000, lambda: self.log_action(\"Emergency stop completed\"))\n        messagebox.showinfo(\"Info\", \"Emergency stop completed\")\n\n    def get_joint_limits(self):\n        \"\"\"Return a copy of the joint limits dictionary.\"\"\"\n        return self.joint_limits.copy()\n\ndef ros_spin_thread(ros_node):\n    \"\"\"Run ROS spin in a background thread\"\"\"\n    try:\n        rclpy.spin(ros_node)\n    except Exception as e:\n        try:\n            ros_node.get_logger().error(f\"ROS spin error: {e}\")\n        except Exception:\n            print(f\"ROS spin error: {e}\")\n\n\n\ndef main(args=None):\n    import sys\n    print(\"=\" * 60)\n    print(\"Starting GUI_commander...\")\n    print(\"=\" * 60)\n    sys.stdout.flush()\n    \n    logging.basicConfig(level=logging.INFO)\n\n    gui_node = None\n    \n    try:\n        print(\"[MAIN] Step 1: Initializing ROS...\")\n        sys.stdout.flush()\n        rclpy.init(args=args)\n        print(\"[MAIN] ✓ ROS initialized\")\n        sys.stdout.flush()\n        \n        # Create a simple node for the GUI\n        gui_node = Node('gui_commander_client')\n        \n        # Start spinning the node in a background thread\n        def ros_spin_thread(node):\n            try:\n                rclpy.spin(node)\n            except Exception as e:\n                print(f\"ROS spin error: {e}\")\n\n        spin_thread = threading.Thread(target=ros_spin_thread, args=(gui_node,), daemon=True)\n        spin_thread.start()\n        print(\"[MAIN] ✓ ROS spin thread started\")\n        \n    except Exception as e:\n        print(f\"[MAIN] ✗ rclpy.init() failed: {e}\")\n        import traceback\n        traceback.print_exc()\n        return\n\n    try:\n        print(\"[MAIN] Step 2: Creating Tkinter root window...\")\n        sys.stdout.flush()\n        root = tk.Tk()\n        root.withdraw()  # Hide initially to show before fully loaded\n        print(\"[MAIN] ✓ Tkinter root created\")\n        sys.stdout.flush()\n        \n        print(\"[MAIN] Step 3: Initializing PegasusArmGUI (Client Mode)...\")\n        sys.stdout.flush()\n        # Pass the node to the GUI\n        gui = PegasusArmGUI(root, node=gui_node)\n        print(\"[MAIN] ✓ PegasusArmGUI initialized\")\n        sys.stdout.flush()\n        \n        # Show window after GUI is initialized\n        print(\"[MAIN] Step 4: Showing window...\")\n        sys.stdout.flush()\n        root.deiconify()  # Show the window\n        print(\"[MAIN] ✓ Window visible\")\n        sys.stdout.flush()\n        \n        print(\"[MAIN] Step 5: Launching Tkinter mainloop...\")\n        sys.stdout.flush()\n        root.mainloop()\n        print(\"[MAIN] ✓ Mainloop exited\")\n        sys.stdout.flush()\n        \n    except Exception as e:\n        print(f\"[MAIN] ✗ GUI error: {e}\")\n        import traceback\n        traceback.print_exc()\n        sys.stdout.flush()\n    finally:\n        print(\"[MAIN] Cleanup: Destroying node...\")\n        sys.stdout.flush()\n        try:\n            if gui_node:\n                gui_node.destroy_node()\n                print(\"[MAIN] ✓ GUI node destroyed\")\n        except Exception as e:\n            print(f\"[MAIN] Error destroying node: {e}\")\n        \n        print(\"[MAIN] Cleanup: Shutting down ROS...\")\n        sys.stdout.flush()\n        try:\n            rclpy.shutdown()\n            print(\"[MAIN] ✓ ROS shutdown complete\")\n        except Exception as e:\n            print(f\"[MAIN] Error shutting down rclpy: {e}\")\n        \n        print(\"[MAIN] Application exit\")\n        sys.stdout.flush()\n\n\nif __name__ == '__main__':\n    main()\n"}\n{"instruction": "Write a ROS2 Python node named main.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "import asyncio\nimport os\nfrom datetime import datetime\nfrom threading import Thread\n\nimport cv2\nimport numpy as np\nimport PIL\nimport PIL.Image\nimport rclpy\nimport rclpy.client\nfrom cv_bridge import CvBridge\nfrom geometry_msgs.msg import Point, Pose, PoseArray, PoseStamped, Quaternion\nfrom moveit_msgs.msg import CollisionObject, PlanningScene, PlanningSceneComponents\nfrom moveit_msgs.srv import GetPlanningScene\nfrom rcl_interfaces.msg import Parameter, ParameterDescriptor, ParameterType\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import CameraInfo, Image, JointState, PointCloud2\nfrom shape_msgs.msg import SolidPrimitive\nfrom std_msgs.msg import Header, String\nfrom std_srvs.srv import Trigger\nfrom tf2_ros import Buffer, TransformException, TransformListener\n\nfrom custom_srv_pkg.msg import GraspPose, GraspPoses\nfrom custom_srv_pkg.srv import (\n    AimGripPlan,\n    BestGraspPose,\n    CameraIKJointState,\n    GraspPoseSend,\n    Gripper,\n    IKJointState,\n    IKPassCount,\n    IMGSend,\n    JointPose,\n    JointStateCollision,\n    JointStateCollisionBool,\n    PCLFuse,\n    PCLMani,\n    PointCloudSend,\n    PointCloudSendWithMask,\n    TargetObjectSend,\n)\n\nfrom .utils import fake_utils, image_utils, utils\nfrom .utils.my_custom_socket import MyClient\n\n\nclass MainNode(Node):\n    def __init__(self):\n\n        self.loop = asyncio.new_event_loop()\n        thread = Thread(target=self.loop.run_forever)\n        thread.daemon = True\n        thread.start()\n\n        super().__init__(\"main\")\n        self.tf_buffer = Buffer()\n        self.tf_listener = TransformListener(self.tf_buffer, self)\n        self.bridge = CvBridge()\n\n        self.command_map = {\n            \"capture\": self.command_capture,\n            \"capture_to_fuse\": self.command_capture_to_fuse,\n            \"req_ism\": self.command_srv_req_ism,\n            \"req_pem\": self.command_srv_req_pem,\n            \"generate_all_grasp\": self.command_srv_all_grasp,\n            \"generate_best_grasp\": self.command_srv_best_grasp,\n            \"make_collision\": self.command_srv_make_collision,\n            \"make_collision_with_mask\": self.command_srv_make_collision_with_mask,\n            \"ik_grasp\": self.command_ik_grasp,\n            \"plan_aim_grip\": self.command_plan_aim_grip,\n            \"trigger_aim\": self.command_trigger_aim,\n            \"trigger_grip\": self.command_trigger_grip,\n            \"plan_home\": self.command_plan_home,\n            \"trigger_home\": self.command_trigger_home,\n            \"attach_object\": self.command_attach_object,\n            \"detach_object\": self.command_detach_object,\n            \"gripper_open\": self.command_gripper_open,\n            \"gripper_close\": self.command_gripper_close,\n            \"fake_point_cloud\": self.command_fake_point_cloud,\n            \"fake_object_pose\": self.command_fake_object_pose,\n            \"fuse_pointcloud\": self.command_fuse_pointcloud,\n            \"clear_pointcloud\": self.command_clear_pointcloud,\n            \"auto_fuse_pointcloud\": self.command_auto_fuse_pointcloud,\n            \"fake_joint_state_pub\": self.fake_joint_state_pub,\n            \"grip_and_attach\": self.command_grip_and_attach,\n            \"republish_stl\": self.call_make_stl_collision,\n            \"clear_planning_scene\": self.command_clear_planning_scene,\n\n        }\n\n        \"\"\"\n        ################### VARIABLE ###########################\n        \"\"\"\n        # File name\n        self.node_run_folder_name = (\n            f\"Run-{datetime.now().strftime('%Y-%m-%d-%H-%M-%S-%f')[:-4]}\"\n        )\n        self.capture_folder_name = f\"Cap-{self.get_current_time()}\"\n        self.req_ism_time = self.get_current_time\n\n        # Camera info\n        self.camera_info = CameraInfo()\n        self.capture_camera_info = False\n\n        # Point Cloud\n        self.data_pointcloud = PointCloud2()\n        self.data_pointcloud_xyz = np.array([])\n        self.capture_pointcloud = False\n\n        self.capture_to_fuse = False\n        self.data_pointcloud_fused = PointCloud2()\n\n        # RGB\n        self.data_msg_rgb = Image()\n        self.data_array_rgb = np.array([])\n        self.capture_rgb = False\n\n        # Depth\n        self.data_msg_depth = Image()\n        self.data_array_depth = np.array([])\n        self.capture_depth = False\n\n        # Fuse Depth\n        self.data_array_depth_fused = np.array([])\n        self.data_msg_depth_fused = Image()\n\n        # ISM Result\n        self.data_best_mask = np.array([])\n        self.data_msg_best_mask = Image()\n\n        # PEM Result\n        self.data_pem_result = np.array([])\n        self.data_msg_pem_result = Image()\n        self.data_object_pose_wrt_cam = PoseStamped()\n        self.data_object_pose = PoseStamped()\n\n        # Pose\n        self.data_all_grasp_pose = GraspPoses()\n        self.data_sorted_grasp_aim_pose = PoseArray()\n        self.data_sorted_grasp_grip_pose = PoseArray()\n        self.data_sorted_grasp_gripper_distance = []\n\n        # Filter IK\n        self.data_aim_joint_state = []\n        self.data_sorted_grasp_aim_pose_filter = PoseArray()\n        self.data_sorted_grasp_grip_pose_filter = PoseArray()\n        self.data_sorted_grasp_gripper_distance_filter = []\n        self.data_aim_joint_state_filter = []\n\n        self.passed_index = None\n        self.capture_index = None\n        self.fake_joint_state_index = 0\n\n        # Planning Scene\n        self.data_planning_scene = PlanningScene()\n\n        \"\"\"\n        ################### PARAM ###########################\n        \"\"\"\n        param_descriptor_target_object = ParameterDescriptor(\n            name=\"target_obj\",\n            type=ParameterType.PARAMETER_STRING,\n            description=\"Target Object\",\n        )\n        self.declare_parameter(\n            \"target_obj\", \"sunscreen\", descriptor=param_descriptor_target_object\n        )\n\n        param_descriptor_dataset_path_prefix = ParameterDescriptor(\n            name=\"dataset_path_prefix\",\n            type=ParameterType.PARAMETER_STRING,\n            description=\"Path to dataset folder containing CAD file of object and templates.\",\n        )\n\n        self.declare_parameter(\n            \"dataset_path_prefix\",\n            \"/home/icetenny/senior-2/senior_dataset/\",\n            descriptor=param_descriptor_dataset_path_prefix,\n        )\n\n        param_descriptor_output_path_prefix = ParameterDescriptor(\n            name=\"output_path_prefix\",\n            type=ParameterType.PARAMETER_STRING,\n            description=\"Path to folder for output files.\",\n        )\n\n        self.declare_parameter(\n            \"output_path_prefix\",\n            \"/home/icetenny/senior-2/results/\",\n            descriptor=param_descriptor_output_path_prefix,\n        )\n\n        \"\"\"\n        ################### SUBSCRIBER ###########################\n        \"\"\"\n        self.sub_command = self.create_subscription(\n            String, \"/main/main_command\", self.command_callback, 10\n        )\n        self.sub_zed_pointcloud = self.create_subscription(\n            PointCloud2,\n            \"/zed/zed_node/point_cloud/cloud_registered\",\n            self.zed_pointcloud_callback,\n            10,\n        )\n\n        self.sub_zed_rgb = self.create_subscription(\n            Image,\n            \"/zed/zed_node/left/image_rect_color\",\n            self.zed_rgb_callback,\n            10,\n        )\n\n        self.sub_zed_depth = self.create_subscription(\n            Image,\n            \"/zed/zed_node/depth/depth_registered\",\n            self.zed_depth_callback,\n            10,\n        )\n\n        self.sub_zed_cam_K = self.create_subscription(\n            CameraInfo,\n            \"/zed/zed_node/left/camera_info\",\n            self.zed_camera_info_callback,\n            10,\n        )\n\n        \"\"\"\n        ################### PUBLISHER ###########################\n        \"\"\"\n        self.pub_rviz_text = self.create_publisher(String, \"/main/rviz_text\", 10)\n\n        self.pub_captured_pointcloud = self.create_publisher(\n            PointCloud2, \"/main/captured_pointcloud\", 10\n        )\n\n        self.pub_captured_rgb = self.create_publisher(Image, \"/main/captured_rgb\", 10)\n\n        self.pub_captured_depth = self.create_publisher(\n            Image, \"/main/captured_depth\", 10\n        )\n\n        self.pub_best_mask = self.create_publisher(Image, \"/main/best_mask\", 10)\n\n        self.pub_pem_result = self.create_publisher(Image, \"/main/pem_result\", 10)\n\n        self.pub_object_pose = self.create_publisher(\n            PoseStamped, \"/main/object_pose\", 10\n        )\n\n        self.pub_best_grasp_aim_poses = self.create_publisher(\n            PoseArray, \"/main/best_grasp_aim_poses\", 10\n        )\n\n        self.pub_best_grasp_grip_poses = self.create_publisher(\n            PoseArray, \"/main/best_grasp_grip_poses\", 10\n        )\n\n        # self.pub_collision = self.create_publisher(\n        #     CollisionObject, \"collision_object_topic\", 10\n        # )\n\n        self.pub_pointcloud_no_object = self.create_publisher(\n            PointCloud2, \"/main/pointcloud_no_object\", 10\n        )\n\n        self.pub_fused_pointcloud = self.create_publisher(\n            PointCloud2, \"/main/fused_pointcloud\", 10\n        )\n\n        self.pub_pointcloud_raw = self.create_publisher(\n            PointCloud2, \"/main/pointcloud_raw\", 10\n        )\n\n        self.pub_fake_joint_state = self.create_publisher(\n            JointState, \"/fake/joint_states\", 10\n        )\n\n        \"\"\"\n        ################### CLIENT ###########################\n        \"\"\"\n        self.client_gripper_control = self.create_client(Gripper, \"gripper_control\")\n\n        self.client_all_grasp = self.create_client(GraspPoseSend, \"GraspPose\")\n\n        self.client_best_grasp = self.create_client(BestGraspPose, \"BestGraspPose\")\n\n        self.client_stl_collision = self.create_client(\n            TargetObjectSend, \"make_stl_collision\"\n        )\n\n        self.client_make_collision = self.create_client(\n            PointCloudSend, \"CollisionMaker\"\n        )\n\n        self.client_ik_grasp = self.create_client(IKJointState, \"joint_state_from_ik\")\n        self.client_joint_state_collision_bool = self.create_client(\n            JointStateCollisionBool, \"joint_state_collision_check_bool\"\n        )\n        self.client_get_planning_scene = self.create_client(\n            GetPlanningScene, \"/get_planning_scene\"\n        )\n\n        self.client_make_collision_with_mask = self.create_client(PCLMani, \"pcl_mani\")\n\n        self.client_aim_grip_plan = self.create_client(AimGripPlan, \"AimGripPlan\")\n        self.client_home_plan = self.create_client(Trigger, \"home_plan_service\")\n\n        self.client_move_joint_pose = self.create_client(JointPose, \"move_joint_pose\")\n\n        # Trigger Client\n        self.client_trigger_aim = self.create_client(Trigger, \"/aim_trigger_service\")\n        self.client_trigger_grip = self.create_client(Trigger, \"/grip_trigger_service\")\n        self.client_trigger_home = self.create_client(Trigger, \"/home_trigger_service\")\n\n        self.client_attach = self.create_client(Trigger, \"attach_collision_object\")\n        self.client_detach = self.create_client(Trigger, \"detach_collision_object\")\n\n        self.client_attach_big_small = self.create_client(Trigger, \"attach_collision_object_big_small\")\n        self.client_detach_big_small = self.create_client(Trigger, \"detach_collision_object_big_small\")\n\n        self.client_clear_planning_scene = self.create_client(Trigger, \"clear_planning_scene\")\n\n        self.client_fuse_pointcloud = self.create_client(PCLFuse, \"pcl_fuse\")\n        self.client_camera_ik_joint_state = self.create_client(\n            CameraIKJointState, \"camera_joint_state_from_ik\"\n        )\n\n        self.client_ik_pass_count = self.create_client(\n            IKPassCount, \"ik_pass_count\"\n        )\n\n        # Socket Client\n        self.client_ism = MyClient(\n            host=\"127.0.0.1\", port=11111, client_name=\"Main ISM Client\"\n        )\n        self.client_pem = MyClient(\n            host=\"127.0.0.1\", port=22222, client_name=\"Main PEM Client\"\n        )\n\n        # Finish Init\n        self.log(\"Main Node is Running. Ready for command.\")\n        self.announce_param(\"target_obj\")\n        self.announce_param(\"dataset_path_prefix\")\n        self.announce_param(\"output_path_prefix\")\n\n    def log(self, text):\n        \"\"\"\n        Log Text into Terminal and RViz label\n        \"\"\"\n        # Log in terminal\n        self.get_logger().info(str(text))\n        # Pub to RViz\n        string_msg = String()\n        string_msg.data = str(text)\n        self.pub_rviz_text.publish(string_msg)\n\n    def tlog(self, text):\n        \"\"\"\n        Log Text into Terminal only\n        \"\"\"\n        # Log in terminal\n        self.get_logger().info(str(text))\n\n    def elog(self, text):\n        \"\"\"\n        Log Error Text into Terminal and RViz label\n        \"\"\"\n        # Log in terminal\n        self.get_logger().error(str(text))\n        # Pub to RViz\n        string_msg = String()\n        string_msg.data = str(text)\n        self.pub_rviz_text.publish(string_msg)\n\n    def announce_param(self, param_name):\n        self.log(\n            f\"⚠️  Param '{param_name}' set to '{self.get_str_param(param_name)}'. Use ros2 param set or rqt to change.\"\n        )\n\n    def is_empty(self, obj):\n        if obj is None:\n            return True\n        if isinstance(obj, np.ndarray):\n            return obj.size == 0\n        if hasattr(obj, \"data\"):\n            return not obj.data\n        try:\n            return obj == type(obj)()\n        except Exception:\n            return False\n\n    def get_str_param(self, param_name):\n        return self.get_parameter(param_name).get_parameter_value().string_value\n\n    def get_current_time(self):\n        return f\"{datetime.now().strftime('%H-%M-%S-%f')[:-4]}\"\n\n    def service_trigger_and_wait(self, client: rclpy.client.Client):\n        future = client.call_async(Trigger.Request())\n        future.add_done_callback(lambda res: self.log(res.result()))\n\n    async def call_service(self, client, request):\n        try:\n            future = client.call_async(request)\n            await future\n            return future.result()\n        except Exception as e:\n            self.elog(f\"Service call failed: {e}\")\n            return None\n\n    def call_make_stl_collision(self, object_pose=None):\n        req = TargetObjectSend.Request()\n        if object_pose is None:\n            req.object_pose = self.data_object_pose\n        else:\n            req.object_pose = object_pose\n        req.dataset_path_prefix = self.get_str_param(\"dataset_path_prefix\")\n        req.target_obj = self.get_str_param(\"target_obj\")\n\n        future = self.client_stl_collision.call_async(req)\n\n    def command_callback(self, msg: String):\n        \"\"\"\n        RViz command callback\n        \"\"\"\n        recv_command = msg.data.strip().lower()\n        self.log(f\"Received command: {recv_command}\")\n\n        # if recv_command in self.command_map:\n        #     self.command_map[recv_command]()\n        # else:\n        #     self.get_logger().warn(f\"Unknown command received: {recv_command}\")\n\n        if recv_command in self.command_map:\n            command_func = self.command_map[recv_command]\n            if asyncio.iscoroutinefunction(command_func):\n                # Run coroutine in event loop\n                asyncio.run_coroutine_threadsafe(command_func(), self.loop)\n            else:\n                command_func()\n\n    def zed_camera_info_callback(self, msg: CameraInfo):\n        if self.capture_camera_info:\n            self.camera_info = msg\n\n    def zed_pointcloud_callback(self, msg: PointCloud2):\n        \"\"\"\n        Transform and save pointcloud only when commanded.\n        \"\"\"\n        if self.capture_pointcloud:\n            try:\n                tf = self.tf_buffer.lookup_transform(\n                    \"world\",\n                    msg.header.frame_id,\n                    rclpy.time.Time(),\n                    rclpy.duration.Duration(seconds=0.5),\n                )\n            except TransformException as ex:\n                self.log(f\"Could not get transform for point cloud: {ex}\")\n                return\n\n            transformed_pointcloud, transformed_xyz = utils.transform_pointcloud(\n                msg=msg, tf=tf, frame_id=\"world\"\n            )\n\n            self.pub_captured_pointcloud.publish(transformed_pointcloud)\n\n            self.data_pointcloud = transformed_pointcloud\n            self.data_pointcloud_xyz = transformed_xyz\n            self.capture_pointcloud = False\n            self.log(\"Captured and saved pointcloud.\")\n\n            self.log(self.data_pointcloud.width)\n\n            if self.capture_to_fuse:\n                # Fuse Pointcloud\n                if self.is_empty(self.data_pointcloud_fused):\n                    self.data_pointcloud_fused = self.data_pointcloud\n                else:\n                    self.data_pointcloud_fused = utils.combine_pointclouds(\n                        self.data_pointcloud_fused, self.data_pointcloud\n                    )\n\n                self.pub_fused_pointcloud.publish(self.data_pointcloud_fused)\n                self.log(\n                    f\"Fuse PointCloud, current width {self.data_pointcloud_fused.width}\"\n                )\n\n                self.capture_to_fuse = False\n\n    def zed_rgb_callback(self, msg: Image):\n        \"\"\"\n        Save RGB only when commanded.\n        \"\"\"\n        if self.capture_rgb:\n            # Save Msg\n            self.data_msg_rgb = msg\n            self.log(\"Index\" + str(self.capture_index))\n\n            # Convert to array\n            try:\n                array_bgr = self.bridge.imgmsg_to_cv2(msg, desired_encoding=\"bgr8\")\n                array_rgb = cv2.cvtColor(array_bgr, cv2.COLOR_BGR2RGB)\n            except Exception as e:\n                self.elog(f\"CVBridge error: {e}\")\n                return\n            self.data_array_rgb = array_rgb\n            self.capture_rgb = False\n            self.pub_captured_rgb.publish(msg)\n            # Save Image\n            image_utils.save_rgb_image(\n                rgb_image=self.data_array_rgb,\n                output_dir=os.path.join(\n                    self.get_str_param(\"output_path_prefix\"),\n                    self.node_run_folder_name,\n                    self.capture_folder_name,\n                ),\n                file_name=(f\"rgb_{self.capture_index}\", \"rgb\")[\n                    self.capture_index is None\n                ],\n            )\n\n            self.log(\"Captured RGB.\")\n\n    def zed_depth_callback(self, msg: Image):\n        \"\"\"\n        Save DEPTH only when commanded.\n        \"\"\"\n        if self.capture_depth:\n            # Save msg\n            self.data_msg_depth = msg\n\n            # Convert to array\n            try:\n                array_depth_m = self.bridge.imgmsg_to_cv2(msg, desired_encoding=\"32FC1\")\n            except Exception as e:\n                self.elog(f\"CVBridge error: {e}\")\n                return\n\n            # Replace NaNs with 0\n            array_depth_m = np.nan_to_num(\n                array_depth_m, nan=0.0, posinf=0.0, neginf=0.0\n            )\n\n            # SClip values to range 10m\n            array_depth_m = np.clip(array_depth_m, 0.0, 10.0)\n\n            # Convert to mm\n            array_depth_mm = (array_depth_m * 1000).astype(np.int32)\n\n            self.data_array_depth = array_depth_mm\n            self.capture_depth = False\n            self.pub_captured_depth.publish(msg)\n\n            # Save Image\n            image_utils.save_depth_uint16(\n                depth_maps=self.data_array_depth,\n                output_dir=os.path.join(\n                    self.get_str_param(\"output_path_prefix\"),\n                    self.node_run_folder_name,\n                    self.capture_folder_name,\n                ),\n                file_name=(f\"depth_{self.capture_index}\", \"depth\")[\n                    self.capture_index is None\n                ],\n            )\n\n            self.log(\"Captured depth.\")\n\n    def command_capture(self, new_folder=True):\n        \"\"\"\n        Capture Current Point Cloud in self.data_pointcloud\n        \"\"\"\n\n        if not os.path.exists(\n            os.path.join(\n                self.get_str_param(\"output_path_prefix\"), self.node_run_folder_name\n            )\n        ):\n            os.makedirs(\n                os.path.join(\n                    self.get_str_param(\"output_path_prefix\"), self.node_run_folder_name\n                )\n            )\n\n        if new_folder:\n            self.capture_folder_name = f\"Cap-{self.get_current_time()}\"\n\n        self.capture_pointcloud = True\n        self.capture_rgb = True\n        self.capture_depth = True\n        self.capture_camera_info = True\n        self.log(\"Ready to capture next pointcloud.\")\n\n    def command_capture_to_fuse(self, new_folder=False):\n        self.capture_to_fuse = True\n        self.command_capture(new_folder=new_folder)\n\n    ## CLIENT: ISM ########################################\n    def command_srv_req_ism(self):\n        if self.is_empty(self.data_array_rgb):\n            self.elog(\"No RGB Data.\")\n            return\n        if self.is_empty(self.data_array_depth_fused):\n            self.elog(\"No Fused Depth.\")\n            return\n\n        client_connected = self.client_ism.connect()\n        if not client_connected:\n            self.elog(f\"Server ISM not started\")\n            return\n\n        try:\n            self.req_ism_time = self.get_current_time()\n            target_obj = self.get_str_param(\"target_obj\")\n\n            # Service Request\n            best_mask, best_box, best_score, combined_result = (\n                self.client_ism.request_msg(\n                    msg_type_in=[\"numpyarray\", \"numpyarray\", \"string\", \"string\"],\n                    msg_in=[\n                        self.data_array_rgb,\n                        self.data_array_depth_fused,\n                        target_obj,\n                        self.get_str_param(\"dataset_path_prefix\"),\n                    ],\n                )\n            )\n\n            # Save Best Mask\n            self.data_best_mask = best_mask\n            self.data_msg_best_mask = image_utils.mask_to_ros_image(self.data_best_mask)\n\n            # Save Image\n            image_utils.save_binary_mask(\n                mask=best_mask,\n                output_dir=os.path.join(\n                    self.get_str_param(\"output_path_prefix\"),\n                    self.node_run_folder_name,\n                    self.capture_folder_name,\n                ),\n                file_name=f\"{self.req_ism_time}_best_mask_{target_obj}\",\n            )\n            image_utils.save_rgb_image(\n                rgb_image=combined_result,\n                output_dir=os.path.join(\n                    self.get_str_param(\"output_path_prefix\"),\n                    self.node_run_folder_name,\n                    self.capture_folder_name,\n                ),\n                file_name=f\"{self.req_ism_time}_ism_result_{target_obj}\",\n            )\n\n            # Pub\n            self.pub_best_mask.publish(self.data_msg_best_mask)\n\n            self.log(f\"Response Received from ISM with best score: {best_score}\")\n        except Exception as e:\n            self.elog(f\"Failed to send request: {e}\")\n\n        self.client_ism.disconnect()\n        self.log(f\"ISM Connection Closed.\")\n\n    ## CLIENT: PEM ########################################\n    def command_srv_req_pem(self):\n        if self.is_empty(self.data_array_rgb) or self.is_empty(self.data_array_depth):\n            self.elog(\"No RGB or Depth Data. Capture First\")\n            return\n        if self.is_empty(self.data_array_depth_fused):\n            self.elog(\"No Fused Depth.\")\n            return\n\n        if self.is_empty(self.data_best_mask):\n            self.elog(\"No Best Mask. Req ISM First.\")\n            return\n\n        client_connected = self.client_pem.connect()\n        if not client_connected:\n            self.elog(f\"Server PEM not started\")\n            return\n\n        try:\n            target_obj = self.get_str_param(\"target_obj\")\n\n            # Service Request\n            result_rot, result_trans, result_image = self.client_pem.request_msg(\n                msg_type_in=[\n                    \"numpyarray\",\n                    \"numpyarray\",\n                    \"numpyarray\",\n                    \"string\",\n                    \"string\",\n                ],\n                msg_in=[\n                    self.data_best_mask,\n                    self.data_array_rgb,\n                    self.data_array_depth_fused,\n                    target_obj,\n                    self.get_str_param(\"dataset_path_prefix\"),\n                ],\n            )\n\n            self.data_pem_result = result_image\n            self.data_msg_pem_result = image_utils.rgb_to_ros_image(\n                self.data_pem_result\n            )\n\n            # + 2 cm\n            # result_trans +=(result_trans /  np.linalg.norm(result_trans)) * 0.015\n            \n            # Object PoseStamped WRT Zed\n            self.data_object_pose_wrt_cam = utils.rotation_translation_to_posestamped(\n                rotation=result_rot,\n                translation=result_trans,\n                frame_id=\"zed_left_camera_optical_frame\",\n            )\n\n            self.log(self.data_object_pose_wrt_cam)\n\n            # Transform to world\n            self.data_object_pose = utils.transform_pose_stamped(\n                self.tf_buffer,\n                self.data_object_pose_wrt_cam,\n                current_frame=\"zed_left_camera_optical_frame\",\n                new_frame=\"world\",\n            )\n\n            # Save Image\n            image_utils.save_rgb_image(\n                rgb_image=result_image,\n                output_dir=os.path.join(\n                    self.get_str_param(\"output_path_prefix\"),\n                    self.node_run_folder_name,\n                    self.capture_folder_name,\n                ),\n                file_name=f\"{self.req_ism_time}_pem_result_{target_obj}\",\n            )\n\n            # Pub\n            self.pub_object_pose.publish(self.data_object_pose)\n            self.pub_pem_result.publish(self.data_msg_pem_result)\n\n            self.call_make_stl_collision()\n\n            self.log(f\"Response Received from PEM\")\n\n            # self.log(f\"Response Received from ISM with best score: {best_score}\")\n        except Exception as e:\n            self.elog(f\"Failed to send request: {e}\")\n\n        self.client_pem.disconnect()\n        self.log(f\"PEM Connection Closed.\")\n\n    ## CLIENT: ALL_GRASP ########################################\n    async def command_srv_all_grasp(self):\n        if not self.client_all_grasp.wait_for_service(timeout_sec=3.0):\n            self.elog(\"Service All Grasp not available!\")\n            return\n\n        request = GraspPoseSend.Request()\n        request.target_obj = self.get_str_param(\"target_obj\")\n        request.dataset_path_prefix = self.get_str_param(\"dataset_path_prefix\")\n\n        # Call\n        all_grasp_response = await self.call_service(self.client_all_grasp, request)\n        if not all_grasp_response:\n            return\n\n        # Response\n        num_poses = len(all_grasp_response.grasp_poses.grasp_poses)\n        self.log(f\"Received {num_poses} grasp pose(s).\")\n        self.data_all_grasp_pose = all_grasp_response.grasp_poses\n\n    ## CLIENT: BEST_GRASP########################################\n    async def command_srv_best_grasp(self):\n        if not self.client_best_grasp.wait_for_service(timeout_sec=3.0):\n            self.elog(\"Service Best Grasp not available!\")\n            return\n\n        if self.is_empty(self.data_all_grasp_pose):\n            self.elog(\"NO all grasp data\")\n            return\n\n        if self.is_empty(self.data_object_pose):\n            self.elog(\"NO Object Pose Data, Req PEM First\")\n            return\n\n        request = BestGraspPose.Request()\n        request.all_grasp_poses = self.data_all_grasp_pose\n        request.object_pose = self.data_object_pose\n        self.log(f\"Sending {len(request.all_grasp_poses.grasp_poses)} grasp poses.\")\n\n        # Call\n        best_grasp_response = await self.call_service(self.client_best_grasp, request)\n        if not best_grasp_response:\n            return\n\n        # Response\n        self.data_sorted_grasp_aim_pose = best_grasp_response.sorted_aim_poses\n        self.data_sorted_grasp_grip_pose = best_grasp_response.sorted_grip_poses\n        self.data_sorted_grasp_gripper_distance = best_grasp_response.gripper_distance\n\n        num_passed_grasp = len(self.data_sorted_grasp_aim_pose.poses)\n\n        if num_passed_grasp == 0:\n            self.elog(\"No grasp passed criteria\")\n            return\n\n        self.log(f\"Received {num_passed_grasp} best aim pose.\")\n\n        # for i, pose in enumerate(self.data_sorted_grasp_aim_pose.poses):\n        #     pos = pose.position\n        #     ori = pose.orientation\n        #     self.log(\n        #         f\"[{i:02d}] Position: x={pos.x:.3f}, y={pos.y:.3f}, z={pos.z:.3f} | \"\n        #         f\"Orientation: x={ori.x:.3f}, y={ori.y:.3f}, z={ori.z:.3f}, w={ori.w:.3f}\"\n        #     )\n        self.pub_best_grasp_aim_poses.publish(self.data_sorted_grasp_aim_pose)\n        self.pub_best_grasp_grip_poses.publish(self.data_sorted_grasp_grip_pose)\n\n    ## CLIENT: MAKE COLLISION ########################################\n    async def command_srv_make_collision(self):\n        if not self.client_make_collision.wait_for_service(timeout_sec=3.0):\n            self.elog(\"Service Make Collision not available!\")\n            return\n\n        if self.is_empty(self.data_pointcloud):\n            self.elog(\"Cannot make Collision. Capture pointcloud first.\")\n            return\n        \n        self.log(\"Attach Big Small Object\")\n        self.service_trigger_and_wait(self.client_attach_big_small)\n\n        request = PointCloudSend.Request()\n        request.pointcloud = self.data_pointcloud_fused  # Correct field assignment\n\n        # Call\n        make_collision_response = await self.call_service(\n            self.client_make_collision, request\n        )\n        if not make_collision_response:\n            return\n        \n\n        self.log(\"Detach Big Small Object\")\n        self.service_trigger_and_wait(self.client_detach_big_small)\n        \n        # Response\n        self.log(f\"Make Collision Success\")\n\n    ## CLIENT: MAKE COLLISION WITH MASK #####################################\n    async def command_srv_make_collision_with_mask(self):\n        if not self.client_make_collision_with_mask.wait_for_service(timeout_sec=3.0):\n            self.elog(\"Service Make Collision With Mask not available!\")\n            return\n\n        if self.is_empty(self.data_pointcloud):\n            self.elog(\"Cannot make Collision. Capture pointcloud first.\")\n            return\n\n        if self.is_empty(self.data_msg_best_mask):\n            self.elog(\"No Best Mask. Req ISM first.\")\n            return\n\n        req = PCLMani.Request()\n        req.rgb_image = self.data_msg_rgb\n        req.depth_image = self.data_msg_depth\n        req.mask_image = self.data_msg_best_mask\n        req.sixd_pose = self.data_object_pose_wrt_cam\n        req.target_object = self.get_str_param(\"target_obj\")\n        req.dataset_path_prefix = self.get_str_param(\"dataset_path_prefix\")\n        req.camera_info = self.camera_info\n\n        # Attach Object\n        # self.command_attach_object()\n\n        # Call\n        make_collision_with_mask_response = await self.call_service(\n            self.client_make_collision_with_mask, req\n        )\n        if not make_collision_with_mask_response:\n            return\n\n        # Response\n        self.log(f\"Remove Target Object from Pointcloud success. Making Collision\")\n        try:\n            # Transform to world\n            tf = self.tf_buffer.lookup_transform(\n                \"world\",\n                make_collision_with_mask_response.pointcloud.header.frame_id,\n                rclpy.time.Time(),\n                rclpy.duration.Duration(seconds=0.5),\n            )\n\n            transformed_pointcloud_no_object, transformed_xyz_no_object = (\n                utils.transform_pointcloud(\n                    msg=make_collision_with_mask_response.pointcloud,\n                    tf=tf,\n                    frame_id=\"world\",\n                )\n            )\n\n            self.data_pointcloud_no_object = transformed_pointcloud_no_object\n\n            self.pub_pointcloud_no_object.publish(self.data_pointcloud_no_object)\n\n            request_make_collision = PointCloudSend.Request()\n            request_make_collision.pointcloud = transformed_pointcloud_no_object\n\n            # Call\n            make_collision_response = await self.call_service(\n                self.client_make_collision, request_make_collision\n            )\n            if not make_collision_response:\n                return\n\n            # Response\n            self.log(f\"Make Collision Success\")\n\n            # self.command_detach_object()\n\n        except Exception as e:\n            self.elog(f\"Failed to make collision with mask: -> {e}\")\n\n    ## CLIENT: IK GRASP #################################################\n    #  1. Get Planning Scene\n    #  2. Get all joint state by IK\n    #  3. Filter joint state by planning scene\n\n    async def command_ik_grasp(self):\n        # Wait for services to be available\n        if not self.client_get_planning_scene.wait_for_service(timeout_sec=3.0):\n            self.elog(\"Service /get_planning_scene not available!\")\n            return\n        if not self.client_ik_grasp.wait_for_service(timeout_sec=3.0):\n            self.elog(\"Service /ik_grasp not available!\")\n            return\n        if not self.client_joint_state_collision_bool.wait_for_service(timeout_sec=3.0):\n            self.elog(\"Service /joint_state_collision not available!\")\n            return\n\n        # Step 1: Get Planning Scene\n        planning_scene_request = GetPlanningScene.Request()\n        planning_scene_request.components.components = (\n            PlanningSceneComponents.SCENE_SETTINGS\n            | PlanningSceneComponents.ROBOT_STATE\n            | PlanningSceneComponents.WORLD_OBJECT_NAMES\n            | PlanningSceneComponents.WORLD_OBJECT_GEOMETRY\n        )\n        planning_scene_response = await self.call_service(\n            self.client_get_planning_scene, planning_scene_request\n        )\n        if not planning_scene_response:\n            return\n        self.data_planning_scene = planning_scene_response.scene\n        self.log(\"Planning scene retrieved successfully.\")\n\n        # Step 2: IK Grasp\n        if not self.data_sorted_grasp_aim_pose or not self.data_sorted_grasp_grip_pose:\n            self.get_logger().warn(\"No grasp data available.\")\n            return\n\n        ik_request = IKJointState.Request()\n        ik_request.sorted_aim_poses = self.data_sorted_grasp_aim_pose\n        ik_request.sorted_grip_poses = self.data_sorted_grasp_grip_pose\n        ik_request.gripper_distance = self.data_sorted_grasp_gripper_distance\n        ik_request.current_joint_state = (\n            self.data_planning_scene.robot_state.joint_state\n        )\n\n        ik_response = await self.call_service(self.client_ik_grasp, ik_request)\n        if not ik_response or not ik_response.possible_aim_joint_state:\n            self.get_logger().warn(\"No valid IK solutions found.\")\n            return\n        self.log(f\"IK solution found: {ik_response.possible_aim_joint_state[0]}\")\n\n        self.data_aim_joint_state = ik_response.possible_aim_joint_state\n\n        self.log(f\"Data Aim Joint State Length {len(self.data_aim_joint_state)}\")\n\n        # Step 3: Joint State Collision Check\n        # Step 3.1: Aim Collision Check\n        collision_aim_request = JointStateCollisionBool.Request()\n        collision_aim_request.joint_state = ik_response.possible_aim_joint_state\n        collision_aim_request.planning_scene = self.data_planning_scene\n\n        collision_aim_response = await self.call_service(\n            self.client_joint_state_collision_bool, collision_aim_request\n        )\n        if not collision_aim_response:\n            self.get_logger().warn(\"Error in Aim Collision Check.\")\n            return\n        # self.log(f\"Aim Response: {collision_aim_response.pass_list}\")\n\n        # Step 3.2: Grip Collision Check\n        collision_grip_request = JointStateCollisionBool.Request()\n        collision_grip_request.joint_state = ik_response.possible_grip_joint_state\n        collision_grip_request.planning_scene = self.data_planning_scene\n\n        collision_grip_response = await self.call_service(\n            self.client_joint_state_collision_bool, collision_grip_request\n        )\n        if not collision_grip_response:\n            self.get_logger().warn(\"Error in Grip Collision Check.\")\n            return\n\n        # self.log(f\"Grip Response: {collision_grip_response.pass_list}\")\n\n        # Output\n        filter_sorted_aim_posearray = PoseArray()\n        filter_sorted_aim_posearray.header.frame_id = \"world\"\n        filter_sorted_grip_posearray = PoseArray()\n        filter_sorted_grip_posearray.header.frame_id = \"world\"\n\n        filter_gripper_distance = []\n\n        filter_aim_joint_state = []\n\n        total_pass = 0\n        for i, (aim_pass, grip_pass) in enumerate(\n            zip(collision_aim_response.pass_list, collision_grip_response.pass_list)\n        ):\n\n            # self.log(f\"{i}, {aim_pass}, {grip_pass}\")\n            if aim_pass and grip_pass:\n                # self.log(f\"{i} Passed\")\n                # self.log(f\"{str(ik_response.sorted_aim_poses.poses[i])} Passed\")\n                # self.log(f\"{ik_response.sorted_grip_poses.poses[i]} Passed\")\n\n                # self.log(f\"{ik_response.gripper_distance[i]} Passed\")\n                # self.log(f\"{ik_response.possible_aim_joint_state[i]} Passed\")\n                filter_sorted_aim_posearray.poses.append(\n                    ik_response.sorted_aim_poses.poses[i]\n                )\n                filter_sorted_grip_posearray.poses.append(\n                    ik_response.sorted_grip_poses.poses[i]\n                )\n\n                filter_gripper_distance.append(ik_response.gripper_distance[i])\n\n                filter_aim_joint_state.append(ik_response.possible_aim_joint_state[i])\n                total_pass += 1\n\n            # else:\n                # self.log(f\"{i} Failed\")\n\n        self.data_aim_joint_state_filter = filter_aim_joint_state\n        self.data_sorted_grasp_aim_pose_filter = filter_sorted_aim_posearray\n        self.data_sorted_grasp_grip_pose_filter = filter_sorted_grip_posearray\n        self.data_sorted_grasp_gripper_distance_filter = filter_gripper_distance\n\n        self.log(\n            f\"Total Pass Joint State: {total_pass} {self.data_aim_joint_state_filter}\"\n        )\n\n    ## CLIENT: PLAN AIM GRIP ############################################\n    async def command_plan_aim_grip(self):\n        if not self.client_aim_grip_plan.wait_for_service(timeout_sec=3.0):\n            self.elog(\"Service Aim Grip Plan not available!\")\n            return\n        if self.is_empty(self.data_aim_joint_state_filter):\n            self.log(\"Filter with IK First.\")\n            return\n\n        request = AimGripPlan.Request()\n        request.sorted_aim_poses = self.data_sorted_grasp_aim_pose_filter\n        request.sorted_grip_poses = self.data_sorted_grasp_grip_pose_filter\n        self.log(str(request))\n        request.aim_joint_states = self.data_aim_joint_state_filter\n        self.log(str(request))\n\n        # Call\n        aim_grip_plan_response = await self.call_service(\n            self.client_aim_grip_plan, request\n        )\n        if not aim_grip_plan_response:\n            return\n\n        # Response\n        self.passed_index = aim_grip_plan_response.passed_index\n        self.log(\n            f\"Plan Aim Grip Success with index: {self.passed_index} , Distance: {self.data_sorted_grasp_gripper_distance_filter[self.passed_index]}\"\n        )\n\n    ## CLIENT: TRIGGER AIM ############################################\n    def command_trigger_aim(self):\n        self.log(\"Going to AIM\")\n        self.service_trigger_and_wait(self.client_trigger_aim)\n\n    ## CLIENT: TRIGGER GRIP ###########################################\n    async def command_trigger_grip(self):\n        await self.srv_gripper_control_send_distance(distance_mm=50)\n        # future = self.client_trigger_grip.call_async(Trigger.Request())\n        self.log(\"Going to GRIP\")\n        self.service_trigger_and_wait(self.client_trigger_grip)\n\n        self.log(\"Gripping...\")\n        # self.srv_gripper_control_send_distance(\n        #     distance_mm=self.data_sorted_grasp_gripper_distance[self.passed_index]\n        # )\n\n    ## CLIENT: PLAN HOME ###########################################\n    def command_plan_home(self):\n        self.log(\"Planning to HOME\")\n        self.service_trigger_and_wait(self.client_home_plan)\n\n    ## CLIENT: TRIGGER HOME ###########################################\n    def command_trigger_home(self):\n        self.log(\"Going to HOME\")\n        self.service_trigger_and_wait(self.client_trigger_home)\n\n    ## CLIENT: ATTACH OBJECT ###########################################\n    def command_attach_object(self):\n        self.log(\"Attach Object\")\n        self.service_trigger_and_wait(self.client_attach)\n\n    ## CLIENT: DETACH OBJECT ###########################################\n    def command_detach_object(self):\n        self.log(\"Detach Object\")\n        self.service_trigger_and_wait(self.client_detach)\n\n        ## CLIENT: DETACH OBJECT ###########################################\n    def command_clear_planning_scene(self):\n        self.log(\"Clear Planning Scene\")\n        self.service_trigger_and_wait(self.client_clear_planning_scene)\n\n    ## CLIENT: GRIPPER CONTROL ########################################\n    async def srv_gripper_control_send_distance(self, distance_mm, pub_joint=False):\n        if not self.client_gripper_control.wait_for_service(timeout_sec=3.0):\n            self.elog(\"Service Gripper Control not available!\")\n            return\n\n        request = Gripper.Request()\n        request.gripper_distance = int(distance_mm)\n        request.pub_joint = pub_joint\n\n        # Call\n        gripper_response = await self.call_service(self.client_gripper_control, request)\n        if not gripper_response:\n            return\n        self.log(f\"Sent distance Success: {distance_mm} mm\")\n\n    ## GRIPPER OPEN ###########################################\n    async def command_gripper_open(self):\n        await self.srv_gripper_control_send_distance(distance_mm=55, pub_joint=True)\n\n    ## GRIPPER CLOSE ########################################\n    async def command_gripper_close(self):\n        self.log(f\"Passed Index: {self.passed_index}\")\n        if self.passed_index is not None:\n            await self.srv_gripper_control_send_distance(\n                distance_mm=int(\n                    self.data_sorted_grasp_gripper_distance_filter[self.passed_index]\n                )\n                - 2\n            )\n        else:\n            await self.srv_gripper_control_send_distance(distance_mm=0)\n\n    ## GRIP AND ATTACH ##################################\n    async def command_grip_and_attach(self):\n        await self.command_gripper_close()\n        self.command_attach_object()\n\n    ## FAKE POINT CLOUD ########################################\n    async def command_fake_point_cloud(self):\n\n        request = IKPassCount.Request()\n        request.pose_array = self.data_sorted_grasp_aim_pose\n\n        # Call\n        await self.call_service(\n            self.client_ik_pass_count, request\n        )\n\n        # self.data_pointcloud = fake_utils.get_random_pointcloud()\n        # self.pub_captured_pointcloud.publish(self.data_pointcloud)\n\n    ## FAKE OBJECT POSE ########################################\n    def command_fake_object_pose(self):\n        self.data_object_pose = fake_utils.get_random_pose_stamped()\n        self.data_object_pose.pose.position.z += 0.8\n        self.pub_object_pose.publish(self.data_object_pose)\n        self.call_make_stl_collision()\n\n    ## FAKE_JOINT_STATE\n    def fake_joint_state_pub(self):\n\n        if len(self.data_aim_joint_state) == 0:\n            self.log(\"No Joint State Data\")\n            return\n\n        msg = self.data_aim_joint_state[self.fake_joint_state_index]\n\n        msg.header.stamp = self.get_clock().now().to_msg()\n\n        msg.name = [\"fake_\" + i for i in msg.name]\n\n        self.pub_fake_joint_state.publish(msg)\n        self.fake_joint_state_index = (self.fake_joint_state_index + 1) % len(\n            self.data_aim_joint_state\n        )\n\n    ## CLIENT: FUSE POINTCLOUD ########################################\n    async def command_fuse_pointcloud(self):\n        if not self.client_fuse_pointcloud.wait_for_service(timeout_sec=3.0):\n            self.elog(\"Service Fuse Pointcloud not available!\")\n            return\n\n        try:\n            tf = self.tf_buffer.lookup_transform(\n                \"zed_left_camera_optical_frame\",\n                \"world\",\n                rclpy.time.Time(),\n                rclpy.duration.Duration(seconds=0.5),\n            )\n        except TransformException as ex:\n            self.log(f\"Could not get transform for point cloud: {ex}\")\n            return\n\n        transformed_pointcloud_fused, _ = utils.transform_pointcloud(\n            msg=self.data_pointcloud_fused,\n            tf=tf,\n            frame_id=\"zed_left_camera_optical_frame\",\n        )\n\n        self.pub_pointcloud_raw.publish(transformed_pointcloud_fused)\n\n        request = PCLFuse.Request()\n        request.pointcloud = transformed_pointcloud_fused\n        request.camera_info = self.camera_info\n\n        # Call\n        fuse_pointcloud_response = await self.call_service(\n            self.client_fuse_pointcloud, request\n        )\n        if not fuse_pointcloud_response:\n            return\n\n        # Response\n        try:\n            array_depth_m = self.bridge.imgmsg_to_cv2(\n                fuse_pointcloud_response.depth_image, desired_encoding=\"32FC1\"\n            )\n        except Exception as e:\n            self.elog(f\"CVBridge error: {e}\")\n            return\n\n        # Replace NaNs with 0\n        array_depth_m = np.nan_to_num(array_depth_m, nan=0.0, posinf=0.0, neginf=0.0)\n\n        # SClip values to range 10m\n        array_depth_m = np.clip(array_depth_m, 0.0, 10.0)\n\n        # Convert to mm\n        array_depth_mm = (array_depth_m * 1000).astype(np.int32)\n\n        # Save Image\n        image_utils.save_depth_uint16(\n            depth_maps=array_depth_mm,\n            output_dir=os.path.join(\n                self.get_str_param(\"output_path_prefix\"),\n                self.node_run_folder_name,\n                self.capture_folder_name,\n            ),\n            file_name=\"depth_fused\",\n        )\n        self.data_array_depth_fused = array_depth_mm\n        self.data_msg_depth_fused = fuse_pointcloud_response.depth_image\n\n        self.log(\"Fuse PointCloud Success\")\n\n    ## CLEAR POINTCLOUD\n    def command_clear_pointcloud(self):\n        self.data_pointcloud_fused = PointCloud2()\n\n    ## AUTOMATED POINTCLOUD FUSING ###########################\n    async def command_auto_fuse_pointcloud(self):\n        self.data_pointcloud_fused = PointCloud2()\n        # Get Planning Scene\n        if not self.client_get_planning_scene.wait_for_service(timeout_sec=3.0):\n            self.elog(\"Service /get_planning_scene not available!\")\n            return\n        if not self.client_camera_ik_joint_state.wait_for_service(timeout_sec=3.0):\n            self.elog(\"Service Camera IK Joint State not available!\")\n            return\n\n        if not self.client_move_joint_pose.wait_for_service(timeout_sec=3.0):\n            self.elog(\"Service Move Joint Pose not available!\")\n            return\n\n        request_get_planning_scene = GetPlanningScene.Request()\n        request_get_planning_scene.components.components = (\n            PlanningSceneComponents.SCENE_SETTINGS\n            | PlanningSceneComponents.ROBOT_STATE\n            | PlanningSceneComponents.WORLD_OBJECT_NAMES\n            | PlanningSceneComponents.WORLD_OBJECT_GEOMETRY\n        )\n\n        # Call Get Planning Scene\n        planning_scene_response = await self.call_service(\n            self.client_get_planning_scene, request_get_planning_scene\n        )\n        if not planning_scene_response:\n            return\n\n        # Response Planning Scene\n        self.data_planning_scene = planning_scene_response.scene\n        self.log(f\"Received Planning Scene of type: {type(self.data_planning_scene)}.\")\n\n        # Camera IK\n        request_camera_joint_state = CameraIKJointState.Request()\n        request_camera_joint_state.current_joint_state = (\n            self.data_planning_scene.robot_state.joint_state\n        )\n\n        # Call Camera IK\n        camera_ik_joint_state_response = await self.call_service(\n            self.client_camera_ik_joint_state, request_camera_joint_state\n        )\n        if not camera_ik_joint_state_response:\n            return\n\n        # Response\n        self.log(\n            f\"Received Camera IK Response with len: {len(camera_ik_joint_state_response.moving_joint_state)}.\"\n        )\n\n        for (\n            camera_capture_joint_state\n        ) in camera_ik_joint_state_response.moving_joint_state:\n\n            req_move_joint = JointPose.Request()\n            req_move_joint.joint_state = camera_capture_joint_state\n\n            self.log(f\"Moving To : {req_move_joint.joint_state}\")\n\n            # Call\n            move_joint_response = await self.call_service(\n                self.client_move_joint_pose, req_move_joint\n            )\n            if not move_joint_response:\n                return\n\n            # Response\n            self.log(f\"Move Joint -> success : {move_joint_response.success}\")\n\n            if not move_joint_response.success:\n                self.log(f\"Move Joint Failed. Exiting....\")\n                return\n\n            await asyncio.sleep(1)\n\n            if self.capture_index is None:\n                self.capture_index = 0\n                self.command_capture_to_fuse(new_folder=True)\n            else:\n                self.capture_index += 1\n                self.command_capture_to_fuse(new_folder=False)\n            # break\n\n        await asyncio.sleep(2)\n        await self.command_fuse_pointcloud()\n\n        self.capture_index = None\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = MainNode()\n    rclpy.spin(node)\n\n\nif __name__ == \"__main__\":\n    main()\n"}\n{"instruction": "Write a ROS2 Python node named ur10_move.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "#!/usr/bin/env python3\n\nimport rclpy\nfrom rclpy.node import Node\nfrom rclpy.action import ActionClient\nfrom moveit_msgs.action import MoveGroup\nfrom moveit_msgs.msg import Constraints, PositionConstraint, OrientationConstraint, PlanningScene, CollisionObject\nfrom shape_msgs.msg import SolidPrimitive\nfrom geometry_msgs.msg import Pose\nfrom geometry_msgs.msg import PoseStamped\nfrom visualization_msgs.msg import Marker\nimport math\nimport time\n\ndef get_goal_from_user():\n    \"\"\"Get goal position (m) and orientation (rpy in degrees) from user input\"\"\"\n    print(\"Enter goal pose (position in meters, orientation in degrees):\")\n    try:\n        x = float(input(\"X position: \"))\n        y = float(input(\"Y position: \"))\n        z = float(input(\"Z position: \"))\n        roll_deg = float(input(\"Roll (deg): \") or 0)\n        pitch_deg = float(input(\"Pitch (deg): \") or 0)\n        yaw_deg = float(input(\"Yaw (deg): \") or 0)\n        return x, y, z, roll_deg, pitch_deg, yaw_deg\n    except ValueError:\n        print(\"Invalid input. Using defaults (0.5, 0.0, 0.5, rpy=0,0,0).\")\n        return 0.5, 0.0, 0.5, 0.0, 0.0, 0.0\n\n\ndef euler_to_quaternion(roll, pitch, yaw):\n    \"\"\"Convert Euler angles (in radians) to quaternion\"\"\"\n    cy = math.cos(yaw * 0.5)\n    sy = math.sin(yaw * 0.5)\n    cp = math.cos(pitch * 0.5)\n    sp = math.sin(pitch * 0.5)\n    cr = math.cos(roll * 0.5)\n    sr = math.sin(roll * 0.5)\n\n    qw = cr * cp * cy + sr * sp * sy\n    qx = sr * cp * cy - cr * sp * sy\n    qy = cr * sp * cy + sr * cp * sy\n    qz = cr * cp * sy - sr * sp * cy\n\n    return qx, qy, qz, qw\n\n\nclass UR10MoveItClient(Node):\n    def __init__(self):\n        super().__init__('ur10_moveit_client')\n        \n        # Action client for MoveGroup\n        self.move_group_client = ActionClient(self, MoveGroup, 'move_action')\n\n        # Publisher for planning scene updates (to add floor)\n        self.scene_pub = self.create_publisher(PlanningScene, '/planning_scene', 10)\n        self.goal_pub = self.create_publisher(PoseStamped, '/goal_pose', 10)\n        self.marker_pub = self.create_publisher(Marker, '/goal_marker', 10)\n        # Wait for MoveGroup server\n        self.get_logger().info(\"Waiting for MoveGroup action server...\")\n        self.move_group_client.wait_for_server(timeout_sec=10.0)\n        self.get_logger().info(\"MoveGroup action server available!\")\n\n        # Add floor to the planning scene\n        self.add_floor_to_scene()\n\n        print(self.move_group_client.get_ee_frame())\n        print(self.move_group_client.get_ee_link())\n        print(self.move_group_client.get_ee_link_name())\n        time.sleep(1.0)\n\n    def add_floor_to_scene(self):\n        \"\"\"Publish a collision object representing the floor\"\"\"\n        self.get_logger().info(\"Adding floor collision object to the planning scene...\")\n\n        floor = CollisionObject()\n        floor.id = \"floor\"\n        floor.header.frame_id = \"world\"  # Use 'world' if robot base is at world origin\n\n        # Define a box primitive as floor (2m x 2m x 0.05m)\n        primitive = SolidPrimitive()\n        primitive.type = SolidPrimitive.BOX\n        primitive.dimensions = [2.0, 2.0, 0.05]\n\n        # Set its pose slightly below the robot base\n        pose = Pose()\n        pose.position.z = -0.025  # half thickness below base (floor is at z = 0)\n        pose.orientation.w = 1.0\n\n        # Add primitive to floor object\n        floor.primitives.append(primitive)\n        floor.primitive_poses.append(pose)\n        floor.operation = CollisionObject.ADD\n\n        # Add to PlanningScene\n        scene = PlanningScene()\n        scene.is_diff = True\n        scene.world.collision_objects.append(floor)\n\n        # Publish once\n        self.scene_pub.publish(scene)\n        self.get_logger().info(\"Floor collision object published to planning scene!\")\n\n    def move_to_pose(self, pose, group_name=\"arm\"):\n        \"\"\"Move robot to a specific pose using MoveGroup action\"\"\"\n        goal_msg = MoveGroup.Goal()\n        goal_msg.request.group_name = group_name\n        goal_msg.request.num_planning_attempts = 10\n        goal_msg.request.allowed_planning_time = 10.0\n        goal_msg.request.max_velocity_scaling_factor = 0.3\n        goal_msg.request.max_acceleration_scaling_factor = 0.3\n        \n        # Define constraints\n        # pos_constraint = PositionConstraint()\n        # pos_constraint.header.frame_id = \"base_link\"\n        # pos_constraint.link_name = \"flange\"\n        # pos_constraint.target_point_offset.x = pose.position.x\n        # pos_constraint.target_point_offset.y = pose.position.y\n        # pos_constraint.target_point_offset.z = pose.position.z\n        # pos_constraint.weight = 1.0\n        \n        # orient_constraint = OrientationConstraint()\n        # orient_constraint.header.frame_id = \"base_link\"\n        # orient_constraint.link_name = \"flange\"\n        # orient_constraint.orientation = pose.orientation\n        # orient_constraint.absolute_x_axis_tolerance = 0.01\n        # orient_constraint.absolute_y_axis_tolerance = 0.01\n        # orient_constraint.absolute_z_axis_tolerance = 0.01\n        # orient_constraint.weight = 1.0\n        \n        # constraints = Constraints()\n        # constraints.name = \"pose_goal\"\n        # constraints.position_constraints = [pos_constraint]\n        # constraints.orientation_constraints = [orient_constraint]\n        # goal_msg.request.goal_constraints = [constraints]\n        #print EE frame\n        # Send goal\n        self.get_logger().info(f\"Sending goal to MoveGroup for group '{group_name}'...\")\n        future = self.move_group_client.send_goal_async(goal_msg)\n        rclpy.spin_until_future_complete(self, future)\n        \n        goal_handle = future.result()\n        if not goal_handle or not goal_handle.accepted:\n            self.get_logger().error(\"Goal rejected by MoveGroup server.\")\n            return False\n        \n        self.get_logger().info(\"Goal accepted, waiting for result...\")\n        result_future = goal_handle.get_result_async()\n        rclpy.spin_until_future_complete(self, result_future)\n        \n        result = result_future.result().result\n        if result.error_code.val == result.error_code.SUCCESS:\n            self.get_logger().info(\"Movement completed successfully!\")\n            return True\n        else:\n            self.get_logger().error(f\"Movement failed with error code: {result.error_code.val}\")\n            return \n        \n    def visualize_goal_pose(self, pose):\n        \"\"\"Publish a PoseStamped and Marker for visualization in RViz\"\"\"\n        # PoseStamped for TF visualization\n        pose_stamped = PoseStamped()\n        pose_stamped.header.frame_id = \"world\"\n        pose_stamped.header.stamp = self.get_clock().now().to_msg()\n        pose_stamped.pose = pose\n        self.goal_pub.publish(pose_stamped)\n\n        # Marker  \n        marker = Marker()\n        marker.header.frame_id = \"world\"\n        marker.header.stamp = self.get_clock().now().to_msg()\n        marker.type = Marker.SPHERE\n        marker.action = Marker.ADD\n        marker.scale.x = 0.05\n        marker.scale.y = 0.05\n        marker.scale.z = 0.05\n        marker.color.a = 1.0\n        marker.color.r = 0.0\n        marker.color.g = 1.0\n        marker.color.b = 0.0\n        marker.pose = pose\n        marker.id = 0\n        self.marker_pub.publish(marker)\n\n        self.get_logger().info(\"Published goal pose to RViz topics: /goal_pose and /goal_marker\")\n\n\ndef main():\n    rclpy.init()\n    try:\n        client = UR10MoveItClient()\n        \n        # Get goal from user\n        x, y, z, roll_deg, pitch_deg, yaw_deg = get_goal_from_user()\n        roll, pitch, yaw = [math.radians(a) for a in (roll_deg, pitch_deg, yaw_deg)]\n        \n        qx, qy, qz, qw = euler_to_quaternion(roll, pitch, yaw)\n        \n        target_pose = Pose()\n        target_pose.position.x = x\n        target_pose.position.y = y\n        target_pose.position.z = z\n        target_pose.orientation.x = qx\n        target_pose.orientation.y = qy\n        target_pose.orientation.z = qz\n        target_pose.orientation.w = qw\n        \n        print(f\"Planning to pose: x={x}, y={y}, z={z}, rpy(deg)=({roll_deg}, {pitch_deg}, {yaw_deg})\")\n        client.visualize_goal_pose(target_pose)\n        success = client.move_to_pose(target_pose)\n        \n        if success:\n            print(\"Movement completed successfully!\")\n        else:\n            print(\"Movement failed! Possibly in collision or unreachable.\")\n            \n    except Exception as e:\n        print(f\"Error: {e}\")\n        import traceback\n        traceback.print_exc()\n    finally:\n        rclpy.shutdown()\n\n\nif __name__ == '__main__':\n    main()\n"}\n{"instruction": "Write a ROS2 Python node named ex_fk.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "#!/usr/bin/env python3\n\"\"\"\nExample of computing Forward Kinematics.\n- ros2 run pymoveit2 ex_fk.py --ros-args -p joint_positions:=\"[1.57, -1.57, 0.0, -1.57, 0.0, 1.57, 0.7854]\"\n- ros2 run pymoveit2 ex_fk.py --ros-args -p joint_positions:=\"[1.57, -1.57, 0.0, -1.57, 0.0, 1.57, 0.7854]\" -p synchronous:=False\n\"\"\"\n\nfrom threading import Thread\n\nimport rclpy\nfrom rclpy.callback_groups import ReentrantCallbackGroup\nfrom rclpy.node import Node\n\nfrom pymoveit2 import MoveIt2, MoveIt2State\nfrom pymoveit2.robots import ur\n\n\ndef main():\n    rclpy.init()\n\n    # Create node for this example\n    node = Node(\"ex_fk\")\n\n    # Declare parameter for joint positions\n    node.declare_parameter(\n        \"joint_positions\",\n        [\n            0.0,\n            0.0,\n            0.0,\n            -0.7853981633974483,\n            0.0,\n            1.5707963267948966,\n            0.7853981633974483,\n        ],\n    )\n    node.declare_parameter(\"synchronous\", True)\n\n    # Create callback group that allows execution of callbacks in parallel without restrictions\n    callback_group = ReentrantCallbackGroup()\n\n    # Create MoveIt 2 interface\n    moveit2 = MoveIt2(\n        node=node,\n        joint_names=ur.joint_names(),\n        base_link_name=ur.base_link_name(),\n        end_effector_name=ur.end_effector_name(),\n        group_name=ur.MOVE_GROUP_ARM,\n        callback_group=callback_group,\n    )\n\n    # Spin the node in background thread(s) and wait a bit for initialization\n    executor = rclpy.executors.MultiThreadedExecutor(2)\n    executor.add_node(node)\n    executor_thread = Thread(target=executor.spin, daemon=True, args=())\n    executor_thread.start()\n    node.create_rate(1.0).sleep()\n\n    # Get parameters\n    joint_positions = node.get_parameter(\"joint_positions\").get_parameter_value().double_array_value\n    synchronous = node.get_parameter(\"synchronous\").get_parameter_value().bool_value\n\n    # Move to joint configuration\n    node.get_logger().info(f\"Computing FK for {{joint_positions: {list(joint_positions)}}}\")\n    retval = None\n    if synchronous:\n        retval = moveit2.compute_fk(joint_positions)\n    else:\n        future = moveit2.compute_fk_async(joint_positions)\n        if future is not None:\n            rate = node.create_rate(10)\n            while not future.done():\n                rate.sleep()\n            retval = moveit2.get_compute_fk_result(future)\n    if retval is None:\n        print(\"Failed.\")\n    else:\n        print(\"Succeeded. Result: \" + str(retval))\n\n    rclpy.shutdown()\n    executor_thread.join()\n    exit(0)\n\n\nif __name__ == \"__main__\":\n    main()\n"}\n{"instruction": "Write a ROS2 Python node named full_demo.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "#!/usr/bin/env python3\n\"\"\"\nA script to outline the fundamentals of the moveit_py motion planning API.\n\"\"\"\n\nimport time\n\n# generic ros libraries\nimport rclpy\nfrom rclpy.logging import get_logger\n\n# moveit python library\nfrom moveit.core.robot_state import RobotState\nfrom moveit.planning import (\n    MoveItPy,\n    MultiPipelinePlanRequestParameters,\n)\n\n\ndef plan_and_execute(\n    robot,\n    planning_component,\n    logger,\n    single_plan_parameters=None,\n    multi_plan_parameters=None,\n    sleep_time=0.0,\n):\n    \"\"\"Helper function to plan and execute a motion.\"\"\"\n    # plan to goal\n    logger.info(\"Planning trajectory\")\n    if multi_plan_parameters is not None:\n        plan_result = planning_component.plan(\n            multi_plan_parameters=multi_plan_parameters\n        )\n    elif single_plan_parameters is not None:\n        plan_result = planning_component.plan(\n            single_plan_parameters=single_plan_parameters\n        )\n    else:\n        plan_result = planning_component.plan()\n\n    # execute the plan\n    if plan_result:\n        logger.info(\"Executing plan\")\n        robot_trajectory = plan_result.trajectory\n        robot.execute(robot_trajectory, controllers=[])\n    else:\n        logger.error(\"Planning failed\")\n\n    time.sleep(sleep_time)\n\n\ndef main():\n\n    ###################################################################\n    # MoveItPy Setup\n    ###################################################################\n    rclpy.init()\n    logger = get_logger(\"moveit_py.pose_goal\")\n\n    # instantiate MoveItPy instance and get planning component\n    panda = MoveItPy(node_name=\"moveit_py\")\n\n    # --- ADD THIS BLOCK ---\n    logger.info(\"Waiting 3 seconds for controllers to warm up...\")\n    time.sleep(3.0) \n    # ----------------------\n\n\n    panda_arm = panda.get_planning_component(\"panda_arm\")\n    logger.info(\"MoveItPy instance created\")\n\n    ###########################################################################\n    # Plan 1 - set states with predefined string\n    ###########################################################################\n\n    # set plan start state using predefined state\n    panda_arm.set_start_state(configuration_name=\"ready\")\n\n    # set pose goal using predefined state\n    panda_arm.set_goal_state(configuration_name=\"extended\")\n\n    # plan to goal\n    plan_and_execute(panda, panda_arm, logger, sleep_time=3.0)\n\n    ###########################################################################\n    # Plan 2 - set goal state with RobotState object\n    ###########################################################################\n\n    # instantiate a RobotState instance using the current robot model\n    robot_model = panda.get_robot_model()\n    robot_state = RobotState(robot_model)\n\n    # randomize the robot state\n    robot_state.set_to_random_positions()\n\n    # set plan start state to current state\n    panda_arm.set_start_state_to_current_state()\n\n    # set goal state to the initialized robot state\n    logger.info(\"Set goal state to the initialized robot state\")\n    panda_arm.set_goal_state(robot_state=robot_state)\n\n    # plan to goal\n    plan_and_execute(panda, panda_arm, logger, sleep_time=3.0)\n\n    ###########################################################################\n    # Plan 3 - set goal state with PoseStamped message\n    ###########################################################################\n\n    # set plan start state to current state\n    panda_arm.set_start_state_to_current_state()\n\n    # set pose goal with PoseStamped message\n    from geometry_msgs.msg import PoseStamped\n\n    pose_goal = PoseStamped()\n    pose_goal.header.frame_id = \"panda_link0\"\n    pose_goal.pose.orientation.w = 1.0\n    pose_goal.pose.position.x = 0.28\n    pose_goal.pose.position.y = -0.2\n    pose_goal.pose.position.z = 0.5\n    panda_arm.set_goal_state(pose_stamped_msg=pose_goal, pose_link=\"panda_link8\")\n\n    # plan to goal\n    plan_and_execute(panda, panda_arm, logger, sleep_time=3.0)\n\n    ###########################################################################\n    # Plan 4 - set goal state with constraints\n    ###########################################################################\n\n    # set plan start state to current state\n    panda_arm.set_start_state_to_current_state()\n\n    # set constraints message\n    from moveit.core.kinematic_constraints import construct_joint_constraint\n\n    joint_values = {\n        \"panda_joint1\": -1.0,\n        \"panda_joint2\": 0.7,\n        \"panda_joint3\": 0.7,\n        \"panda_joint4\": -1.5,\n        \"panda_joint5\": -0.7,\n        \"panda_joint6\": 2.0,\n        \"panda_joint7\": 0.0,\n    }\n    robot_state.joint_positions = joint_values\n    joint_constraint = construct_joint_constraint(\n        robot_state=robot_state,\n        joint_model_group=panda.get_robot_model().get_joint_model_group(\"panda_arm\"),\n    )\n    panda_arm.set_goal_state(motion_plan_constraints=[joint_constraint])\n\n    # plan to goal\n    plan_and_execute(panda, panda_arm, logger, sleep_time=3.0)\n\n    ###########################################################################\n    # Plan 5 - Planning with Multiple Pipelines simultaneously\n    ###########################################################################\n\n    # set plan start state to current state\n    panda_arm.set_start_state_to_current_state()\n\n    # set pose goal with PoseStamped message\n    panda_arm.set_goal_state(configuration_name=\"ready\")\n\n    # initialise multi-pipeline plan request parameters\n    multi_pipeline_plan_request_params = MultiPipelinePlanRequestParameters(\n        panda, [\"ompl_rrtc\", \"pilz_lin\", \"chomp_planner\"]\n    )\n\n    # plan to goal\n    plan_and_execute(\n        panda,\n        panda_arm,\n        logger,\n        multi_plan_parameters=multi_pipeline_plan_request_params,\n        sleep_time=3.0,\n    )\n\n\nif __name__ == \"__main__\":\n    main()\n"}\n{"instruction": "Write a ROS2 Python node named task2atfl.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "#!/usr/bin/env python3\n\nfrom os import path\nfrom threading import Thread\n\nimport rclpy\nfrom rclpy.callback_groups import ReentrantCallbackGroup\nfrom rclpy.node import Node\n\nfrom pymoveit2 import MoveIt2\nfrom pymoveit2.robots import ur5\n\nimport math\nimport numpy as np\nimport time\nfrom std_srvs.srv import Trigger\nfrom tf2_ros import TransformException\nfrom tf2_ros.buffer import Buffer\nfrom tf2_ros.transform_listener import TransformListener\nfrom geometry_msgs.msg import TransformStamped\nfrom scipy.spatial.transform import Rotation as R\nfrom linkattacher_msgs.srv import AttachLink, DetachLink\nfrom geometry_msgs.msg import TwistStamped\nfrom ros2_interfaces_cpp.msg import List\n\n\n\n##################### FUNCTION DEFINITIONS #######################\n\ndef quaternion_from_euler(roll, pitch, yaw):\n    \"\"\"\n    Convert an Euler angle to a quaternion.\n    \n    Input\n        :param roll: The roll (rotation around x-axis) angle in radians.\n        :param pitch: The pitch (rotation around y-axis) angle in radians.\n        :param yaw: The yaw (rotation around z-axis) angle in radians.\n    \n    Output\n        :return qx, qy, qz, qw: The orientation in quaternion [x,y,z,w] format\n    \"\"\"\n\n    ############ Function VARIABLES ############\n    qx = 0\n    qy = 0 \n    qz = 0 \n    qw = 0\n\n    ############ Code ############\n\n    qx = np.sin(roll/2) * np.cos(pitch/2) * np.cos(yaw/2) - np.cos(roll/2) * np.sin(pitch/2) * np.sin(yaw/2)\n    qy = np.cos(roll/2) * np.sin(pitch/2) * np.cos(yaw/2) + np.sin(roll/2) * np.cos(pitch/2) * np.sin(yaw/2)\n    qz = np.cos(roll/2) * np.cos(pitch/2) * np.sin(yaw/2) - np.sin(roll/2) * np.sin(pitch/2) * np.cos(yaw/2)\n    qw = np.cos(roll/2) * np.cos(pitch/2) * np.cos(yaw/2) + np.sin(roll/2) * np.sin(pitch/2) * np.sin(yaw/2)\n    \n    return [qx, qy, qz, qw]\n\nimport math\n\ndef euler_from_quaternion(quat):\n        \"\"\"\n        Convert a quaternion into euler angles (roll, pitch, yaw)\n        roll is rotation around x in radians (counterclockwise)\n        pitch is rotation around y in radians (counterclockwise)\n        yaw is rotation around z in radians (counterclockwise)\n        \"\"\"\n        x = quat[0]\n        y = quat[1]\n        z = quat[2]\n        w = quat[3]\n        \n        t0 = +2.0 * (w * x + y * z)\n        t1 = +1.0 - 2.0 * (x * x + y * y)\n        roll_x = math.atan2(t0, t1)\n     \n        t2 = +2.0 * (w * y - z * x)\n        t2 = +1.0 if t2 > +1.0 else t2\n        t2 = -1.0 if t2 < -1.0 else t2\n        pitch_y = math.asin(t2)\n     \n        t3 = +2.0 * (w * z + x * y)\n        t4 = +1.0 - 2.0 * (y * y + z * z)\n        yaw_z = math.atan2(t3, t4)\n\n        euler_angles = [roll_x, pitch_y, yaw_z]\n        \n        return euler_angles # in radians\n\n\ndef calculate_intermediate_position(position, quat_xyzw):\n    # Calculate the box's z-axis in the base_link frame\n    box_z_axis = [0, 0, 1]  # Assuming the box's z-axis is the same for all boxes\n    # Rotate the box's z-axis by its orientation\n    r = R.from_quat(quat_xyzw)\n    rotated_box_z_axis = r.apply(box_z_axis)\n    # Calculate the intermediate position as 0.2 meters in the negative direction of the rotated box's z-axis\n    intermediate_position = [\n        position[0] - 0.15 * rotated_box_z_axis[0],\n        position[1] - 0.15 * rotated_box_z_axis[1],\n        position[2] - 0.15 * rotated_box_z_axis[2]\n    ]\n    return intermediate_position\n\n\nclass move_boxes(Node):\n\n    def __init__(self):\n        super().__init__('task2a')\n\n        self.move_ur5_sub = self.create_subscription(List, '/obj_frames', self.move_ur5, 10)\n        self.servo_publisher = self.create_publisher(TwistStamped, '/servo_node/delta_twist_cmds', 10)\n        self.twist_msg = TwistStamped()\n\n        #Configuring the Path of the Mesh file \n        DEFAULT_EXAMPLE_MESH = path.join(\n            path.dirname(path.realpath(__file__)), \"assets\", \"rack.stl\"\n        )\n\n        ARM_BASE_MESH = path.join(\n            path.dirname(path.realpath(__file__)), \"assets\", \"arm_base.stl\"\n        )\n\n        TABLE_MESH = path.join(\n            path.dirname(path.realpath(__file__)), \"assets\", \"table.stl\"\n        )\n\n\n        # Create callback group that allows execution of callbacks in parallel without restrictions\n        self.callback_group = ReentrantCallbackGroup()\n\n        # Create MoveIt 2 interface\n        self.moveit2 = MoveIt2(\n            node=self,\n            joint_names=ur5.joint_names(),\n            base_link_name=ur5.base_link_name(),\n            end_effector_name=ur5.end_effector_name(),\n            execute_via_moveit=True,\n            group_name=ur5.MOVE_GROUP_ARM,\n            callback_group=self.callback_group,\n        )\n        \n\n\n\n        # Get parameters\n        self.filepath = \"\"\n        self.action = \"add\"\n        self.position_rack_front = [0.57, 0.05, -0.56]\n        self.quat_xyzw_rack_front = quaternion_from_euler(np.pi, np.pi, 0.0)\n        self.position_rack_left = [0.29, 0.66, -0.56]\n        self.quat_xyzw_rack_left = quaternion_from_euler(0.0, 0.0, np.pi/2)\n        self.position_rack_right = [0.29, -0.66, -0.56]\n        self.quat_xyzw_rack_right = quaternion_from_euler(0.0, 0.0, np.pi/2)\n        self.position_arm_base = [-0.2, 0.00, -0.58]\n        self.quat_xyzw_arm_base = quaternion_from_euler(0.0, 0.0, np.pi)\n        self.position_table = [-0.8, 0.00, -0.60]\n        self.quat_xyzw_table = quaternion_from_euler(0.0, 0.0, 0.0)\n\n        self.tf_buffer = Buffer()\n        self.tf_listener = TransformListener(self.tf_buffer, self)\n\n        self.position_initial = [0.176, 0.108, 0.470]\n        self.quat_xyzw_initial = quaternion_from_euler(np.pi/2, 0.0, np.pi/2)\n\n        self.position_intermediate = [0.0, 0.10, 0.68]\n        self.quat_xyzw_intermediate = quaternion_from_euler(np.pi/2, 0.0, np.pi/2)\n\n        self.position_d = [-0.814, 0.108, 0.312]\n        self.quat_xyzw_d = quaternion_from_euler(np.pi, np.pi/2, 0.0)\n        self.joint_positions_center = [0.00, -2.39, 2.40, -3.15, -1.58, 3.15]\n        self.joint_positions_d = [0.00, -2.39, -0.50, -3.15, -1.58, 3.15]\n        self.joint_positions_d2 = [0.334, -2.39, -0.50, -3.15, -1.58, 3.15]\n        self.position_d2 = [0.15, 0.108, 0.6]\n        self.quat_xyzw_d2 = quaternion_from_euler(np.pi/2, 0.0, np.pi/2)\n\n        self.cartesian = False\n\n        # Use the default example mesh if invalid\n        if not self.filepath:\n            self.get_logger().info(f\"Using the default example mesh file\")\n            self.filepath = DEFAULT_EXAMPLE_MESH\n            self.filepath_arm_base = ARM_BASE_MESH\n            self.filepath_table = TABLE_MESH\n\n        # Make sure the mesh file exists\n        if not path.exists(self.filepath):\n            self.get_logger().error(f\"File '{self.filepath}' does not exist\")\n            rclpy.shutdown()\n            exit(1)\n\n        # Determine ID of the collision mesh\n        self.mesh_id_front = \"_\".join(path.basename(self.filepath).split(\".\")) + \"_front\"\n        self.mesh_id_left = \"_\".join(path.basename(self.filepath).split(\".\")) + \"_left\"\n        self.mesh_id_right = \"_\".join(path.basename(self.filepath).split(\".\")) + \"_right\"\n        self.mesh_id_arm_base = \"_\".join(path.basename(self.filepath_arm_base).split(\".\"))\n        self.mesh_id_table = \"_\".join(path.basename(self.filepath_table).split(\".\"))\n\n        #To get the accuracy in Collision \n        for i in range(2):\n            if \"add\" == self.action:\n            \n                # Add collision mesh rack_front\n                self.get_logger().info(\n                    f\"Adding collision mesh '{self.filepath}' {{position: {list(self.position_rack_front)}, quat_xyzw: {list(self.quat_xyzw_rack_front)}}}\"\n                )\n\n                self.moveit2.add_collision_mesh(\n                    filepath=self.filepath, id=self.mesh_id_front, position=self.position_rack_front, quat_xyzw=self.quat_xyzw_rack_front, frame_id=ur5.base_link_name()\n                )\n\n                # Add collision mesh rack_left\n                self.get_logger().info(\n                    f\"Adding collision mesh '{self.filepath}' {{position: {list(self.position_rack_left)}, quat_xyzw: {list(self.quat_xyzw_rack_left)}}}\"\n                )\n                self.moveit2.add_collision_mesh(\n                    filepath=self.filepath, id=self.mesh_id_left, position=self.position_rack_left, quat_xyzw=self.quat_xyzw_rack_left, frame_id=ur5.base_link_name()\n                )\n                \n                # Add collision mesh rack_right\n                self.get_logger().info(\n                    f\"Adding collision mesh '{self.filepath}' {{position: {list(self.position_rack_right)}, quat_xyzw: {list(self.quat_xyzw_rack_right)}}}\"\n                )\n                self.moveit2.add_collision_mesh(\n                    filepath=self.filepath, id=self.mesh_id_right, position=self.position_rack_right, quat_xyzw=self.quat_xyzw_rack_right, frame_id=ur5.base_link_name()\n                )\n\n                # Add collision mesh arm_base\n                self.get_logger().info(\n                    f\"Adding collision mesh '{self.filepath_arm_base}' {{position: {list(self.position_arm_base)}, quat_xyzw: {list(self.quat_xyzw_arm_base)}}}\"\n                )\n                self.moveit2.add_collision_mesh(\n                    filepath=self.filepath_arm_base, id=self.mesh_id_arm_base, position=self.position_arm_base, quat_xyzw=self.quat_xyzw_arm_base, frame_id=ur5.base_link_name()\n                )\n\n                # Add collision mesh table\n                self.get_logger().info(\n                    f\"Adding collision mesh '{self.filepath_table}' {{position: {list(self.position_table)}, quat_xyzw: {list(self.quat_xyzw_table)}}}\"\n                )\n                self.moveit2.add_collision_mesh(\n                    filepath=self.filepath_table, id=self.mesh_id_table, position=self.position_table, quat_xyzw=self.quat_xyzw_table, frame_id=ur5.base_link_name()\n                )\n\n            else:\n                # Remove collision mesh\n                self.get_logger().info(f\"Removing collision mesh with ID '{self.mesh_id_front, self.mesh_id_left, self.mesh_id_right}'\")\n                self.moveit2.remove_collision_mesh(id=self.mesh_id_front)\n                self.moveit2.remove_collision_mesh(id=self.mesh_id_left)\n                self.moveit2.remove_collision_mesh(id=self.mesh_id_right)\n                self.moveit2.remove_collision_mesh(id=self.mesh_id_arm_base)\n                self.moveit2.remove_collision_mesh(id=self.mesh_id_table)\n\n        # Call on_timer function every second\n        #self.timer = self.create_timer(1.0, self.move_ur5)\n        \n        #self.move_ur5()\n        #Stopping the Motion\n        #rclpy.shutdown()\n        #exit(0)\n\n    def servo_publish_rotation(self, angles):\n        self.twist_msg.header.stamp = self.get_clock().now().to_msg()\n        self.twist_msg.twist.linear.x = 0.0\n        self.twist_msg.twist.linear.y = 0.0\n        self.twist_msg.twist.linear.z = 0.0\n        self.twist_msg.twist.angular.x = angles[0]\n        self.twist_msg.twist.angular.y = angles[1]\n        self.twist_msg.twist.angular.z = angles[2]\n        self.servo_publisher.publish(self.twist_msg)\n\n    def servo_publish(self, distance):\n        self.twist_msg.header.stamp = self.get_clock().now().to_msg()\n        self.twist_msg.twist.linear.x = distance[0]\n        self.twist_msg.twist.linear.y = distance[1]\n        self.twist_msg.twist.linear.z = distance[2]\n        self.twist_msg.twist.angular.x = 0.0\n        self.twist_msg.twist.angular.y = 0.0\n        self.twist_msg.twist.angular.z = 0.0\n        self.servo_publisher.publish(self.twist_msg)\n\n    def move_ur5(self, msg):\n        self.obj_frames = msg.data\n        print(\"Received Frames: \", self.obj_frames)\n        from_frame_rel = 'base_link'\n        to_frame_rel = 'obj_1'\n\n        # Spin the node in background thread(s)\n        executor = rclpy.executors.MultiThreadedExecutor(2)\n        executor.add_node(self)\n        executor_thread = Thread(target=executor.spin, daemon=True, args=())\n        executor_thread.start()\n\n        print(\"Ready to move\")\n\n        service_client = self.create_client(Trigger, '/servo_node/start_servo')\n\n        while not service_client.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info('MoveIt Servo start service not available, waiting...')\n        \n        self.trigger_request = Trigger.Request()\n        self.future = service_client.call_async(self.trigger_request)\n\n        gripper_control = self.create_client(AttachLink, '/GripperMagnetON')\n        gripper_control_detach = self.create_client(DetachLink, '/GripperMagnetOFF')\n        # Lookup transform between base_link and obj frame\n        self.drop_change = False\n        for child_frame in self.obj_frames:\n            self.future = service_client.call_async(self.trigger_request)\n            box_name = \"box\" + child_frame[4:]\n            try:\n                transform = self.tf_buffer.lookup_transform(\n                    'base_link',\n                    child_frame,\n                    rclpy.time.Time())\n                \n                self.get_logger().info(\n                    f'Transform from {to_frame_rel} to {from_frame_rel} and {transform.transform._translation}')\n            except TransformException as ex:\n                self.get_logger().info(\n                    f'Could not transform {to_frame_rel} to {from_frame_rel}: {ex}')\n                continue\n            \n            self.position = [transform.transform.translation.x, transform.transform.translation.y, transform.transform.translation.z]\n            self.quat_xyzw = [transform.transform.rotation.x, transform.transform.rotation.y, transform.transform.rotation.z, transform.transform.rotation.w]\n            self.euler_angles = euler_from_quaternion(self.quat_xyzw)\n            \n            self.position_intermediate = calculate_intermediate_position(self.position, self.quat_xyzw)\n\n\n\n\n\n            '''# Lookup transform between base_link and ee frame\n            try:\n                transform = self.tf_buffer.lookup_transform('base_link', 'tool0', rclpy.time.Time())\n            except (self.tf2_ros.LookupException, self.tf2_ros.ConnectivityException, self.tf2_ros.ExtrapolationException):\n                self.get_logger().error(f\"Failed to lookup transform from base_link to {child_frame}\")\n                continue\n\n            # Publish the TF between object frame and base_link\n            self.ee_position = [transform.transform.translation.x, transform.transform.translation.y, transform.transform.translation.z]\n            self.ee_orientation = [transform.transform.rotation.x, transform.transform.rotation.y, transform.transform.rotation.z, transform.transform.rotation.w]\n            self.ee_euler_angles = euler_from_quaternion(self.ee_orientation)\n            print(\"End Effector Position\", self.ee_position)\n\n            self.distance = [\n                self.position_intermediate[0] - self.ee_position[0],\n                self.position_intermediate[1] - self.ee_position[1],\n                self.position_intermediate[2] - self.ee_position[2]\n            ] \n            print(\"Distance: \",self.distance)\n\n            self.future = service_client.call_async(self.trigger_request)\n\n            while abs(self.distance[0]) > 0.008 or abs(self.distance[1]) > 0.01 or abs(self.distance[2]) > 0.015:\n                while True:\n                    try:\n                        transform = self.tf_buffer.lookup_transform('base_link', 'tool0', rclpy.time.Time())\n                        print(\"Got the transform!\")\n                        break\n                    except (self.tf2_ros.LookupException, self.tf2_ros.ConnectivityException, self.tf2_ros.ExtrapolationException):\n                        self.get_logger().error(f\"Failed to lookup transform from base_link to {child_frame}\")\n                        print(\"Waiting for transform!\")\n\n                self.ee_position = [transform.transform.translation.x, transform.transform.translation.y, transform.transform.translation.z]\n                print(\"End Effector Location \", self.ee_position)\n\n                self.distance = [\n                    self.position_intermediate[0] - self.ee_position[0],\n                    self.position_intermediate[1] - self.ee_position[1],\n                    self.position_intermediate[2] - self.ee_position[2]\n                ] \n                print(\"Distance: \",self.distance)\n                self.servo_publish(self.distance)'''\n\n            # Move to Position Intermediate\n            self.get_logger().info(\n                f\"Moving to {{position: {list(self.position_intermediate)}, quat_xyzw: {list(self.quat_xyzw)}}}\"\n            )\n            self.moveit2.move_to_pose(position=self.position_intermediate, quat_xyzw=self.quat_xyzw, cartesian=self.cartesian)\n            self.moveit2.wait_until_executed()\n\n            '''# Lookup transform between base_link and ee frame\n            try:\n                transform = self.tf_buffer.lookup_transform('base_link', 'tool0', rclpy.time.Time())\n            except (self.tf2_ros.LookupException, self.tf2_ros.ConnectivityException, self.tf2_ros.ExtrapolationException):\n                self.get_logger().error(f\"Failed to lookup transform from base_link to {child_frame}\")\n                continue\n\n            # Publish the TF between object frame and base_link\n            self.ee_position = [transform.transform.translation.x, transform.transform.translation.y, transform.transform.translation.z]\n            self.ee_orientation = [transform.transform.rotation.x, transform.transform.rotation.y, transform.transform.rotation.z, transform.transform.rotation.w]\n            self.ee_euler_angles = euler_from_quaternion(self.ee_orientation)\n            print(\"End Effector Orientation\", self.ee_orientation)\n\n            self.angles = [\n                self.euler_angles[0] - self.ee_euler_angles[0],\n                self.euler_angles[1] - self.ee_euler_angles[1],\n                self.euler_angles[2] - self.ee_euler_angles[2]\n            ]            \n            print(\"Angles \",self.angles)\n\n            self.future = service_client.call_async(self.trigger_request)\n\n            while abs(self.angles[0]) > 0.008 or abs(self.angles[1]) > 0.008 or abs(self.angles[2]) > 0.008:\n                while True:\n                    try:\n                        transform = self.tf_buffer.lookup_transform('base_link', 'tool0', rclpy.time.Time())\n                        print(\"Got the transform!\")\n                        break\n                    except (self.tf2_ros.LookupException, self.tf2_ros.ConnectivityException, self.tf2_ros.ExtrapolationException):\n                        self.get_logger().error(f\"Failed to lookup transform from base_link to {child_frame}\")\n                        print(\"Waiting for transform!\")\n\n                self.ee_position = [transform.transform.translation.x, transform.transform.translation.y, transform.transform.translation.z]\n                self.ee_orientation = [transform.transform.rotation.x, transform.transform.rotation.y, transform.transform.rotation.z, transform.transform.rotation.w]\n                self.ee_euler_angles = euler_from_quaternion(self.ee_orientation)\n                print(\"End Effector Orientation\", self.ee_orientation)\n\n                self.angles = [\n                    self.euler_angles[0] - self.ee_euler_angles[0],\n                    self.euler_angles[1] - self.ee_euler_angles[1],\n                    self.euler_angles[2] - self.ee_euler_angles[2]\n                ]              \n                print(\"Angles \",self.angles)\n\n                self.servo_publish_rotation(self.angles)'''\n            # Lookup transform between base_link and ee frame\n            try:\n                transform = self.tf_buffer.lookup_transform('base_link', 'tool0', rclpy.time.Time())\n            except (self.tf2_ros.LookupException, self.tf2_ros.ConnectivityException, self.tf2_ros.ExtrapolationException):\n                self.get_logger().error(f\"Failed to lookup transform from base_link to {child_frame}\")\n                continue\n\n            # Publish the TF between object frame and base_link\n            self.ee_position = [transform.transform.translation.x, transform.transform.translation.y, transform.transform.translation.z]\n            self.ee_orientation = [transform.transform.rotation.x, transform.transform.rotation.y, transform.transform.rotation.z, transform.transform.rotation.w]\n            self.ee_euler_angles = euler_from_quaternion(self.ee_orientation)\n            print(\"End Effector Position\", self.ee_position)\n\n            self.distance = [\n                self.position[0] - self.ee_position[0],\n                self.position[1] - self.ee_position[1],\n                self.position[2] - self.ee_position[2]\n            ] \n            print(\"Distance: \",self.distance)\n\n            self.future = service_client.call_async(self.trigger_request)\n\n            while abs(self.distance[0]) > 0.008 or abs(self.distance[1]) > 0.01 or abs(self.distance[2]) > 0.015:\n                while True:\n                    try:\n                        transform = self.tf_buffer.lookup_transform('base_link', 'tool0', rclpy.time.Time())\n                        print(\"Got the transform!\")\n                        break\n                    except (self.tf2_ros.LookupException, self.tf2_ros.ConnectivityException, self.tf2_ros.ExtrapolationException):\n                        self.get_logger().error(f\"Failed to lookup transform from base_link to {child_frame}\")\n                        print(\"Waiting for transform!\")\n\n                self.ee_position = [transform.transform.translation.x, transform.transform.translation.y, transform.transform.translation.z]\n                print(\"End Effector Location \", self.ee_position)\n\n                self.distance = [\n                    self.position[0] - self.ee_position[0],\n                    self.position[1] - self.ee_position[1],\n                    self.position[2] - self.ee_position[2]\n                ] \n                print(\"Distance: \",self.distance)\n                self.servo_publish(self.distance)\n\n            # Move to Position of the Box\n            '''self.get_logger().info(\n                f\"Moving to {{position: {list(self.position)}, quat_xyzw: {list(self.quat_xyzw)}}}\"\n            )\n            self.moveit2.move_to_pose(position=self.position, quat_xyzw=self.quat_xyzw, cartesian=self.cartesian)\n            print(\"Executing\")\n            self.moveit2.wait_until_executed()\n            print(\"Executed\")'''\n\n\n            while not gripper_control.wait_for_service(timeout_sec=1.0):\n                self.get_logger().info('EEF service not available, waiting again...')\n\n            req = AttachLink.Request()\n            req.model1_name =  box_name    \n            req.link1_name  = 'link'       \n            req.model2_name =  'ur5'       \n            req.link2_name  = 'wrist_3_link'  \n\n            gripper_control.call_async(req)\n\n            try:\n                transform = self.tf_buffer.lookup_transform('base_link', 'tool0', rclpy.time.Time())\n            except (self.tf2_ros.LookupException, self.tf2_ros.ConnectivityException, self.tf2_ros.ExtrapolationException):\n                self.get_logger().error(f\"Failed to lookup transform from base_link to {child_frame}\")\n                continue\n\n            # Publish the TF between object frame and base_link\n            self.ee_position = [transform.transform.translation.x, transform.transform.translation.y, transform.transform.translation.z]\n            print(\"End Effector Location \", self.ee_position)\n\n            self.distance = [\n                self.position_intermediate[0] - self.ee_position[0],\n                self.position_intermediate[1] - self.ee_position[1],\n                self.position_intermediate[2] - self.ee_position[2]\n            ]            \n            print(\"Distance \",self.distance)\n\n            self.future = service_client.call_async(self.trigger_request)\n\n            end_time = time.time() + 10\n            while abs(self.distance[0]) > 0.01 or abs(self.distance[1]) > 0.01 or abs(self.distance[2]) > 0.015 and time.time()<end_time:\n                while True:\n                    try:\n                        transform = self.tf_buffer.lookup_transform('base_link', 'tool0', rclpy.time.Time())\n                        print(\"Got the transform!\")\n                        break\n                    except (self.tf2_ros.LookupException, self.tf2_ros.ConnectivityException, self.tf2_ros.ExtrapolationException):\n                        self.get_logger().error(f\"Failed to lookup transform from base_link to {child_frame}\")\n                        print(\"Waiting for transform!\")\n\n                self.ee_position = [transform.transform.translation.x, transform.transform.translation.y, transform.transform.translation.z]\n                print(\"End Effector Location \", self.ee_position)\n\n                self.distance = [\n                    self.position_intermediate[0] - self.ee_position[0],\n                    self.position_intermediate[1] - self.ee_position[1],\n                    self.position_intermediate[2] - self.ee_position[2]\n                ]    \n\n                print(self.distance)\n                self.servo_publish(self.distance)\n\n            # Move to Position D\n            '''self.get_logger().info(\n                f\"Moving to {{position: {list(self.position_d2)}, quat_xyzw: {list(self.quat_xyzw_d2)}}}\"\n            )\n            self.moveit2.move_to_pose(position=self.position_d2, quat_xyzw=self.quat_xyzw, cartesian=self.cartesian)\n            self.moveit2.wait_until_executed()'''\n\n            # Move to Position Center\n            self.get_logger().info(\n                f\"Moving to {{position: {list(self.position_d2)}, quat_xyzw: {list(self.quat_xyzw_d2)}}}\"\n            )\n            self.moveit2.move_to_configuration(self.joint_positions_center)\n            self.moveit2.wait_until_executed()\n\n\n            if not self.drop_change:\n                # Move to Position D\n                self.get_logger().info(\n                    f\"Moving to {{position: {list(self.position_d)}, quat_xyzw: {list(self.quat_xyzw_d)}}}\"\n                )\n                #self.moveit2.move_to_pose(position=self.position_d, quat_xyzw=self.quat_xyzw_d, cartesian=self.cartesian)\n                self.moveit2.move_to_configuration(self.joint_positions_d2)\n                self.moveit2.wait_until_executed()\n\n                self.drop_change = True\n            else:\n                # Move to Position D\n                self.get_logger().info(\n                    f\"Moving to {{position: {list(self.position_d)}, quat_xyzw: {list(self.quat_xyzw_d)}}}\"\n                )\n                #self.moveit2.move_to_pose(position=self.position_d, quat_xyzw=self.quat_xyzw_d, cartesian=self.cartesian)\n                self.moveit2.move_to_configuration(self.joint_positions_d)\n                self.moveit2.wait_until_executed()\n\n\n            while not gripper_control.wait_for_service(timeout_sec=1.0):\n                self.get_logger().info('EEF service not available, waiting again...')\n\n            req_detach = DetachLink.Request()\n            req_detach.model1_name =  box_name    \n            req_detach.link1_name  = 'link'       \n            req_detach.model2_name =  'ur5'       \n            req_detach.link2_name  = 'wrist_3_link'  \n\n            gripper_control_detach.call_async(req_detach)\n\n            # Move to Position Center\n            self.get_logger().info(\n                f\"Moving to {{position: {list(self.position_d2)}, quat_xyzw: {list(self.quat_xyzw_d2)}}}\"\n            )\n            self.moveit2.move_to_configuration(self.joint_positions_center)\n            self.moveit2.wait_until_executed()\n\n        # Move to Initial Position\n        '''self.get_logger().info(\n            f\"Moving to {{position: {list(self.position_initial)}, quat_xyzw: {list(self.quat_xyzw_initial)}}}\"\n        )\n        self.moveit2.move_to_pose(position=self.position_initial, quat_xyzw=self.quat_xyzw_initial, cartesian=self.cartesian)\n        self.moveit2.wait_until_executed()\n        return'''\n        \n\n    def on_timer(self):\n        # Store frame names in variables that will be used to\n        # compute transformations\n        from_frame_rel = 'base_link'\n        to_frame_rel = 'obj_1'\n\n        try:\n            t = self.tf_buffer.lookup_transform(\n                'base_link',\n                'obj_1',\n                rclpy.time.Time())\n            \n            self.get_logger().info(\n                f'Transform from {to_frame_rel} to {from_frame_rel} and {t.transform._translation}')\n        except TransformException as ex:\n            self.get_logger().info(\n                f'Could not transform {to_frame_rel} to {from_frame_rel}: {ex}')\n            return\n\n\ndef main():\n    rclpy.init()    \n\n    # Creating ROS node\n    node = rclpy.create_node('task_2a')  \n\n    # Logging the Information\n    #node.get_logger().info('Node created: task_2a') \n    move_boxes_class = move_boxes()\n\n\n    rclpy.spin(move_boxes_class)\n\n    move_boxes_class.destroy_node()\n\n    rclpy.shutdown()\n\n\nif __name__ == '__main__':\n    '''\n    Description:    If the python interpreter is running that module (the source file) as the main program, \n                    it sets the special __name__ variable to have a value “__main__”. \n                    If this file is being imported from another module, __name__ will be set to the module’s name.\n    '''\n    main()                                     \n"}\n{"instruction": "Write a ROS2 Python node named panda_control.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "#!/usr/bin/env python3\n\"\"\"\nFR3 Robot Controller using ROS2 and MoveIt (ZMQ Client Version)\n\"\"\"\n\nimport rclpy\nimport sys\nimport zmq\nimport pickle\n\nimport sensor_msgs\nfrom utils.transform import Transform, reorder_pose_list, Rotation, matrix_to_euler_angles\nfrom rclpy.node import Node\nfrom rclpy.action import ActionClient\n\nfrom sensor_msgs.msg import JointState\n\nimport time\nfrom typing import List, Optional\n\nfrom franka_msgs.action import Grasp, ErrorRecovery, Move\nfrom franka_msgs.msg import FrankaRobotState, GraspEpsilon, Errors\nfrom franka_msgs.srv import SetForceTorqueCollisionBehavior\n\nfrom rclpy.callback_groups import ReentrantCallbackGroup\n# from utils_exp import vis # 可选\nimport numpy as np\n\n# 注意：Client 端不需要导入 curobo 的库，除非你需要 Mesh 类的辅助函数来生成 dict\n# 这里我们假设 Mesh 数据处理逻辑稍作修改，或者保留 Mesh 引用仅用于数据结构转换\nfrom curobo.geom.types import Mesh, WorldConfig \n\nfrom utils.control import calculate_velocity\nimport roboticstoolbox as rtb\nfrom nav_msgs.msg import Path\nfrom std_msgs.msg import Header\nfrom geometry_msgs.msg import PoseStamped\n\n# --- 新增：ZMQ 客户端类 ---\nclass MotionPlannerClient:\n    def __init__(self, host='localhost', port=5556):\n        self.context = zmq.Context()\n        self.socket = self.context.socket(zmq.REQ)\n        self.socket.connect(f\"tcp://{host}:{port}\")\n        print(f\"[MotionClient] Connected to Motion Server at {port}\")\n        \n        # 简单的 Ping 测试\n        try:\n            self.socket.send(pickle.dumps({'cmd': 'ping'}))\n            # 设置超时防止卡死\n            if self.socket.poll(2000): # 2s timeout\n                self.socket.recv()\n                print(\"[MotionClient] Server online.\")\n            else:\n                print(\"[MotionClient] WARNING: Server not responding!\")\n        except Exception as e:\n            print(f\"[MotionClient] Init error: {e}\")\n\n    def update_world(self, cuboids=None, pcl=None):\n        \"\"\"\n        发送环境信息给 Server\n        :param cuboids: dict, e.g. {'table': {'dims':..., 'pose':...}}\n        :param pcl: numpy array (N, 3), 原始点云数据\n        \"\"\"\n        # 预处理：如果 cuboids 嵌套在 'cuboid' 键下，提取出来，因为 Server 端会重新组装\n        cuboids_data = cuboids\n        if cuboids is not None and 'cuboid' in cuboids:\n            cuboids_data = cuboids['cuboid']\n\n        req = {\n            'cmd': 'update_world',\n            'cuboids': cuboids_data,\n            'pcl': pcl # 直接发送 Numpy 数组，pickle 会自动处理\n        }\n        \n        try:\n            self.socket.send(pickle.dumps(req))\n            resp = pickle.loads(self.socket.recv())\n            return resp.get('success', False)\n        except Exception as e:\n            print(f\"[MotionClient] Update World Error: {e}\")\n            self._reset_socket()\n            return False\n\n    def plan(self, start_joint_state, target_pose, plan_config=None):\n        \"\"\"\n        返回: (waypoints_np, success)\n        \"\"\"\n        req = {\n            'cmd': 'plan',\n            'start': start_joint_state,\n            'target': target_pose,\n            # plan_config 暂不支持传输复杂对象，Server 端使用默认\n        }\n        \n        try:\n            self.socket.send(pickle.dumps(req))\n            resp = pickle.loads(self.socket.recv())\n            \n            success = resp.get('success', False)\n            waypoints = resp.get('waypoints', None)\n            \n            return waypoints, success\n            \n        except Exception as e:\n            print(f\"[MotionClient] Plan Error: {e}\")\n            self._reset_socket()\n            return None, False\n\n    def _reset_socket(self):\n        print(\"[MotionClient] Resetting socket...\")\n        self.socket.close()\n        self.context.term()\n        self.context = zmq.Context()\n        self.socket = self.context.socket(zmq.REQ)\n        self.socket.connect(\"tcp://localhost:5556\")\n\n\nclass PandaCommander(Node):\n    \"\"\"\n    FR3 Robot Controller with ZMQ Motion Planner\n    \"\"\"\n    \n    def __init__(self, robot_name: str = \"fr3\"):\n        super().__init__('fr3_controller')\n        self.callback_group = ReentrantCallbackGroup()\n        \n        # Robot parameters\n        self.robot_name = robot_name\n        self.joint_names = [\n            f'{robot_name}_joint1', f'{robot_name}_joint2', f'{robot_name}_joint3', \n            f'{robot_name}_joint4', f'{robot_name}_joint5', f'{robot_name}_joint6', \n            f'{robot_name}_joint7'\n        ]\n        \n        # self.T_body_tcp = Transform.from_dict({\"rotation\": [0.0, 0.0, 0.0, 1.0], \"translation\": [0.0, 0.0, -0.05]})\n        # self.T_tcp_body = self.T_body_tcp.inverse()\n        # self.T_tcp_link8 = self.T_body_tcp # Alias\n\n        self.T_link8_tcp = Transform.from_dict({\"rotation\": [0.0, 0.0, 0.0, 1.0], \"translation\": [0.0, 0.0, 0.05]})\n        self.T_tcp_link8 = self.T_link8_tcp.inverse()\n\n\n        # wrench \n        self.wrench_raw = np.zeros(6)\n        self.wrench_baseline = np.zeros(6)\n        self.wrench_filtered = np.zeros(6)\n        self.baseline_samples = []\n        self.baseline_ready = False\n        self.baseline_sample_count = 100        # 前100帧用于基线估计\n        self.ema_alpha = 0.02                   # 低通滤波系数（慢）\n        self.contact_hysteresis_count = 3       # 连续帧数确认接触\n        self._contact_count = 0\n        \n        # --- ROS Subs/Pubs ---\n        self.joint_state_sub = self.create_subscription(JointState, '/joint_states', self.joint_state_callback, 1, callback_group=self.callback_group)\n        self.joint_velo_pub = self.create_publisher(JointState, '/joint_velocity_controller/joint_velocity', 1, callback_group=self.callback_group)\n        self.predicted_path_pub = self.create_publisher(Path, '/planned_trajectory', 1, callback_group=self.callback_group)\n        self.force_sub = self.create_subscription(FrankaRobotState, \"/franka_robot_state_broadcaster/robot_state\", self.force_callback, 10, callback_group=self.callback_group)\n        self.robot_state_sub = self.create_subscription(FrankaRobotState, 'franka_robot_state_broadcaster/robot_state', self.robot_state_cb, 10, callback_group=self.callback_group)\n\n        # --- Clients ---\n        self.grasp_client = ActionClient(self, Grasp, f'/{self.robot_name}_gripper/grasp', callback_group=self.callback_group)\n        self.move_client = ActionClient(self, Move, f'/{self.robot_name}_gripper/move', callback_group=self.callback_group)\n        self.error_recovery_client = ActionClient(self, ErrorRecovery, '/action_server/error_recovery', callback_group=self.callback_group)\n        self.collision_client = self.create_client(SetForceTorqueCollisionBehavior, '/service_server/set_force_torque_collision_behavior')\n        \n        # --- 初始化 Motion Planner Client (替代原有的 MotionPlanner) ---\n        self.planner = MotionPlannerClient() \n        \n        # PID & Limits\n        self.kp = 1.0\n        self.kd = 0.04\n        self.dt = 0.05\n        self.limit_vel = np.array([2.1750, 2.1750, 2.1750, 2.1750, 2.6100, 2.6100, 2.6100]) * 0.2\n        self.limit_acc = np.array([15, 7.5, 10, 12.5, 15, 20, 20]) * 0.04\n        self.goal_tolerance = 0.01\n        \n        self.joint_command_msg = JointState()\n        self.react_control_flag = False\n        self.force_limit = 10.0\n        self.wrench = np.zeros(6)\n        self.robot_error = False\n        # self.home_joints = [0.0, -0.785, 0.0, -2.356, 0.0, 1.571, 0.785]\n        self.home_joints = [-0.5049881727597879, -0.8549570584577496, 0.31917120002324684, -2.358842981033868, 0.22935616762328961, 1.5388877849995934, 0.5157969213680381] \n\n        self.current_joint_state = None\n        \n        # Kinematics Model (for Client side FK/IK utils)\n        self.panda = rtb.models.Panda()\n\n        # Init World Config (Table)\n        self.table_cfg = None\n\n        self.create_timer(0.005, self.joint_velo_publisher, callback_group=self.callback_group)\n        \n        # Wait for robot state\n        self._wait_for_connection()\n        self.set_high_collision_thresholds()\n\n\n    def _wait_for_connection(self):\n        timeout = 10.0\n        start_time = time.time()\n        while self.current_joint_state is None and (time.time() - start_time) < timeout:\n            rclpy.spin_once(self, timeout_sec=0.1)\n        if self.current_joint_state:\n            self.get_logger().info(\"Controller connected to Robot.\")\n        else:\n            self.get_logger().error(\"Robot Joint State Timeout.\")\n\n    def set_high_collision_thresholds(self):\n        \"\"\"把碰撞阈值调高一点，用于允许抓取/接触环境\"\"\"\n        \n        # 等待服务\n        if not self.collision_client.wait_for_service(timeout_sec=2.0):\n            self.get_logger().error(\"Collision behavior service not available.\")\n            return\n\n        request = SetForceTorqueCollisionBehavior.Request()\n\n        # ========= 设置较高的阈值（常用配置） =========\n        # request.lower_torque_thresholds_acc  = [30, 30, 30, 20, 20, 15, 10]\n        # request.upper_torque_thresholds_acc  = [45, 45, 45, 35, 35, 25, 20]\n\n        # request.lower_force_thresholds_acc   = [50, 50, 50, 30, 30, 30]\n        # request.upper_force_thresholds_acc   = [80, 80, 80, 50, 50, 50]\n\n        request.lower_torque_thresholds_nominal = [20., 20., 20., 15., 15., 10., 10.]\n        request.upper_torque_thresholds_nominal = [35., 35., 35., 25., 25., 20., 15.]\n\n        request.lower_force_thresholds_nominal  = [40., 40., 40., 25., 25., 25.]\n        request.upper_force_thresholds_nominal  = [100., 100., 100., 100., 100., 100.]\n        # ========================================\n\n        future = self.collision_client.call_async(request)\n\n        # 回调处理结果\n        rclpy.spin_until_future_complete(self, future)\n\n        if future.result() is not None:\n            self.get_logger().info(\"High collision thresholds successfully set!\")\n        else:\n            self.get_logger().error(\"Failed to set collision thresholds.\")\n    \n    def visualize_trajectory(self, joint_waypoints, panda):\n        \"\"\"Visualize planned trajectory as a Path message\"\"\"\n        trajectory = []\n        for joints in joint_waypoints:\n            T_ee = panda.fkine(joints)\n            trajectory.append(np.array(T_ee))\n        path_msg = self.create_path_msg(trajectory, frame_id=\"fr3_link0\")\n        self.predicted_path_pub.publish(path_msg)\n\n    def create_path_msg(self, trajectory, frame_id=\"world\", ee_frame_id=\"cur_link\", color_alpha=1.0):\n        path_msg = Path()\n        path_msg.header = Header()\n        path_msg.header.stamp = self.get_clock().now().to_msg()\n        path_msg.header.frame_id = frame_id\n        for pose_matrix in trajectory:\n            pose_stamped = PoseStamped()\n            pose_stamped.header = path_msg.header\n            pose_stamped.pose.position.x = float(pose_matrix[0, 3])\n            pose_stamped.pose.position.y = float(pose_matrix[1, 3])\n            pose_stamped.pose.position.z = float(pose_matrix[2, 3])\n            rot_matrix = pose_matrix[:3, :3]\n            quat = Rotation.from_matrix(rot_matrix).as_quat()\n            pose_stamped.pose.orientation.x = float(quat[0])\n            pose_stamped.pose.orientation.y = float(quat[1])\n            pose_stamped.pose.orientation.z = float(quat[2])\n            pose_stamped.pose.orientation.w = float(quat[3])\n            path_msg.poses.append(pose_stamped)\n        return path_msg\n\n    def joint_velo_publisher(self):\n        try:\n            if self.react_control_flag:\n                self.joint_command_msg.header.stamp = self.get_clock().now().to_msg()\n                self.joint_velo_pub.publish(self.joint_command_msg)\n        except Exception as e:\n            pass\n\n    # def force_callback(self, msg):\n    #     self.wrench = np.array([\n    #         msg.o_f_ext_hat_k.wrench.force.x,\n    #         msg.o_f_ext_hat_k.wrench.force.y,\n    #         msg.o_f_ext_hat_k.wrench.force.z,\n    #         msg.o_f_ext_hat_k.wrench.torque.x,\n    #         msg.o_f_ext_hat_k.wrench.torque.y,\n    #         msg.o_f_ext_hat_k.wrench.torque.z,\n    #     ])\n    \n    def force_callback(self, msg):\n        \"\"\"接收传感器回调后：保存原始、并做一个简单低通滤波（EMA）到 wrench_filtered\"\"\"\n        raw = np.array([\n            msg.o_f_ext_hat_k.wrench.force.x,\n            msg.o_f_ext_hat_k.wrench.force.y,\n            msg.o_f_ext_hat_k.wrench.force.z,\n            msg.o_f_ext_hat_k.wrench.torque.x,\n            msg.o_f_ext_hat_k.wrench.torque.y,\n            msg.o_f_ext_hat_k.wrench.torque.z,\n        ])\n        self.wrench_raw = raw\n\n        # 启动时用前 baseline_sample_count 帧做平均基线\n        if not getattr(self, 'baseline_ready', False):\n            self.baseline_samples.append(raw)\n            if len(self.baseline_samples) >= self.baseline_sample_count:\n                self.wrench_baseline = np.mean(self.baseline_samples, axis=0)\n                self.baseline_ready = True\n        else:\n            # 运行时用 EMA 慢速更新 baseline（可选）\n            self.wrench_baseline = (1 - self.ema_alpha) * self.wrench_baseline + self.ema_alpha * raw\n\n        # 对原始信号做一个 EMA 低通以减少高频噪声\n        self.wrench_filtered = (1 - self.ema_alpha) * getattr(self, 'wrench_filtered', np.zeros(6)) + self.ema_alpha * raw\n\n\n    def robot_state_cb(self, msg):\n        detected_error = False\n        self.robot_mode = msg.robot_mode\n        if np.any([msg.collision_indicators.is_cartesian_angular_collision.x, msg.collision_indicators.is_cartesian_angular_collision.y, msg.collision_indicators.is_cartesian_angular_collision.z]):\n            detected_error = True\n        for s in Errors.__slots__:\n            if getattr(msg.current_errors, s):\n                detected_error = True\n        if not self.robot_error and detected_error:\n            self.robot_error = True\n            self.get_logger().warn(\"Detected robot error\")\n        if self.robot_error and not detected_error:\n            self.robot_error = False\n            self.get_logger().info(\"Robot error cleared\")\n\n    def joint_state_callback(self, msg: JointState):\n        self.current_joint_state = msg\n\n    def get_current_joint_position(self) -> Optional[List[float]]:\n        if self.current_joint_state is None:\n            return None\n        joint_positions = []\n        for joint_name in self.joint_names:\n            try:\n                idx = self.current_joint_state.name.index(joint_name)\n                joint_positions.append(self.current_joint_state.position[idx])\n            except ValueError:\n                return None\n        return joint_positions\n\n    def get_ee_pose(self):\n        joint_positions = self.get_current_joint_position()\n        joint_positions = np.array(joint_positions)\n        T_ee = self.panda.fkine(joint_positions)\n        return np.array(T_ee)\n\n    def wait_for_action_result(self, future, timeout: float = 30.0):\n        start_time = time.time()\n        while not future.done() and (time.time() - start_time) < timeout:\n            time.sleep(0.01)\n        if not future.done():\n            self.get_logger().warn(f\"Action timed out after {timeout} seconds.\")\n            return None\n        return future.result()\n\n    def home(self) -> bool:\n        self.get_logger().info(\"Moving to home position...\")\n        # current_joints = np.array(self.get_current_joint_position())\n        # error = self.home_joints - current_joints\n        # if np.linalg.norm(error) < self.goal_tolerance:\n        #     return True\n        # home_pose = self.panda.fkine(np.array(self.home_joints)).A @ self.T_tcp_link8.as_matrix()\n        # self.goto_pose(Transform.from_matrix(home_pose))\n        \n        # while self.baseline_ready is False:\n        #     time.sleep(0.1)\n        # if cur_pose[2, 3] < 0.12:\n        #     cur_pose[2, 3] += 0.08\n        #     cur_pose = Transform.from_matrix(cur_pose)\n        #     self.approach_grasp(cur_pose)\n            # print('Lifted EE Z')\n        \n        # return self.goto_pose(Transform.from_matrix(home_pose))\n        return self.goto_joints(self.home_joints)\n    \n    def set_table(self, table_height: float = 0., table_size: float = 0.5, T_base_task: Transform = Transform.identity()) -> None:\n        pose = reorder_pose_list(T_base_task.to_list())\n        pose[2] += table_height\n        \n        # 仅更新本地 Config 字典\n        self.table_cfg = {\n            \"cuboid\": {\n                \"table\": {\n                    \"dims\": [table_size, table_size, 0.01],\n                    \"pose\": pose,\n                },\n            },\n        }\n\n    # --- 核心修改：Planning ---\n    def planning(self, target_pose, pcl=None, plan_config=None):\n        \"\"\"\n        调用 ZMQ Client 进行规划，支持 PCL 输入\n        \"\"\"\n        target_pose = reorder_pose_list((target_pose * self.T_tcp_link8).to_list())\n        \n        # 准备数据\n        # 1. Cuboids (Table)\n        cuboids_data = self.table_cfg # 默认为 {'cuboid': {'table': ...}}\n\n        # 2. PointCloud (如果你有)\n        # pcl 必须是 (N, 3) 的 numpy 数组\n        pcl_data = pcl \n\n        # 发送更新请求给 Server\n        # Server 会在 GPU 上处理 Mesh 生成\n        self.planner.update_world(cuboids=cuboids_data, pcl=pcl_data)\n        \n        # 请求规划\n        cur_joint = np.array(self.get_current_joint_position())\n        joint_waypoints, success = self.planner.plan(cur_joint, target_pose, plan_config=plan_config)\n        \n        return joint_waypoints\n\n\n    # def goto_joints(self, target_joints):\n    #     # (逻辑不变，使用 self.kp, self.kd 控制)\n    #     arrived = False\n    #     current_joints = np.array(self.get_current_joint_position())\n    #     error = target_joints - current_joints\n    #     self.react_control_flag = True\n    #     last_velocity = np.array([0.0]*7)\n    #     last_error = error \n        \n    #     if np.linalg.norm(error) < self.goal_tolerance:\n    #         self.react_control_flag = False\n    #         return True\n            \n    #     while np.linalg.norm(error) > self.goal_tolerance and (self.robot_error is False):\n    #         loop_start = time.time()\n    #         robot_state_joint = self.get_current_joint_position()\n    #         error = target_joints - np.array(robot_state_joint)\n    #         error_derivative = (error - last_error) / self.dt\n    #         raw_joint_vel = (self.kp * error) + (self.kd * error_derivative)\n            \n    #         joint_acc = (raw_joint_vel - last_velocity) / self.dt\n    #         if (np.abs(joint_acc) > self.limit_acc).any():\n    #             joint_acc = np.clip(joint_acc, -self.limit_acc, self.limit_acc)\n    #             joint_vel = last_velocity + joint_acc * self.dt\n    #         else:\n    #             joint_vel = np.clip(raw_joint_vel, -self.limit_vel, self.limit_vel)\n            \n    #         last_velocity = joint_vel\n    #         last_error = error\n    #         self.joint_command_msg.name = self.joint_names\n    #         self.joint_command_msg.velocity = joint_vel.tolist()\n    #         elapsed = time.time() - loop_start\n    #         if self.dt > elapsed:\n    #             time.sleep(self.dt - elapsed)\n    #     self.react_control_flag = False\n    #     return True\n\n    def goto_joints(self, target_joints):\n        current_joints = np.array(self.get_current_joint_position())\n        interpolated_traj = rtb.jtraj(current_joints, target_joints, 20)\n        return self.goto_joint_trajectory(interpolated_traj.q)\n    \n\n    def approach_grasp(self, target_pose, Gain=1, threshold=0.01, duration_limit=5.0):\n        # target_pose = target_pose * self.T_tcp_body\n        target_pose = target_pose * self.T_link8_tcp\n        self.react_control_flag = True\n        wrench_baseline = self.wrench_filtered.copy()\n        k_null = 0.1\n        dq = np.zeros((7, 1))\n        last_velocity = np.zeros(7)\n        start_time = time.time()\n        while (self.robot_error is False):\n            if np.linalg.norm(self.wrench_filtered-wrench_baseline) > self.force_limit:\n                print('Force limit reached, stopping reactive control.')\n                break\n            if (time.time() - start_time) > duration_limit:\n                print(f\"[Approach] Time limit {duration_limit}s reached, stopping.\")\n                break\n            q = np.array(self.get_current_joint_position())\n            Te = self.panda.fkine(q)\n            Tep = target_pose.as_matrix()\n            v, arrived = rtb.p_servo(Te, Tep, Gain, threshold)\n            if arrived:\n                break\n            jacobian = self.panda.jacobe(q)\n            jacobian_pinv = np.linalg.pinv(jacobian)\n            dq_task = jacobian_pinv @ v\n            I = np.eye(jacobian.shape[1])  # 7x7 单位矩阵\n            null_space_projection = I - (jacobian_pinv @ jacobian)\n            dq_0 = -dq # 阻尼效果\n                \n            dq_null = null_space_projection @ dq_0\n            \n            # 4. 合并总速度\n            raw_joint_vel = dq_task + k_null * dq_null.reshape(-1)\n            dq = raw_joint_vel.reshape(-1, 1)\n\n            # ---------- 4. 加速度/速度限制 ----------\n            joint_acc = (raw_joint_vel - last_velocity) / self.dt\n            joint_acc = np.clip(joint_acc, -self.limit_acc, self.limit_acc)\n            joint_vel = last_velocity + joint_acc * self.dt\n            joint_vel = np.clip(joint_vel, -self.limit_vel, self.limit_vel)\n\n            last_velocity = joint_vel\n\n            self.joint_command_msg.velocity = joint_vel.tolist()\n        # ---------- 5. 缓停 ----------\n        for _ in range(5):\n            joint_vel *= 0.5\n            self.joint_command_msg.velocity = joint_vel.tolist()\n            time.sleep(0.01)\n\n        self.react_control_flag = False\n        return\n\n        \n    # def approach_grasp(self, target_pose, \n    #                 Gain=1, Lambda=0.1, threshold=0.001,\n    #                 contact_threshold=3.0,       # 轻微接触开始反应\n    #                 stop_threshold=12.0,         # 停止阈值\n    #                 rotate_gain=0.05,            # 旋转的速度比例\n    #                 duration_limit=5.0):         # <-- 新增：最大持续时间（秒）\n\n    #     target_pose = target_pose * self.T_tcp_body\n    #     self.react_control_flag = True\n    #     arrived = False\n\n    #     last_joint = np.array(self.get_current_joint_position())\n    #     last_velocity = np.zeros(7)\n    #     joint_vel = np.zeros(7)\n\n    #     # 初始基线\n    #     wrench_baseline = self.wrench_filtered.copy()\n\n    #     # 记录开始时间\n    #     start_time = time.time()\n\n    #     while (self.robot_error is False):\n    #         loop_start = time.time()\n\n    #         # ---------- 0. duration 退出 ----------\n    #         if (time.time() - start_time) > duration_limit:\n    #             print(f\"[Approach] Time limit {duration_limit}s reached, stopping.\")\n    #             break\n\n    #         q = np.array(self.get_current_joint_position())\n\n    #         # ---------- 1. 常规伺服控制 ----------\n    #         raw_joint_vel, arrived = calculate_velocity(\n    #             self.panda, q, target_pose,\n    #             obstacles=None, Gain=Gain, Lambda=Lambda, threshold=threshold\n    #         )\n\n    #         if arrived:\n    #             break\n\n    #         # ---------- 2. 力反馈 ----------\n    #         wrench = self.wrench_filtered.copy()\n    #         wrench_diff = wrench - wrench_baseline\n    #         wrench_diff_norm = np.linalg.norm(wrench_diff)\n\n    #         # print(f\"Wrench Diff Norm: {wrench_diff_norm:.2f} N\")\n\n    #         # 若达到停止阈值 → 停止\n    #         if np.linalg.norm(self.wrench_raw) > stop_threshold:\n    #             print(f\"[Approach] Stop threshold reached ({stop_threshold}).\")\n    #             break\n\n    #         # ---------- 3. 触碰旋转修正 ----------\n    #         if wrench_diff_norm > contact_threshold:\n    #             torque = wrench_diff[3:]   # τx, τy, τz\n\n    #             if np.linalg.norm(torque) > 1.0:\n    #                 # print(f\"[Approach] Contact detected. Torque norm={np.linalg.norm(torque):.2f}\")\n\n    #                 rot_axis = torque / np.linalg.norm(torque)\n    #                 twist = np.hstack([np.zeros(3), rotate_gain * rot_axis])\n\n    #                 # J\n    #                 J = self.panda.jacobe(q)\n    #                 dq_rot = np.linalg.pinv(J).dot(twist)\n\n    #                 raw_joint_vel = raw_joint_vel + dq_rot\n\n    #         # ---------- 4. 加速度/速度限制 ----------\n    #         joint_acc = (raw_joint_vel - last_velocity) / self.dt\n    #         joint_acc = np.clip(joint_acc, -self.limit_acc, self.limit_acc)\n    #         joint_vel = last_velocity + joint_acc * self.dt\n    #         joint_vel = np.clip(joint_vel, -self.limit_vel, self.limit_vel)\n\n    #         last_velocity = joint_vel\n\n    #         self.joint_command_msg.velocity = joint_vel.tolist()\n\n    #         elapsed = time.time() - loop_start\n    #         if self.dt > elapsed:\n    #             time.sleep(self.dt - elapsed)\n\n    #     # ---------- 5. 缓停 ----------\n    #     for _ in range(5):\n    #         joint_vel *= 0.5\n    #         self.joint_command_msg.velocity = joint_vel.tolist()\n    #         time.sleep(0.01)\n\n    #     self.react_control_flag = False\n    #     return arrived\n\n\n    \n    # def approach_grasp(self, target_pose, \n    #                    Gain=1, Lambda=0.1, threshold=0.001,\n    #                    detect_force=True,\n    #                    contact_threshold=0.15,    # 单位与你的传感器一致（N or Nm），调小用于检测接触\n    #                    stop_threshold=12.0,      # 最终停止阈值（按你原先设定）\n    #                    rotate_gain=0.05,\n    #                    deadzone = np.array([0.5,0.5,0.5,0.02,0.02,0.02]), # 各轴死区（示例，请调参）\n    #                    delta_threshold = 0.5,    # 瞬时变化率阈值（可选）\n    #                    contact_confirm_frames = 1,\n    #                    watch_dog_limit=70):\n\n    #     target_pose = target_pose * self.T_tcp_body\n    #     self.react_control_flag = True\n    #     arrived = False\n    #     watch_dog = 0\n\n    #     last_joint = np.array(self.get_current_joint_position())\n    #     last_velocity = np.zeros(7)\n    #     joint_vel = np.zeros(7)\n\n    #     # 确保 baseline 已准备好（若未准备好，可先收集更多样本或延迟响应）\n    #     if not getattr(self, 'baseline_ready', False):\n    #         # 如果 baseline 还没准备好，你可以选择等待或在低速下先收集\n    #         # 这里简单打印并尽量继续（但不使用力信息）\n    #         print(\"Warning: wrench baseline not ready yet. force-based reactions disabled until baseline ready.\")\n    #         use_force = False\n    #     else:\n    #         use_force = detect_force\n\n    #     prev_wrench_corrected = np.zeros(6)\n    #     contact_counter = 0\n\n    #     while True and (self.robot_error is False):\n    #         loop_start = time.time()\n    #         q = np.array(self.get_current_joint_position())\n\n    #         raw_joint_vel, arrived = calculate_velocity(self.panda, q, target_pose,\n    #                                                 obstacles=None, Gain=Gain, Lambda=Lambda, threshold=threshold)\n\n    #         joint_movement = np.linalg.norm(q - last_joint)\n    #         last_joint = q.copy()\n    #         if joint_movement < 0.001:\n    #             watch_dog += 1\n    #         else:\n    #             watch_dog = 0\n    #         if arrived or watch_dog > watch_dog_limit:\n    #             break\n\n    #         # 使用滤波后并去掉基线\n    #         if use_force:\n    #             wrench_corr = self.wrench_filtered - self.wrench_baseline\n    #         else:\n    #             wrench_corr = np.zeros(6)\n\n    #         # 对每个轴做 deadzone（小于死区视为0）\n    #         for i in range(6):\n    #             if abs(wrench_corr[i]) < deadzone[i]:\n    #                 wrench_corr[i] = 0.0\n\n    #         wrench_norm = np.linalg.norm(wrench_corr)\n\n    #         # 也可以检测 torque 的变化率来避免初始偏移误判\n    #         delta = np.linalg.norm(wrench_corr - prev_wrench_corrected)\n    #         prev_wrench_corrected = wrench_corr.copy()\n\n    #         # 接触判据：去偏值大于 contact_threshold 且 delta 大于 delta_threshold （或持续多帧）\n    #         is_contact_this_frame = (wrench_norm > contact_threshold) and (delta > 0.01 or wrench_norm > (contact_threshold*1.2))\n    #         if is_contact_this_frame:\n    #             contact_counter += 1\n    #         else:\n    #             contact_counter = 0\n\n    #         confirmed_contact = (contact_counter >= contact_confirm_frames)\n\n    #         # 如果达到最终停止阈值，立即停止\n    #         if np.linalg.norm(self.wrench_filtered) > stop_threshold: # - self.wrench_baseline\n    #             break\n\n    #         # 若确认接触，才计算旋转避免\n    #         if confirmed_contact:\n    #             torque = wrench_corr[3:]\n    #             if np.linalg.norm(torque) > 1e-4:\n    #                 rot_axis = torque / np.linalg.norm(torque)\n    #                 twist = np.hstack([np.zeros(3), rotate_gain * rot_axis])\n    #                 J = self.panda.jacobe(q)\n    #                 dq_rot = np.linalg.pinv(J).dot(twist)\n    #                 raw_joint_vel = raw_joint_vel + dq_rot\n\n    #         # 速度/加速度限制\n    #         joint_acc = (raw_joint_vel - last_velocity) / self.dt\n    #         joint_acc = np.clip(joint_acc, -self.limit_acc, self.limit_acc)\n    #         joint_vel = last_velocity + joint_acc * self.dt\n    #         joint_vel = np.clip(joint_vel, -self.limit_vel, self.limit_vel)\n\n    #         self.joint_command_msg.velocity = joint_vel.tolist()\n    #         last_velocity = joint_vel\n\n    #         # elapsed = time.time() - loop_start\n    #         # if self.dt > elapsed:\n    #         #     time.sleep(self.dt - elapsed)\n\n    #     # 缓停\n    #     for _ in range(5):\n    #         joint_vel *= 0.5\n    #         self.joint_command_msg.velocity = joint_vel.tolist()\n    #         time.sleep(0.01)\n\n    #     self.react_control_flag = True\n    #     return arrived\n\n    def goto_pose_reactive(self, target_pose, Gain=1, Lambda=0.1, threshold=0.001, detect_force=True, pcl=None, watch_dog_limit=70):\n        # target_pose = target_pose * self.T_tcp_body\n        target_pose = target_pose * self.T_link8_tcp\n        self.react_control_flag = True\n        arrived = False\n        watch_dog = 0\n        last_joint = np.array(self.get_current_joint_position())\n        last_velocity = np.array([0.0]*7)\n        joint_vel = np.array([0.0]*7)\n        wrench_baseline = self.wrench_filtered.copy()\n        while True and (self.robot_error is False):\n            loop_start = time.time()\n            robot_state_joint = self.get_current_joint_position()\n            # Gain_mod = Gain * max((self.force_limit - np.linalg.norm(self.wrench)) / (self.force_limit - 6), 0)\n            # print('Gain mod:', Gain_mod)\n            raw_joint_vel, arrived = calculate_velocity(self.panda, np.array(robot_state_joint), target_pose, \n                                                    obstacles=None, Gain=Gain, Lambda=Lambda, threshold=threshold)\n            joint_movement = np.linalg.norm(np.array(self.get_current_joint_position())-last_joint)\n            last_joint = np.array(self.get_current_joint_position())\n            if joint_movement < 0.001:\n                watch_dog += 1\n            else:\n                watch_dog = 0\n            if arrived is True or watch_dog > watch_dog_limit:\n                break\n            if np.linalg.norm(self.wrench_filtered-wrench_baseline) > self.force_limit and detect_force:\n                print('Force limit reached, stopping reactive control.')\n                break\n            \n            joint_acc = (raw_joint_vel - last_velocity) / self.dt\n            joint_acc = np.clip(joint_acc, -self.limit_acc, self.limit_acc)\n            joint_vel = last_velocity + joint_acc * self.dt\n            joint_vel = np.clip(joint_vel, -self.limit_vel, self.limit_vel)\n            \n            self.joint_command_msg.velocity = joint_vel.tolist()\n            last_velocity = joint_vel\n            elapsed = time.time() - loop_start\n            if self.dt > elapsed:\n                time.sleep(self.dt - elapsed)\n        \n        for _ in range(5):\n            joint_vel = joint_vel*0.5\n            self.joint_command_msg.velocity = (joint_vel).tolist()\n            time.sleep(0.01)\n        self.react_control_flag = True\n        return arrived\n    \n    # def grasp(self, width=0.01, speed=0.1, force=50.0, \n    #       inner_epsilon=0.005, outer_epsilon=0.005,\n    #       hold=True, hold_interval=0.2):\n\n    #     if not self.grasp_client.wait_for_server(timeout_sec=5.0):\n    #         return False\n\n    #     goal = Grasp.Goal()\n    #     goal.width = width\n    #     goal.speed = speed\n    #     goal.force = force\n    #     goal.epsilon = GraspEpsilon(inner=inner_epsilon, outer=outer_epsilon)\n\n    #     send_future = self.grasp_client.send_goal_async(goal)\n    #     result = self.wait_for_action_result(send_future, 5.0)\n    #     if not result:\n    #         return False\n\n    #     # --- 关键：持续保持 ---\n    #     if hold:\n    #         final_width = width\n    #         for _ in range(5):  # 初期补偿多几次\n    #             self.move_gripper(final_width, speed=0.02, force=force)\n    #             time.sleep(hold_interval)\n\n    #     return True\n    \n    def move_gripper(self, width, speed=0.1):\n        goal = Move.Goal()\n        goal.width = width\n        goal.speed = speed\n        send_future = self.move_client.send_goal_async(goal)\n        start = time.time()\n        while not send_future.done() and (time.time() - start) < 2.0:\n            time.sleep(0.01)\n        if not send_future.done(): return False\n        handle = send_future.result()\n        if not handle or not handle.accepted: return False\n        res_future = handle.get_result_async()\n        res = self.wait_for_action_result(res_future, 2.0)\n        return True\n\n\n\n    def grasp(self, width: float = 0.01, speed: float = 0.1, force: float = 50.0, inner_epsilon: float = 0.05, outer_epsilon: float = 0.05) -> bool:\n        if not self.grasp_client.wait_for_server(timeout_sec=5.0):\n            return False\n        goal = Grasp.Goal()\n        goal.width = width\n        goal.speed = speed\n        goal.force = force\n        goal.epsilon = GraspEpsilon(inner=inner_epsilon, outer=outer_epsilon)\n        send_future = self.grasp_client.send_goal_async(goal)\n        start = time.time()\n        while not send_future.done() and (time.time() - start) < 5.0:\n            time.sleep(0.01)\n        if not send_future.done(): return False\n        handle = send_future.result()\n        if not handle or not handle.accepted: return False\n        res_future = handle.get_result_async()\n        res = self.wait_for_action_result(res_future, 5.0)\n        return res and res.status == 4\n\n    def goto_pose(self, target_pose: Transform, pcl=None, plan_config=None) -> bool:\n        cur_pose = Transform.from_matrix(self.get_ee_pose()) * self.T_tcp_link8.inverse()\n        ## whether arrive at target\n        dist =  (target_pose * cur_pose.inverse())\n        if np.linalg.norm(dist.translation) < 0.01 and dist.rotation.as_euler('ZYX').abs().sum() < 0.1:\n            return True\n        \n        self.get_logger().info(f\"Planning to target pose...\")\n        joint_waypoints = self.planning(target_pose, pcl=pcl, plan_config=plan_config)\n        if joint_waypoints is None:\n            self.get_logger().error(\"Planning failed.\")\n            return False\n        self.visualize_trajectory(joint_waypoints, self.panda)\n        return self.goto_joint_trajectory(joint_waypoints)\n\n    def goto_joint_trajectory(self, joint_waypoints: List[List[float]]) -> bool:\n        waypoints = np.array(joint_waypoints)\n        if len(waypoints) < 2: return False\n        self.react_control_flag = True\n        \n        # ... (轨迹跟踪逻辑不变，省略以节省篇幅，请复制原逻辑) ...\n        # (PD Control Loop through waypoints)\n        \n        # Simplified placeholder for brevity in this response:\n        process_tolerance = 0.4\n        final_tolerance = self.goal_tolerance\n        last_velocity = np.array([0.0] * 7)\n        last_error = np.zeros(7)\n        cur_i = 0\n        while cur_i < len(waypoints) - 1 and self.robot_error is False:\n            loop_start = time.time()\n            cur_target = waypoints[cur_i + 1]\n            current_joints = np.array(self.get_current_joint_position())\n            error = cur_target - current_joints\n            if np.linalg.norm(error) < (process_tolerance if cur_i < len(waypoints)-2 else process_tolerance*0.5):\n                cur_i += 1\n            error_derivative = (error - last_error) / self.dt\n            raw_joint_vel = (self.kp * error) + (self.kd * error_derivative)\n            \n            joint_acc = np.clip((raw_joint_vel - last_velocity) / self.dt, -self.limit_acc, self.limit_acc)\n            joint_vel = np.clip(last_velocity + joint_acc * self.dt, -self.limit_vel, self.limit_vel)\n            \n            last_velocity = joint_vel\n            last_error = error\n            self.joint_command_msg.name = self.joint_names\n            self.joint_command_msg.velocity = joint_vel.tolist()\n            if self.dt > (time.time() - loop_start): time.sleep(self.dt - (time.time() - loop_start))\n        \n        # Final Alignment\n        timeout_start = time.time()\n        final_target = waypoints[-1]\n        while self.robot_error is False and (time.time() - timeout_start < 3.0):\n            current_joints = np.array(self.get_current_joint_position())\n            error = final_target - current_joints\n            if np.linalg.norm(error) < final_tolerance: break\n            joint_vel = np.clip(self.kp * error, -0.2, 0.2)\n            self.joint_command_msg.velocity = joint_vel.tolist()\n            time.sleep(self.dt)\n        \n        self.joint_command_msg.velocity = [0.0]*7\n        time.sleep(0.05)\n        self.react_control_flag = False\n        return True\n\n    def recover(self) -> bool:\n        if not self.error_recovery_client.wait_for_server(timeout_sec=5.0): return False\n        goal = ErrorRecovery.Goal()\n        future = self.error_recovery_client.send_goal_async(goal)\n        start = time.time()\n        while not future.done() and (time.time() - start) < 5.0: time.sleep(0.01)\n        if not future.done(): return False\n        handle = future.result()\n        if not handle or not handle.accepted: return False\n        res = self.wait_for_action_result(handle.get_result_async(), 5.0)\n        if res and res.status == 4:\n            return self.home()\n        return False\n\n# --- Pose Generator (保留用于测试) ---\nclass FrankaPoseGenerator:\n    def __init__(self, robot_name=\"fr3\"):\n        self.panda = rtb.models.Panda()\n        self.q_min = np.array([-2.7, -1.7, -2.8, -3.0, -2.8, 0.01, -2.8]) * 0.5\n        self.q_max = np.array([ 2.7,  1.7,  2.8, -0.1,  2.8, 3.7,  2.8]) * 0.5\n    \n    def _to_user_format(self, pos, quat):\n        user_quat = [quat[3], quat[0], quat[1], quat[2]] \n        return Transform.from_list(user_quat + list(pos))\n\n    def get_guaranteed_reachable_pose(self):\n        q_rand = np.random.uniform(self.q_min, self.q_max)\n        T = self.panda.fkine(q_rand)\n        pos = T.t \n        quat = Rotation.from_matrix(T.R).as_quat()\n        if pos[2] < 0.05: return self.get_guaranteed_reachable_pose()\n        return self._to_user_format(pos, quat)\n\ndef main():\n    rclpy.init()\n    panda_commander = PandaCommander(robot_name=\"fr3\")\n    from rclpy.executors import MultiThreadedExecutor\n    from threading import Thread\n    executor = MultiThreadedExecutor(10)\n    executor.add_node(panda_commander)\n    generator = FrankaPoseGenerator()\n    try:\n        t1 = Thread(target=executor.spin, daemon=True)\n        t1.start()\n\n        for i in range(10):\n            print(f\"--- Loop {i} ---\")\n            print(\"Testing Grasp...\")\n            panda_commander.grasp(width=0.08, force=30.0)\n            time.sleep(1.0)\n            \n            print(\"Testing Home...\")\n            panda_commander.home()\n            time.sleep(1.0)\n            \n            for j in range(2):\n                print(f\"Testing Plan to Random Pose {j}...\")\n                target_pose = generator.get_guaranteed_reachable_pose()\n                panda_commander.goto_pose(target_pose)\n                time.sleep(1.0)\n            \n            print(\"Testing Grasp Close...\")\n            panda_commander.grasp(width=0.02, force=30.0)\n            time.sleep(1.0)\n        \n    except KeyboardInterrupt:\n        pass\n    finally:\n        executor.shutdown()\n        panda_commander.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()"}\n{"instruction": "Write a ROS2 Python node named task1b.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "#!/usr/bin/env python3\n\"\"\"\nExample of using MoveIt 2 Servo to perform a circular motion.\n`ros2 run pymoveit2 ex_servo.py`\n\"\"\"\nfrom threading import Thread\nimport numpy as np\nfrom math import cos, sin\nimport math, time\nfrom copy import deepcopy\nimport rclpy\nfrom rclpy.node import Node\nfrom scipy.spatial.transform import Rotation as R\nfrom tf2_ros import TransformException\nfrom tf2_ros.buffer import Buffer\nfrom tf2_ros.transform_listener import TransformListener\nimport tf2_ros\nfrom tf2_ros import TransformException\nfrom rclpy.callback_groups import ReentrantCallbackGroup\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import TwistStamped\nfrom pymoveit2 import MoveIt2\nfrom pymoveit2.robots import ur5\nfrom rclpy.qos import (\n    QoSDurabilityPolicy,\n    QoSHistoryPolicy,\n    QoSProfile,\n    QoSReliabilityPolicy,\n)\n\nglobal i \ni = 0\n\nglobal curr_x,curr_y,curr_z\ncurr_x = -65536\ncurr_y = -65536\ncurr_z = -65536\n\npositions=[  [0.35, 0.10, 0.68] ,  \n            [-0.37, 0.12, 0.397] , \n            [0.194, -0.43, 0.701] , \n            [-0.37, 0.12, 0.397] ]\n\nstart = [math.radians(0),math.radians(-137),math.radians(138),math.radians(-180),math.radians(-91),math.radians(180)]\ndrop = [-0.03403341798766224, -1.2848632387872256, -1.8567441129914095, -3.185621281551551, -1.545888364367352, 3.1498768354918307]\nright = [math.radians(-90),math.radians(-138),math.radians(137),math.radians(-181),math.radians(-93),math.radians(180)]\nleft = [math.radians(90),math.radians(-138),math.radians(137),math.radians(-181),math.radians(-93),math.radians(180)]\njoints = [ [start],\n            [start,drop], # Go to drop\n            [start,right], # Go to P2\n            [right,drop] ] # Go to D\n\n\n\n\nclass FrameListener(Node):\n\n    def __init__(self):\n        super().__init__('tf2_frame_listener')\n\n        self.tf_buffer = Buffer()\n        self.tf_listener = TransformListener(self.tf_buffer, self)\n\n        # Call on_timer function every second\n        self.timer = self.create_timer(0.02, self.on_timer)\n\n    def on_timer(self):\n        # Store frame names in variables that will be used to\n        # compute transformations\n        from_frame_rel = ur5.end_effector_name()\n        to_frame_rel = ur5.base_link_name()\n        global curr_x,curr_y,curr_z,r,p,y\n\n        # Look up for the transformation between target_frame and turtle2 frames\n        # and send velocity commands for turtle2 to reach target_frame\n        try:\n            t = self.tf_buffer.lookup_transform(\n                to_frame_rel,\n                from_frame_rel,\n                rclpy.time.Time())\n            curr_x = t.transform.translation.x\n            curr_y = t.transform.translation.y\n            curr_z = t.transform.translation.z\n            # q = [t.transform.rotation.w , t.transform.rotation.x ,t.transform.rotation.y ,t.transform.rotation.z ]\n            # r , p , y = R.from_quat(q).as_euler('xyz', degrees=False)\n        except TransformException as ex:\n            self.get_logger().info(\n                f'Could not transform {to_frame_rel} to {from_frame_rel}: {ex}')\n            return\n\nclass MoveItJointControl:\n    def __init__(self):\n        # Create a node for this example\n        self.node = Node(\"moveit_joint_control\")\n\n        # Create callback group that allows execution of callbacks in parallel without restrictions\n        self.callback_group = ReentrantCallbackGroup()\n\n        # Create MoveIt 2 interface\n        self.moveit2 = MoveIt2(\n            node=self.node,\n            joint_names=ur5.joint_names(),\n            base_link_name=ur5.base_link_name(),\n            end_effector_name=ur5.end_effector_name(),\n            group_name=ur5.MOVE_GROUP_ARM,\n            callback_group=self.callback_group,\n        )\n\n        # Spin the node in a background thread\n        self.executor = rclpy.executors.MultiThreadedExecutor(2)\n        self.executor.add_node(self.node)\n        self.executor_thread = Thread(target=self.executor.spin, daemon=True, args=())\n        self.executor_thread.start()\n\n    def move_to_joint_positions(self, joint_positions):\n        \"\"\"\n        Move the robot to the specified joint positions.\n\n        :param joint_positions: List of target joint positions\n        :type joint_positions: list of float\n        \"\"\"\n        # Move to joint configuration\n        self.node.get_logger().info(f\"Moving to {{joint_positions: {joint_positions}}}\")\n        self.moveit2.move_to_configuration(joint_positions)\n        self.moveit2.wait_until_executed()\n\n    def shutdown(self):\n        self.node.get_logger().info(\"Shutting down MoveItJointControl\")\n        self.executor.shutdown()\n\n\ndef main():\n    rclpy.init()\n\n    # Create node for this example\n    moveit_control = MoveItJointControl()\n    marign = 0.01\n\n    for jointlist in joints:\n        for joint in jointlist:\n            moveit_control.move_to_joint_positions(joint)\n            time.sleep(2)\n\n        node = Node(\"Servo\")\n        node1 = FrameListener()\n\n        callback_group = ReentrantCallbackGroup()\n        twist_pub = node.create_publisher(TwistStamped, \"/servo_node/delta_twist_cmds\", 10)\n\n        global i\n        target_pose = positions[i]\n\n        future = rclpy.Future()\n        def func():\n            if curr_x == -65536 and curr_y == -65536 and curr_z == -65536 :\n                return\n            curr_pose_x = target_pose[0] - curr_x\n            curr_pose_y = target_pose[1] - curr_y\n            curr_pose_z = target_pose[2] - curr_z \n            mag = math.sqrt( curr_x ** 2 + curr_y ** 2 + curr_z ** 2 )\n            vt = [ curr_pose_x / mag , curr_pose_y / mag , curr_pose_z / mag ]\n            if( abs(curr_x-target_pose[0])<marign and abs(curr_y-target_pose[1])<marign and abs(curr_z-target_pose[2])<marign):\n                twist_msg = TwistStamped()\n                twist_msg.header.frame_id = ur5.base_link_name()\n                twist_msg.header.stamp = node.get_clock().now().to_msg()\n                twist_msg.twist.linear.x = 0.0\n                twist_msg.twist.linear.y = 0.0\n                twist_msg.twist.linear.z = 0.0\n                twist_msg.twist.angular.x = 0.0\n                twist_msg.twist.angular.y = 0.0\n                twist_msg.twist.angular.z = 0.0 \n                twist_pub.publish(twist_msg)\n                global i\n                i+=1\n                future.set_result(True)\n                return\n            twist_msg = TwistStamped()\n            twist_msg.header.frame_id = ur5.base_link_name()\n            twist_msg.header.stamp = node.get_clock().now().to_msg()\n            twist_msg.twist.linear.x = vt[0]\n            twist_msg.twist.linear.y = vt[1]\n            twist_msg.twist.linear.z = vt[2]\n            twist_msg.twist.angular.x = 0.0\n            twist_msg.twist.angular.y = 0.0\n            twist_msg.twist.angular.z = 0.0\n            twist_pub.publish(twist_msg) \n        # Create timer for moving in a circular motion\n        node.create_timer(0.02, func)\n        # Spin the node in background thread(s)\n        executor = rclpy.executors.MultiThreadedExecutor(2)\n        executor.add_node(node1)\n        executor.add_node(node)\n        executor.spin_until_future_complete(future)\n        # executor.spin()  \n        node.destroy_node()\n        node1.destroy_node() \n        time.sleep(1)\n    \n    rclpy.shutdown()\n    exit(0)\n\n\nif __name__ == \"__main__\":\n    main()\n\n"}\n{"instruction": "Write a ROS2 Python node named controller_ros.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "from controllerGui import *\nimport sys\nfrom PyQt5.QtWidgets import *\n\nfrom threading import Thread\nimport rclpy\nfrom rclpy.node import Node\nfrom rclpy.callback_groups import ReentrantCallbackGroup\nfrom rclpy.node import Node\nfrom pymoveit2 import MoveIt2, MoveIt2Servo, MoveIt2ServoJoints\nfrom pymoveit2.robots import ur3\n\nfrom sensor_msgs.msg import JointState\nfrom example_interfaces.msg import Float64\n\n\n\n#Executes GUI\napp = QtWidgets.QApplication(sys.argv)\nMainWindow = QtWidgets.QMainWindow()\nui = Ui_MainWindow()\nui.setupUi(MainWindow)\n#MainWindow.show()\n\n# Initialize ROS\n\n \n\ndef servo_on_off():\n    if ui.checkBox.isChecked():\n        if ui.radioButton.isChecked():\n            servo_init()\n        else:\n            try:\n                destroy()\n                servoj_init()\n            except:\n                servoj_init() \n    else:\n        destroy\n# Locks ComboBox when ServoJ enabled\ndef lock_joint_frame():\n    ui.comboBox.setCurrentIndex(0)\n    ui.comboBox.setDisabled(1)\n# Unlocks ComboBox when ServoJ disabled\ndef unlock_joint_frame():\n    ui.comboBox.setEnabled(1)\n# Changes publisher to Servo\ndef radio_button_change_1(self):\n    if ui.checkBox.isChecked():\n        self.destroy()\n        self.servo_init()\n    else:\n        self.servo_init()\n# Changes publisher to ServoJ\ndef radio_button_change_2(self):\n    if ui.checkBox.isChecked():\n        self.destroy()\n        self.servoj_init() \n\n\n\ndef destroy():\n    try:\n        node.destroy_node()\n    except:\n        print(\"Failed\")\n\ndef pose(self):\n    try:\n        node = Node(\"ex_pose_goal\")\n        callback_group = ReentrantCallbackGroup()\n        moveit2 = MoveIt2(\n            node=node,\n            joint_names=ur3.joint_names(),\n            base_link_name=ur3.base_link_name(),\n            end_effector_name=ur3.end_effector_name(),\n            group_name=ur3.MOVE_GROUP_ARM,\n            callback_group=callback_group,\n        )\n        executor.add_node(node)\n        position = [ui.doubleSpinBox.value(), ui.doubleSpinBox_2.value(), ui.doubleSpinBox_3.value()] \n        quat_xyzw = [ui.doubleSpinBox_4.value(), ui.doubleSpinBox_5.value(), ui.doubleSpinBox_6.value(), ui.doubleSpinBox_7.value()]\n        node.get_logger().info(\n            \"Moving to {{position: {list(position)}, quat_xyzw: {list(quat_xyzw)}}}\"\n        )\n        moveit2.move_to_pose(position=position, quat_xyzw=quat_xyzw)\n        moveit2.wait_until_executed()\n        node.destroy_node()\n    except:\n        print(\"Failed to go Pose\") \n        node.destroy_node()\n           \n\ndef joint(self):\n    try:\n        node = Node(\"ex_joint_goal\")\n        node.declare_parameter(\n            \"joint_positions\",\n            [\n            ui.spinBox.value()*22/1260,\n            ui.spinBox_2.value()*22/1260,\n            ui.spinBox_3.value()*22/1260,\n            ui.spinBox_4.value()*22/1260,\n            ui.spinBox_5.value()*22/1260,\n            ui.spinBox_6.value()*22/1260,\n            ],\n        )\n        callback_group = ReentrantCallbackGroup()\n        moveit2 = MoveIt2(\n            node=node,\n            joint_names=ur3.joint_names(),\n            base_link_name=ur3.base_link_name(),\n            end_effector_name=ur3.end_effector_name(),\n            group_name=ur3.MOVE_GROUP_ARM,\n            callback_group=callback_group,\n        )\n        self.executor.add_node(node)\n        joint_positions = (\n            node.get_parameter(\"joint_positions\").get_parameter_value().double_array_value\n        )\n        node.get_logger().info(f\"Moving to {{joint_positions: {list(joint_positions)}}}\")\n        moveit2.move_to_configuration(joint_positions)\n        moveit2.wait_until_executed()\n        node.destroy_node()\n    except:\n        print(\"Failed to MoveJ\")\n        node.destroy_node()\n\ndef servoj_init(self):\n    self.node = Node(\"ex_servoj\")\n    callback_group = ReentrantCallbackGroup()\n    self.moveit2_servoj = MoveIt2ServoJoints(\n        node=self.node,\n        frame_id= ur3.base_link_name(),\n        joint_names=ur3.joint_names(),  #[\"shoulder_pan_joint\",\"shoulder_lift_joint\",\"elbow_joint\",\"wrist_1_joint\",\"wrist_2_joint\",\"wrist_3_joint\"],\n        callback_group=callback_group,\n    )\n     \n    executor.add_node(self.node)\n    self.node.create_timer(0.01,self.servoj)\n\n# Define SpinBoxes for Servo  \ndef servoj(self):\n    self.moveit2_servoj.servoJ(\n        velocities=(ui.spinBox_7.value()/100, ui.spinBox_8.value()/100, ui.spinBox_9.value()/100,\n        ui.spinBox_10.value()/100, ui.spinBox_11.value()/100, ui.spinBox_12.value()/100)) \n    print(float(ui.spinBox_7.value()))\n    \ndef servo_init(self):\n    if ui.checkBox.isChecked(): \n        self.node = Node(\"ex_servo\")\n        callback_group = ReentrantCallbackGroup()\n        if ui.comboBox.currentIndex() == 0:\n            self.moveit2_servo = MoveIt2Servo(\n              node=self.node,\n              frame_id=ur3.base_link_name(),\n              callback_group=callback_group,\n              linear_speed=0.01,\n              angular_speed=0.01,\n            )\n        elif ui.comboBox.currentIndex() == 1:\n            self.moveit2_servo = MoveIt2Servo(\n              node=self.node,\n              frame_id=ur3.end_effector_name(),\n              callback_group=callback_group,\n              linear_speed=0.01,\n              angular_speed=0.01,\n            )         \n        self.executor.add_node(self.node)\n        self.node.create_timer(0.01,self.servo)\n    else:\n        print(\"ERROR\")\n    \n# Define SpinBoxes for Servo    \ndef servo(self):\n    self.moveit2_servo.servo(\n        linear=(ui.spinBox_7.value(), ui.spinBox_8.value(), ui.spinBox_9.value()), \n        angular=(ui.spinBox_10.value(), ui.spinBox_11.value(), ui.spinBox_12.value()))\n    print(float(ui.spinBox_7.value()))\n\n\n\n#Exit\n#sys.exit(app.exec_())"}\n{"instruction": "Write a ROS2 Python node named scan_fixed_positions.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "#!/usr/bin/env python3\n\nfrom threading import Thread\nimport random\nimport math\n\nimport rclpy\nfrom rclpy.callback_groups import ReentrantCallbackGroup\nfrom rclpy.node import Node\n\nfrom pymoveit2 import MoveIt2, MoveIt2State\nfrom pymoveit2.robots import ur as robot\n\n\ndef main():\n    rclpy.init()\n\n    # Create node for this example\n    node = Node(\"ex_joint_goal\")\n\n    joint_names = [\n        \"shoulder_pan_joint\",\n        \"shoulder_lift_joint\",\n        \"elbow_joint\",\n        \"wrist_1_joint\",\n        \"wrist_2_joint\",\n        \"wrist_3_joint\",\n    ]\n\n    random_joint_values = [\n        random.uniform(-math.pi/2, math.pi/2) for _ in joint_names\n    ]\n\n    # Declare parameter for joint positions\n    node.declare_parameter(\n        \"joint_positions\",\n        random_joint_values,\n    )\n    node.declare_parameter(\"synchronous\", True)\n    # If non-positive, don't cancel. Only used if synchronous is False\n    node.declare_parameter(\"cancel_after_secs\", 0.0)\n    # Planner ID\n    node.declare_parameter(\"planner_id\", \"RRTConnectkConfigDefault\")\n\n    # Create callback group that allows execution of callbacks in parallel without restrictions\n    callback_group = ReentrantCallbackGroup()\n\n    node.get_logger().info(f\"Moving {robot.MOVE_GROUP_ARM}\")\n    # Create MoveIt 2 interface\n    moveit2 = MoveIt2(\n        node=node,\n        joint_names=joint_names,\n        base_link_name=\"base_link\",\n        end_effector_name=\"tool0\",\n        group_name=\"ur_manipulator\",\n        callback_group=callback_group,\n    )\n    moveit2.planner_id = (\n        node.get_parameter(\"planner_id\").get_parameter_value().string_value\n    )\n\n    # Spin the node in background thread(s) and wait a bit for initialization\n    executor = rclpy.executors.MultiThreadedExecutor(2)\n    executor.add_node(node)\n    executor_thread = Thread(target=executor.spin, daemon=True, args=())\n    executor_thread.start()\n    node.create_rate(1.0).sleep()\n\n    # Scale down velocity and acceleration of joints (percentage of maximum)\n    moveit2.max_velocity = 0.5\n    moveit2.max_acceleration = 0.5\n\n    # Get parameters\n    joint_positions = (\n        node.get_parameter(\"joint_positions\").get_parameter_value().double_array_value\n    )\n    synchronous = node.get_parameter(\"synchronous\").get_parameter_value().bool_value\n    cancel_after_secs = (\n        node.get_parameter(\"cancel_after_secs\").get_parameter_value().double_value\n    )\n\n    # Move to joint configuration\n    node.get_logger().info(f\"Moving to {{joint_positions: {list(joint_positions)}}}\")\n    moveit2.move_to_configuration(joint_positions)\n    if synchronous:\n        # Note: the same functionality can be achieved by setting\n        # `synchronous:=false` and `cancel_after_secs` to a negative value.\n        moveit2.wait_until_executed()\n    else:\n        # Wait for the request to get accepted (i.e., for execution to start)\n        print(\"Current State: \" + str(moveit2.query_state()))\n        rate = node.create_rate(10)\n        while moveit2.query_state() != MoveIt2State.EXECUTING:\n            rate.sleep()\n\n        # Get the future\n        print(\"Current State: \" + str(moveit2.query_state()))\n        future = moveit2.get_execution_future()\n\n        # Cancel the goal\n        if cancel_after_secs > 0.0:\n            # Sleep for the specified time\n            sleep_time = node.create_rate(cancel_after_secs)\n            sleep_time.sleep()\n            # Cancel the goal\n            print(\"Cancelling goal\")\n            moveit2.cancel_execution()\n\n        # Wait until the future is done\n        while not future.done():\n            rate.sleep()\n\n        # Print the result\n        print(\"Result status: \" + str(future.result().status))\n        print(\"Result error code: \" + str(future.result().result.error_code))\n\n    rclpy.shutdown()\n    executor_thread.join()\n    exit(0)\n\n\nif __name__ == \"__main__\":\n    main()\n"}\n{"instruction": "Write a ROS2 Python node named model.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "\"\"\"Model client node to get actions from a robot policy model server over WebSocket.\"\"\"\n\nfrom __future__ import annotations\n\nfrom collections import deque\nfrom dataclasses import dataclass\nfrom enum import Enum\nimport threading\nimport time\n\nimport jax\nimport numpy as np\nfrom openpi_client import websocket_client_policy as wcp\nfrom webpolicy.client import Client\n\nimport rclpy\nfrom rich.pretty import pprint\nfrom sensor_msgs.msg import JointState\nfrom std_msgs.msg import Float32MultiArray\nimport tyro\nfrom xarm_msgs.msg import RobotMsg\n\nfrom xnodes.nodes.base import Base\n\nnp.set_printoptions(suppress=True)  # no scientific notation\n\n\nclass ActionRepresentation(Enum):\n    ABS = \"absolute\"\n    REL = \"relative\"\n\n\n@dataclass\nclass ModelClientConfig:\n    host: str\n    port: str\n\n    rep: ActionRepresentation\n    task: str\n    # to use weigted average across time\n    ensemble: bool = False\n    # server: Server = Server.XGYM  # model server architecture\n\n\nNOMODEL = ModelClientConfig(\n    host=\"none\",\n    port=8000,\n    rep=ActionRepresentation.REL,\n    task=\"none\",\n    ensemble=False,\n)\n\n\nclass GaussianConv:\n    def __init__(self, kernel_size=5, std=1.0):\n        assert kernel_size % 2 == 1, \"kernel_size must be odd for symmetric smoothing\"\n        self.kernel_size = kernel_size\n        self.std = std\n        self.half_k = kernel_size // 2\n\n        # Create symmetric Gaussian kernel\n        x = np.arange(kernel_size) - self.half_k\n        self.kernel = np.exp(-0.5 * (x / std) ** 2)\n        self.kernel /= self.kernel.sum()\n\n        # Rolling buffer with symmetric size\n        self.buffer = deque(maxlen=kernel_size)\n\n    def __call__(self, x):\n        x = np.atleast_1d(x).astype(float)\n        result = []\n\n        if x.shape[0] == 1:\n            # Streaming mode: single value\n            self.buffer.append(x.item())\n            buffer_np = np.array(self.buffer)\n            i = len(buffer_np) - 1\n            start = max(0, i - self.half_k)\n            end = i + self.half_k + 1\n            k_start = self.half_k - (i - start)\n            k_end = k_start + (end - start)\n            values = buffer_np[start:end]\n            weights = self.kernel[k_start:k_end]\n            return np.average(values, weights=weights)\n\n        else:\n            # Batch mode: fill buffer and process entire sequence\n            self.buffer.clear()\n            self.buffer.extend(x.tolist())\n            buffer_np = np.array(self.buffer)\n            N = len(x)\n\n            for i in range(N):\n                start = max(0, i - self.half_k)\n                end = min(N, i + self.half_k + 1)\n                k_start = self.half_k - (i - start)\n                k_end = k_start + (end - start)\n                values = x[start:end]\n                weights = self.kernel[k_start:k_end]\n                result.append(np.average(values, weights=weights))\n\n            return np.array(result)\n\n\nclass MyClient(wcp.WebsocketClientPolicy):\n    def reset(self):\n        self.infer({\"reset\": True})\n\n\nclass Model(Base):\n    \"\"\"Recieves action from model server\"\"\"\n\n    def __init__(self, cfg: ModelClientConfig):\n        super().__init__(\"model\")\n        self.cfg = cfg\n\n        self.joints = None\n        self.pose = None\n        self.gripper = None\n        self.g = 1\n        self.gconv = GaussianConv(kernel_size=5, std=1.0)\n\n        self.req_hz = 20  # request from server frequency\n        self.cmd_hz = 100  # command frequency\n        self.resolution = 1  # every 2 predicted steps\n\n        self.data = {}\n        cams = [x for x in self.list_camera_topics() if any(k in x for k in [\"rs\", \"worm\"])]\n        self.build_cam_subs()\n\n        self.policy = MyClient(host=cfg.host, port=cfg.port)\n        self.policy.reset()\n        self._reset = True\n\n        self.targets = None\n\n        self.get_logger().info(\"Model Client Initialized.\")\n\n        self.moveit_sub = self.create_subscription(JointState, \"/xarm/joint_states\", self.set_joints, 10)\n        self.moveit_pose_sub = self.create_subscription(RobotMsg, \"/xarm/robot_states\", self.set_pose, 10)\n        self.gripper_sub = self.create_subscription(Float32MultiArray, \"/xgym/gripper\", self.set_gripper, 10)\n        # self.timer = self.create_timer(1, self.step)\n        self.publisher = self.create_publisher(Float32MultiArray, \"/gello/state\", 10)\n        self.timer = self.create_timer(1 / self.cmd_hz, self.command)\n\n        self._stop_event = threading.Event()\n        self._thread = threading.Thread(target=self._command_loop, daemon=True)\n        self._thread.start()\n        # self.stepper = self.create_timer(1 / self.req_hz, self.step)\n\n        # self.ds = tfds.load(\"xgym_duck_single\", split=\"train\")\n        # self.episode = self.ds.take(1)\n\n    def set_active(self, msg):\n        super().set_active(msg)\n        time.sleep(0.25)\n        self.reset()\n        time.sleep(0.25)\n\n        self.joints = None\n        self.poleaderse = None\n        self.gripper = None\n        self.targets = None\n\n    def set_gripper(self, msg: Float32MultiArray):\n        self.gripper = np.array(msg.data).astype(np.float32)\n\n    def set_pose(self, msg: RobotMsg):\n        \"\"\"\n        RobotMsg message has:\n            header: std_msgs/Header header\n            pose: List[float64]\n            ...others...\n        \"\"\"\n        self.pose = np.array(msg.pose).astype(np.float32)\n\n    def set_joints(self, msg: JointState):\n        \"\"\"\n        JointState message has:\n            header: std_msgs/Header header\n            name: List[string]\n            position: List[float64]\n            velocity: List[float64]\n            effort: List[float64]\n        \"\"\"\n\n        if len(msg.position) == 6:\n            return\n        self.joints = np.array(msg.position)\n        # self.joint_names = msg.name\n\n    def _command_loop(self):\n        rate = 1.0 / self.req_hz\n        while not self._stop_event.is_set():\n            tic = time.time()\n            self.step()\n            toc = time.time()\n            time.sleep(max(0, rate - (toc - tic)))\n\n    def destroy_node(self):\n        self._stop_event.set()\n        self._thread.join()\n        super().destroy_node()\n\n    def step(self):\n        if any(x is None for x in [self.joints, self.pose, self.gripper]):\n            return\n        if self.active is False:\n            if not self._reset:\n                self.policy.reset()\n                self._reset = True\n            # conat joints gripper\n            target = np.concatenate([self.joints, self.gripper], axis=-1)\n            self.targets = [target]\n            return\n\n        # example batch\n        # image_left_wrist: '(1, 1, 224, 224, 224) != (1, 1, 224, 224, 3)',\n        # image_primary: '(1, 1, 224, 224, 224) != (1, 1, 224, 224, 3)',\n        # proprio_single: '(1, 1, 1, 6) != (1, 1, 6)',\n\n        pose = self.pose\n\n        prefix = \"/xgym/camera/\"\n        imgs = {k: self.data.get(prefix + k) for k in [\"low\", \"side\", \"wrist\"]}\n\n        spec = lambda arr: jax.tree.map(lambda x: x.shape, arr)\n        # pprint(spec(imgs))\n\n        rad2deg = lambda x: x * 180 / np.pi\n        deg2rad = lambda x: x * np.pi / 180\n\n        if any(x is None for k, x in imgs.items()):\n            self.get_logger().info(f\"Missing images: {spec(imgs)}\")\n            return\n\n        pose[:3] /= 1000  # mm to m\n\n        try:\n            gripper = self.gripper\n            # gripper = np.array([0.99]) if gripper > 0.8 else gripper\n            assert gripper <= 1.0, \"Gripper out of bounds\"\n            state = np.concatenate([self.joints, gripper], axis=-1)\n        except Exception as e:\n            self.get_logger().info(f\"Gripper error: {e}\")\n            return\n\n        # pprint(state)\n        obs = {\n            \"pixels\": jax.tree.map(lambda x: x.astype(np.uint8), imgs),\n            \"agent_pos\": state,\n        }\n        obs = jax.tree.map(lambda x: x.reshape(1, *x.shape), obs)\n\n        # pprint(spec(obs))\n        payload = {\n            \"observation\": {\n                # 'image_high'\n                \"image_left_wrist\": obs[\"pixels\"][\"wrist\"][None],\n                \"image_primary\": obs[\"pixels\"][\"low\"][None],\n                \"image_side\": obs[\"pixels\"][\"side\"][None],\n                # 'proprio_single_arm' : pose.reshape(1,1,-1).astype(np.float32),\n                \"proprio_single_arm\": np.concatenate(\n                    [pose.reshape(1, 1, -1).astype(np.float32), state.reshape(1, 1, -1).astype(np.float32)], axis=-1\n                ),\n            },\n            \"ensemble\": False,\n        }\n\n        # pprint(payload['observation']['proprio_single_arm'])\n        # actions : dict= self.policy.infer(obs)\n        actions: dict = self.policy.infer(payload)\n        # pprint(spec(actions))\n\n        act = actions[\"action\"].copy()\n\n        np.set_printoptions(suppress=True, precision=2)\n        # pprint(np.minimum(1.0, act[:,-1]))\n        # pprint( act[:,-1])\n\n        # g = act[:, -1]\n        # act[:,-1] = np.where(g < 0.5, 0.3, g)\n        self.targets = act[:: self.resolution].copy()\n\n        # print( t.round(4))\n        # print(state.round(4))\n        # print()\n\n        \"\"\"\n        pprint(\n                jax.tree.map(\n                lambda x: x.round(4),\n                    {\n                        \"actions\": actions,\n                        \"joints\": self.joints,\n                        \"gripper\": self.gripper,\n                        },\n                    )\n                )\n        \"\"\"\n        return\n\n        quit()\n\n        # else: # no more uvicorn/fastapi\n        # observation = asdict(observation)\n        # actions = self.client(**observation)\n\n        ntile = 1\n        expanded = np.tile(actions, (ntile, 1))  # Repeat 4 times to get (200, 8)\n        # expanded[:,-1] *= 850\n        # expanded = actions.copy()\n\n        sigmoid = lambda x: 1 / (1 + np.exp(-x))\n        # gripper = np.clip(expanded[:, -1:], 0, 1)\n        gripper = np.clip(expanded[:, -1:], 0, 1)\n        # gripper = np.where(gripper > 0.5, 1, 0)\n\n        # g = gripper.mean()\n        # gripper = np.zeros_like(gripper) + g\n        # gripper = np.cumsum(gripper, axis=0) / np.arange(1, len(gripper) + 1)[:, None]\n\n        # print(gripper.flatten().round(2))\n        _grip = []\n        # print(gripper.flatten().tolist())\n        for g in gripper.flatten().tolist():\n            rate = 0.9\n            self.g = rate * self.g + (1 - rate) * g\n            _grip.append(self.g)\n\n        # gripper = self.gconv(np.array(_grip))[:, None]\n        gripper = np.array(_grip)[:, None]\n\n        # print(gripper.flatten().round(2))\n        # print()\n\n        # gripper @ 5hz\n        # n = len(gripper) // 3\n        # gripper = sum([[g] * n for g in gripper.tolist()[::n]], [])\n        # gripper = np.array(gripper).round(1)\n        # gripper = np.zeros_like(gripper) + gripper[n]\n\n        # gripper = np.ones_like(gripper)\n\n        # if self.cfg.rep == ActionRepresentation.REL:\n        expanded[:, :-1] /= ntile  # gripper stays the same\n        cumulants = np.cumsum(expanded[:, :-1], axis=0)\n        targets = cumulants + np.tile(self.joints, (len(cumulants), 1))\n        # if self.cfg.rep == ActionRepresentation.ABS:\n        # print(\"ABS\")\n        # targets = expanded[:, :-1]\n\n        targets = np.concatenate((targets, gripper), axis=1)\n\n        # print(self.joints.round(4))\n        # print(rad2deg(targets).round(4))\n\n        # from matplotlib import pyplot as plt\n        # fig,axs = plt.subplots(1,1)\n        # for i in range(targets.shape[1]):\n        # axs.plot(targets[:,i], label=f\"joint {i}\")\n\n        # plt.legend()\n        # plt.show()\n        # quit()\n\n        self.targets = targets\n\n    def reset(self):\n        self._reset = False  # send reset signal to thread\n\n    def command(self):\n        \"\"\"Publishes model action\"\"\"\n\n        if self.targets is None or len(self.targets) == 0:\n            if self.joints is None or self.gripper is None:\n                # print(\"No joints or gripper\")\n                return\n            target = np.concatenate([self.joints, self.gripper], axis=-1)\n            # self.step()\n            # return\n        else:\n            target, self.targets = self.targets[0], self.targets[1:]\n            # print(len(self.targets))\n\n        msg = Float32MultiArray()\n        msg.data = target.tolist()\n        self.publisher.publish(msg)\n\n\ndef main(cfg: ModelClientConfig):\n    pprint(cfg)\n\n    args = None\n    rclpy.init(args=args)\n\n    node = Model(cfg)\n\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        node.get_logger().info(\"Controller Node shutting down...\")\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\n\nif __name__ == \"__main__\":\n    main(tyro.parse(ModelClientConfig))\n"}\n{"instruction": "Write a ROS2 Python node named ps4_teleop.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "#!/usr/bin/env python3\n\"\"\"\nStart PS4 teleop.\n\"\"\"\nfrom multiprocessing import Process\nfrom dataclasses import dataclass\nimport math\n\nimport rclpy\nfrom ament_index_python.packages import get_package_share_directory\n\nfrom geometry_msgs.msg import TwistStamped\nfrom sensor_msgs.msg import Joy\nfrom std_srvs.srv import Trigger\n\nfrom moveit_configs_utils import MoveItConfigsBuilder\nfrom moveit.planning import MoveItPy, PlanRequestParameters\nfrom moveit.core.robot_state import RobotState\nfrom moveit.core.robot_state import RobotState\nfrom moveit.core.kinematic_constraints import construct_joint_constraint\nfrom moveit.servo_client.teleop import TeleopDevice\nfrom moveit.servo_client.devices.ps4_dualshock import PS4DualShock\n\nfrom xarm.wrapper import XArmAPI\n\nclass PS4DualShockTeleop(TeleopDevice):\n    \"A class which encapsulates teleoperation functionalities for ps4 dualshock device.\"\n\n    def __init__(\n        self,\n        ee_frame_name: str,\n        node_name: str = \"ps4_dualshock_teleop\",\n        device_name: str = \"ps4_dualshock\",\n        device_config: PS4DualShock = PS4DualShock(),\n    ):\n        super().__init__(\n            node_name=node_name,\n            device_name=device_name,\n            device_config=device_config,\n            ee_frame_name=ee_frame_name,\n        )\n        self.logger = rclpy.logging.get_logger(\"ps4_dualshock_teleop\")\n        \n        # hardcode the ip address for now\n        self.xarm = XArmAPI(\"192.168.1.156\")\n        \n        # status flags\n        self.gripper_open = True\n\n        # connect to xarm and enable motion\n        self.xarm.connect()\n        self.xarm.motion_enable(enable=True)\n\n\n    def publish_command(self, data):\n        \"\"\"\n        Publishes the teleop command.\n        \"\"\"\n        try:\n            # convert joy data to twist command\n            twist = TwistStamped()\n            twist.twist.linear.z = data.axes[self.device_config.Axes.RIGHT_STICK_Y]\n            twist.twist.linear.y = data.axes[self.device_config.Axes.RIGHT_STICK_X]\n\n            lin_x_right = -0.5 * (data.axes[self.device_config.Axes.RIGHT_TRIGGER])\n            lin_x_left = 0.5 * (data.axes[self.device_config.Axes.LEFT_TRIGGER])\n            twist.twist.linear.x = lin_x_right + lin_x_left\n\n            twist.twist.angular.y = data.axes[self.device_config.Axes.LEFT_STICK_Y]\n            twist.twist.angular.x = data.axes[self.device_config.Axes.LEFT_STICK_X]\n\n            roll_positive = data.buttons[self.device_config.Buttons.R1]\n            roll_negative = -1 * data.buttons[self.device_config.Buttons.L1]\n            twist.twist.angular.z = float(roll_positive + roll_negative)\n\n            twist.header.frame_id = self.ee_frame_name\n            twist.header.stamp = self.get_clock().now().to_msg()\n            self.twist_publisher.publish(twist)\n            \n            # open/close gripper\n            if data.buttons[self.device_config.Buttons.O] == 1:\n                if self.gripper_open:\n                    self.xarm.close_lite6_gripper()\n                    self.gripper_open = False\n                else:\n                    self.xarm.open_lite6_gripper()\n                    self.gripper_open = True\n\n            # stop gripper noise\n            if data.buttons[self.device_config.Buttons.TRIANGLE] == 1:\n                self.xarm.stop_lite6_gripper()\n\n        except Exception as e:\n            self.logger.info.error(e)\n            print(e)\n\n    def record():\n        pass\n\n\nif __name__==\"__main__\":\n    rclpy.init()\n    \n    # start moveit_py\n    moveit_config = (\n        MoveItConfigsBuilder(robot_name=\"lite6\", package_name=\"moveit_resources_lite6_moveit_config\")\n        .robot_description_semantic(file_path=\"config/lite6.srdf\")\n        .trajectory_execution(file_path=\"config/moveit_controllers.yaml\")\n        .robot_description(file_path=get_package_share_directory(\"moveit_resources_lite6_description\")\n                          + \"/urdf/lite6.urdf\")\n        .moveit_cpp(\n            file_path=get_package_share_directory(\"lite6_moveit_demos\")\n            + \"/config/moveit_cpp.yaml\"\n        )\n        .to_moveit_configs()\n    ).to_dict()\n\n    lite6 = MoveItPy(node_name=\"moveit_py\", config_dict=moveit_config)\n    lite6_arm = lite6.get_planning_component(\"lite6\")\n\n    # Instantiate and activate the teleop device\n    ps4 = PS4DualShockTeleop(ee_frame_name='link_eef', moveit=lite6)\n    ps4.start_teleop()\n\n    # TODO: incorporate shutdown teleop into button press\n    import time\n    time.sleep(100000.0)\n\n    # stop teleoperation and shutdown\n    ps4.stop_teleop()\n    ps4.destroy_node()\n    rclpy.shutdown()\n\n"}\n{"instruction": "Write a ROS2 Python node named pick_stack.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "#!/usr/bin/env python3\nimport rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import PoseStamped\nfrom moveit_commander import MoveGroupCommander, roscpp_initialize, roscpp_shutdown\n\nSTACK_POSE_0 = [0.3,0.0,.005]\n\nclass PickAndStack(Node):\n    def __init__(self):\n        super().__init__('pick_and_stack')\n        roscpp_initialize([])\n        self.group = MoveGroupCommander('arm')  # name from MoveIt SRDF\n        self.subscription = self.create_subscription(PoseStamped, '/tile_pose', self.callback, 10)\n        self.stack_height = 0.02  # meters between tiles\n        self.stack_count = 0\n\n    def callback(self, pose):\n        self.get_logger().info(f\"Received tile pose: {pose.pose.position}\")\n        pick_pose = pose.pose\n        stack_pose = PoseStamped()\n        stack_pose.header.frame_id = pose.header.frame_id\n        stack_pose.pose.position.x = STACK_POSE_0[0]\n        stack_pose.pose.position.y = STACK_POSE_0[1]\n        stack_pose.pose.position.z = STACK_POSE_0[2] + self.stack_height * self.stack_count\n        stack_pose.pose.orientation.w = 1.0\n\n        # Move to pick\n        self.group.set_pose_target(pick_pose)\n        plan1 = self.group.go(wait=True)\n        self.group.stop()\n        self.group.clear_pose_targets()\n\n        # Move to stack\n        self.group.set_pose_target(stack_pose.pose)\n        plan2 = self.group.go(wait=True)\n        self.group.stop()\n        self.group.clear_pose_targets()\n\n        if plan1 and plan2:\n            self.stack_count += 1\n            self.get_logger().info(f\"Stacked tile #{self.stack_count}\")\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = PickAndStack()\n    rclpy.spin(node)\n    roscpp_shutdown()\n    node.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"}\n{"instruction": "Write a ROS2 Python node named servo4c.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "#!usr/bin/env/python3\nimport math\nfrom geometry_msgs.msg import TransformStamped\nimport tf2_ros\nfrom std_msgs.msg import String ,Int32\nimport ast\nfrom math import cos, sin\nimport math, time\nfrom copy import deepcopy\nfrom pymoveit2 import MoveIt2\nimport rclpy\nfrom rclpy.task import Future\nimport tf2_ros\nfrom rclpy.callback_groups import ReentrantCallbackGroup\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import TwistStamped\nfrom pymoveit2.robots import ur5\nfrom rclpy.qos import (\n    QoSDurabilityPolicy,\n    QoSHistoryPolicy,\n    QoSProfile,\n    QoSReliabilityPolicy,\n)\nfrom linkattacher_msgs.srv import AttachLink\nfrom linkattacher_msgs.srv import DetachLink\n\n\n\narm_manipulator=None\nbox1=[]\nbox2=[]\nbox3=[]\ncurrent_position=None\nmessage=\"\"\nflag1=0\nflag=0\nlinear=[]\nangular=[]\nwrist_3_link_pose=[]\ndiff=[]\nmag=0.0\nunit_vector=[0.0,0.0,0.0]\n\n\n\nclass MagnetON(Node):\n    def __init__(self):\n        super().__init__('GripperMagnetON_client')\n\n    def runON(self, obj):\n        # Create a thread for the service client.\n        self.call_Attacher(obj, 'link', 'ur5', 'wrist_3_link')\n\n    def call_Attacher(self, model1_name, link1_name, model2_name, link2_name):\n        gripper_control = self.create_client(AttachLink, '/GripperMagnetON')\n\n        while not gripper_control.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info('EEF service not available, waiting again...')\n\n        req = AttachLink.Request()\n        req.model1_name = str(model1_name)\n        req.link1_name  = link1_name       \n        req.model2_name = model2_name       \n        req.link2_name  = link2_name \n        # Call the service asynchronously\n        future = gripper_control.call_async(req)\n        rclpy.spin_until_future_complete(self, future)\n        try:\n            response = future.result()\n            self.get_logger().info(response.message)\n        except Exception as e:\n            self.get_logger().error(\"Service call failed %r\" % (e,))\n\nclass MagnetOFF(Node):\n    def __init__(self):\n        super().__init__('GripperMagnetOFF_client')\n\n    def runOFF(self, obj):\n        self.call_Detacher(obj, 'link', 'ur5', 'wrist_3_link')\n\n    def call_Detacher(self, model1_name, link1_name, model2_name, link2_name):\n        gripper_control = self.create_client(DetachLink, '/GripperMagnetOFF')\n\n        while not gripper_control.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info('EEF service not available, waiting again...')\n\n        req = DetachLink.Request()\n        req.model1_name = str(model1_name)\n        req.link1_name  = link1_name       \n        req.model2_name = model2_name       \n        req.link2_name  = link2_name \n        future = gripper_control.call_async(req)\n        rclpy.spin_until_future_complete(self, future)\n        try:\n            response = future.result()\n            self.get_logger().info(response.message)\n        except Exception as e:\n            self.get_logger().error(\"Service call failed %r\" % (e,))\n\n\n\n\n\nclass Arm_Manipulator(Node):\n    def __init__(self):\n        super().__init__(\"Arm_servoing\")\n        self.__twist_pub = self.create_publisher(TwistStamped, \"/servo_node/delta_twist_cmds\", 10)\n        self.get_logger().info('Node created: Arm_Manipulator')\n        self.callbackgroup=ReentrantCallbackGroup()\n        # Initialize message based on passed arguments \n        self.__twist_msg = TwistStamped()\n        self.__twist_msg.header.frame_id = ur5.base_link_name()\n        self.__twist_msg.twist.linear.x = 1.0\n        self.__twist_msg.twist.linear.y = 1.0\n        self.__twist_msg.twist.linear.z = 1.0\n        self.__twist_msg.twist.angular.x = 1.0\n        self.__twist_msg.twist.angular.y = 1.0\n        self.__twist_msg.twist.angular.z = 1.0\n        self.timer1 = self.create_timer(0.008, self.servo_circular_motion)\n        self.tf_buffer = tf2_ros.buffer.Buffer()\n        self.listener = tf2_ros.TransformListener(self.tf_buffer, self)\n        self.callbakgroup=ReentrantCallbackGroup()\n    def servo_circular_motion(self):\n        box_position = current_position\n        print(box_position)\n        while True:\n            try:\n                self.t2 = self.tf_buffer.lookup_transform('base_link','wrist_3_link', rclpy.time.Time())\n                global wrist_3_link_pose, diff, mag, unit_vector\n                wrist_3_link_pose = [self.t2.transform.translation.x, self.t2.transform.translation.y, self.t2.transform.translation.z]\n                diff = [box_position[0] - wrist_3_link_pose[0], box_position[1] - wrist_3_link_pose[1], box_position[2] - wrist_3_link_pose[2]]\n                mag = math.sqrt((diff[0]**2 + diff[1]**2 + diff[2]**2))\n                unit_vector = [diff[0]/mag, diff[1]/mag, diff[2]/mag]\n                self.get_logger().info(f'Successfully listened to tf unit vector :{unit_vector} distance : {mag}')\n                break\n            except tf2_ros.LookupException as e:\n                self.get_logger().info(f\"LookupException: {e}\")\n                break\n            except tf2_ros.ConnectivityException as e2:\n                self.get_logger().info(f\"ConnectivityException: {e2}\")\n                break\n        self.twist_msg = deepcopy(self.__twist_msg)\n        self.twist_msg.header.stamp = self.get_clock().now().to_msg()\n        global linear, angular\n        linear=unit_vector\n        angular=[0.0,0.0,0.0]\n        if unit_vector==[0.0,0.0,0.0]:\n            self.get_logger().info('Skipped')\n            return\n        if mag < 0.1:\n            self.twist_msg.twist.linear.x *= 0.0\n            self.twist_msg.twist.linear.y *= 0.0\n            self.twist_msg.twist.linear.z *= 0.0\n            self.twist_msg.twist.angular.x *= 0.0\n            self.twist_msg.twist.angular.y *= 0.0\n            self.twist_msg.twist.angular.z *= 0.0\n            self.__twist_pub.publish(self.twist_msg)\n            global flag\n            flag=1\n        else:\n            self.twist_msg.twist.linear.x *= linear[0]\n            self.twist_msg.twist.linear.y *= linear[1]\n            self.twist_msg.twist.linear.z *= linear[2]\n            self.twist_msg.twist.angular.x *= angular[0]\n            self.twist_msg.twist.angular.y *= angular[1]\n            self.twist_msg.twist.angular.z *= angular[2]\n            self.__twist_pub.publish(self.twist_msg)\n            self.get_logger().info('Successfully published to twist')\n\n\n\ndef main():\n        try:\n            while True:\n                rclpy.init()\n                \n                callback_group = ReentrantCallbackGroup()\n                node= Node(\"task_4A\")\n                node.get_logger().info('Node created: Task_2A') \n\n                def flag_callback(msg):\n                    try:\n                        global flag1\n                        flag1 = msg.data  # Get the string data from the message\n                        \n                        print(flag1)\n                        node.destroy_subscription(tf_subscription)\n                    except Exception as e:\n                        print(\"Error :\", e)\n                    # Create a TF subscriber within the main method\n                flag_subscription = node.create_subscription(\n                Int32,\n                '/flag',\n                flag_callback,\n                10\n                )\n\n                rclpy.spin_once(node)\n                if flag1==1:\n                    global box1, box2, box3, current_position, flag, arm_manipulator\n                    def message_callback(msg):\n                        try:\n                            global message, box1, box2, box3\n                            message = msg.data  # Get the string data from the message\n                            message = ast.literal_eval(message)\n                            print(message)\n\n                            # Iterating through the main list and storing each sublist separately\n                            for sublist in message:\n                                if sublist is not None:\n                                    if isinstance(sublist, list):\n                                        if len(sublist) == 0:\n                                            continue\n                                        if sublist == message[0]:\n                                            box1 = list(sublist)\n                                        elif sublist == message[1]:\n                                            box2 = list(sublist)\n                                        elif sublist == message[2]:\n                                            box3 = list(sublist)\n\n                            # Displaying the stored sublists separately\n                            print(\"Sublist 1:\", box1)\n                            print(\"Sublist 2:\", box2)\n                            print(\"Sublist 3:\", box3)\n                            node.destroy_subscription(tf_subscription)\n                        except Exception as e:\n                            print(\"Error while converting message:\", e)\n                        # Create a TF subscriber within the main method\n                    tf_subscription = node.create_subscription(\n                    String,\n                    '/topic',\n                    message_callback,\n                    10\n                    )\n\n                    rclpy.spin_once(node)\n\n\n                    if box1: \n                        node.declare_parameter(\n                        \"turn_pose1\",\n                        [\n                            -math.radians(box1[7]),\n                            -2.23402,\n                            1.98968,\n                            -2.93215,\n                            -1.58825,\n                            3.14159\n                        ],\n                        )\n                    if box2: \n                        node.declare_parameter(\n                        \"turn_pose2\",\n                        [\n                            -math.radians(box2[7]),\n                            -2.23402,\n                            1.98968,\n                            -2.93215,\n                            -1.58825,\n                            3.14159\n                        ],\n                        )\n                    if box3: \n                        node.declare_parameter(\n                        \"turn_pose3\",\n                        [\n                            -math.radians(box3[7]),\n                            -2.23402,\n                            1.98968,\n                            -2.93215,\n                            -1.58825,\n                            3.14159\n                        ],\n                        )\n                    node.declare_parameter(\n                    \"home_pose\",\n                    [\n                        -0.261799,\n                        -2.47837,\n                        2.40855,\n                        -3.14159,\n                        -1.58825,\n                        3.14159\n                    ],\n                    )\n\n                    node.declare_parameter(\n                    \"drop_pose\",\n                    [\n                        0.0,\n                        -1.81514,\n                        -1.3090,\n                        -3.07178,\n                        -1.58825,\n                        3.14159\n                    ],\n                    )      \n\n                    # Create MoveIt 2 interface\n                    moveit2 = MoveIt2(\n                        node=node,\n                        joint_names=ur5.joint_names(),\n                        base_link_name=ur5.base_link_name(),\n                        end_effector_name=ur5.end_effector_name(),\n                        group_name=ur5.MOVE_GROUP_ARM,\n                        callback_group=callback_group,\n                    )\n\n                    if box1:\n                        joint_positions1 = (\n                            node.get_parameter(\"turn_pose1\").get_parameter_value().double_array_value\n                        )\n                    \n                    if box2:\n                        joint_positions4 = (\n                            node.get_parameter(\"turn_pose2\").get_parameter_value().double_array_value\n                        )\n\n                    if box3:\n                        joint_positions5 = (\n                            node.get_parameter(\"turn_pose3\").get_parameter_value().double_array_value\n                        )\n\n                    joint_positions2 = (\n                        node.get_parameter(\"home_pose\").get_parameter_value().double_array_value\n                    )\n\n                    joint_positions3 = (\n                        node.get_parameter(\"drop_pose\").get_parameter_value().double_array_value\n                    )\n\n                    if box1:\n                        # Move to joint configuration\n                        node.get_logger().info(f\"Moving to {{joint_positions: {list(joint_positions1)}}}\")\n                        moveit2.move_to_configuration(joint_positions1)\n                        #moveit2.wait_until_executed()\n                        time.sleep(3.0)\n\n                        current_position = box1[1]\n                        arm_manipulator = Arm_Manipulator()\n\n                        while flag == 0:\n                            rclpy.spin_once(arm_manipulator)\n                        flag=0\n                        time.sleep(1.0)\n\n                        current_position = box1[2]\n                        while flag == 0:\n                            rclpy.spin_once(arm_manipulator)\n                        flag=0\n                        time.sleep(1.0)\n\n                        current_position = box1[3]\n                        while flag == 0:\n                            rclpy.spin_once(arm_manipulator)\n                        flag=0\n                        time.sleep(2.0)\n\n\n                        magnet_ON = MagnetON()\n                        magnet_ON.runON(box1[0])\n                        time.sleep(2.0)\n                    \n                        current_position = box1[2]\n                        while flag == 0:\n                            rclpy.spin_once(arm_manipulator)\n                        flag=0\n                        time.sleep(1.0)\n\n                        current_position = box1[1]\n                        while flag == 0:\n                            rclpy.spin_once(arm_manipulator)\n                        flag=0\n                        time.sleep(1.0)\n\n                        node.get_logger().info(f\"Moving to {{joint_positions: {list(joint_positions2)}}}\")\n                        moveit2.move_to_configuration(joint_positions2)\n                        time.sleep(3.0)\n\n                        node.get_logger().info(f\"Moving to {{joint_positions: {list(joint_positions3)}}}\")\n                        moveit2.move_to_configuration(joint_positions3)\n                        time.sleep(10.0)\n\n                        magnet_OFF = MagnetOFF()\n                        magnet_OFF.runOFF(box1[0])\n                            \n                        node.get_logger().info(f\"Moving to {{joint_positions: {list(joint_positions2)}}}\")\n                        moveit2.move_to_configuration(joint_positions2)\n                        time.sleep(2.0)\n\n\n\n                    if box2:\n                        # Move to joint configuration\n                        node.get_logger().info(f\"Moving to {{joint_positions: {list(joint_positions4)}}}\")\n                        moveit2.move_to_configuration(joint_positions4)\n                        #moveit2.wait_until_executed()\n                        time.sleep(7.0)\n\n                        current_position = box2[1]\n                        if not box1:\n                            arm_manipulator = Arm_Manipulator()\n\n                        while flag == 0:\n                            rclpy.spin_once(arm_manipulator)\n                        flag=0\n                        time.sleep(1.0)\n\n                        current_position = box2[2]\n                        while flag == 0:\n                            rclpy.spin_once(arm_manipulator)\n                        flag=0\n                        time.sleep(1.0)\n\n                        current_position = box2[3]\n                        while flag == 0:\n                            rclpy.spin_once(arm_manipulator)\n                        flag=0\n                        time.sleep(2.0)\n\n\n                        magnet_ON = MagnetON()\n                        magnet_ON.runON(box2[0])\n                        time.sleep(2.0)\n\n                        current_position = box2[2]\n                        while flag == 0:\n                            rclpy.spin_once(arm_manipulator)\n                        flag=0\n                        time.sleep(1.0)\n\n                        current_position = box2[1]\n                        while flag == 0:\n                            rclpy.spin_once(arm_manipulator)\n                        flag=0\n                        time.sleep(1.0)\n\n                        node.get_logger().info(f\"Moving to {{joint_positions: {list(joint_positions2)}}}\")\n                        moveit2.move_to_configuration(joint_positions2)\n                        time.sleep(3.0)\n\n                        node.get_logger().info(f\"Moving to {{joint_positions: {list(joint_positions3)}}}\")\n                        moveit2.move_to_configuration(joint_positions3)\n                        time.sleep(5.0)\n                        magnet_OFF = MagnetOFF()\n                        magnet_OFF.runOFF(box2[0])\n\n                            \n                        node.get_logger().info(f\"Moving to {{joint_positions: {list(joint_positions2)}}}\")\n                        moveit2.move_to_configuration(joint_positions2)\n                        time.sleep(2.0)\n\n                    if box3:\n                        # Move to joint configuration\n                        node.get_logger().info(f\"Moving to {{joint_positions: {list(joint_positions5)}}}\")\n                        moveit2.move_to_configuration(joint_positions5)\n                        #moveit2.wait_until_executed()\n                        time.sleep(7.0)\n\n                        current_position = box3[1]\n                        if not box1 and box2:\n                            arm_manipulator = Arm_Manipulator()\n\n                        while flag == 0:\n                            rclpy.spin_once(arm_manipulator)\n                        flag=0\n                        time.sleep(1.0)\n\n                        current_position = box3[2]\n                        while flag == 0:\n                            rclpy.spin_once(arm_manipulator)\n                        flag=0\n                        time.sleep(1.0)\n\n                        current_position = box3[3]\n                        while flag == 0:\n                            rclpy.spin_once(arm_manipulator)\n                        flag=0\n                        time.sleep(2.0)\n\n\n                        magnet_ON = MagnetON()\n                        magnet_ON.runON(box3[0])\n                        time.sleep(2.0)\n                    \n                        current_position = box2[2]\n                        while flag == 0:\n                            rclpy.spin_once(arm_manipulator)\n                        flag=0\n                        time.sleep(1.0)\n\n                        current_position = box3[1]\n                        while flag == 0:\n                            rclpy.spin_once(arm_manipulator)\n                        flag=0\n                        time.sleep(1.0)\n\n                        node.get_logger().info(f\"Moving to {{joint_positions: {list(joint_positions2)}}}\")\n                        moveit2.move_to_configuration(joint_positions2)\n                        time.sleep(3.0)\n\n                        node.get_logger().info(f\"Moving to {{joint_positions: {list(joint_positions3)}}}\")\n                        moveit2.move_to_configuration(joint_positions3)\n                        time.sleep(5.0)\n                        magnet_OFF = MagnetOFF()\n                        magnet_OFF.runOFF(box3[0])\n\n                            \n                        node.get_logger().info(f\"Moving to {{joint_positions: {list(joint_positions2)}}}\")\n                        moveit2.move_to_configuration(joint_positions2)\n                        time.sleep(2.0)\n\n                # Spin the node in background thread(s)\n                    executor = rclpy.executors.MultiThreadedExecutor(2)\n                    executor.add_node(node)\n                    executor.spin_once()\n                \n        # Shutdown nodes and the executor when exiting\n        except KeyboardInterrupt:\n            node.get_logger().info(\"Keyboard interrupt detected. Exiting...\")\n        except Exception as e:\n            if 'node' in locals():\n                node.get_logger().error(f\"An exception occurred: {str(e)}\")\n        finally:\n        # Cleanup operations\n            if 'node' in locals():\n                node.destroy_node()\n            if 'Arm_servoing' in locals():\n                arm_manipulator.destroy_node()\n        rclpy.shutdown()\n        exit(0)\n\n        \nif __name__ == '__main__':\n\n    main()"}\n{"instruction": "Write a ROS2 Python node named arm.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "#!/usr/bin/env python3\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import Image, CameraInfo\nfrom yolo_msgs.msg import DetectionArray\nfrom cv_bridge import CvBridge\nfrom geometry_msgs.msg import PoseStamped, Twist\nfrom pymoveit2 import MoveIt2\nfrom trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint\nfrom tf2_ros import Buffer, TransformListener, LookupException, TransformException\nfrom tf2_geometry_msgs.tf2_geometry_msgs import do_transform_pose\nfrom message_filters import ApproximateTimeSynchronizer, Subscriber\nimport numpy as np\nimport time\nimport subprocess\nimport threading\n\n\nclass ArmExecutor(Node):\n    def __init__(self):\n        super().__init__('arm_node')\n\n        self.target_label = 'paracetamol'\n        self.bridge = CvBridge()\n        self.fx = self.fy = self.cx = self.cy = None\n        self.last_pose = None\n        self.arm_triggered = False\n        self.finalized = False\n        self.pose_ready = False\n        self.execution_failed = False\n        self.start_time = None\n\n        self.tf_buffer = Buffer()\n        self.tf_listener = TransformListener(self.tf_buffer, self)\n\n        self.cmd_vel_pub = self.create_publisher(Twist, '/cmd_vel', 10)\n        self.gripper_pub = self.create_publisher(JointTrajectory, '/gripper_controller/joint_trajectory', 10)\n\n        self.moveit2 = MoveIt2(\n            node=self,\n            group_name=\"arm_torso\",\n            end_effector_name=\"arm_tool_link\",\n            base_link_name=\"torso_lift_link\",\n            joint_names=[\n                \"torso_lift_joint\", \"arm_1_joint\", \"arm_2_joint\", \"arm_3_joint\",\n                \"arm_4_joint\", \"arm_5_joint\", \"arm_6_joint\", \"arm_7_joint\"\n            ]\n        )\n\n        self.create_subscription(CameraInfo, \"/head_front_camera/depth/camera_info\", self.info_cb, 1)\n\n        det_sub = Subscriber(self, DetectionArray, \"/yolo/detections\", qos_profile=10)\n        depth_sub = Subscriber(self, Image, \"/head_front_camera/depth/image_raw\", qos_profile=10)\n        self.sync = ApproximateTimeSynchronizer([det_sub, depth_sub], queue_size=10, slop=0.3)\n        self.sync.registerCallback(self.synced_cb)\n\n        self.create_timer(0.5, self.try_motion)\n        self.get_logger().info(\"🤖 Arm node initialized and waiting for 'paracetamol'...\")\n\n    def info_cb(self, msg):\n        if self.fx is None:\n            self.fx = msg.k[0]\n            self.fy = msg.k[4]\n            self.cx = msg.k[2]\n            self.cy = msg.k[5]\n            self.get_logger().info(\"📸 Camera intrinsics received.\")\n\n    def synced_cb(self, det_msg, depth_msg):\n        if self.fx is None:\n            return\n\n        for det in det_msg.detections:\n            if det.class_name.lower() == self.target_label:\n                cx = int(det.bbox.center.position.x)\n                cy = int(det.bbox.center.position.y)\n\n                depth_image = self.bridge.imgmsg_to_cv2(depth_msg, desired_encoding=\"passthrough\")\n                depth_val = float(np.nan_to_num(depth_image[cy, cx], nan=0.0))\n\n                if 0.1 < depth_val < 2.5:\n                    X = round((cx - self.cx) * depth_val / self.fx, 3)\n                    Y = round((cy - self.cy) * depth_val / self.fy, 3)\n                    Z = round(depth_val, 3)\n\n                    pose = PoseStamped()\n                    pose.header.stamp = depth_msg.header.stamp\n                    pose.header.frame_id = \"head_front_camera_color_optical_frame\"\n                    pose.pose.position.x = X\n                    pose.pose.position.y = Y\n                    pose.pose.position.z = Z\n                    pose.pose.orientation.w = 1.0\n\n                    try:\n                        tf = self.tf_buffer.lookup_transform(\"base_footprint\", pose.header.frame_id, rclpy.time.Time())\n                        pose_base = PoseStamped()\n                        pose_base.header = tf.header\n                        pose_base.pose = do_transform_pose(pose.pose, tf)\n\n                        pos = pose_base.pose.position\n                        self.last_pose = pose_base\n\n                        if self.is_reachable_pose(pos):\n                            self.pose_ready = True\n                            self.get_logger().info(f\"📌 Good pose: x={pos.x:.2f}, y={pos.y:.2f}, z={pos.z:.2f}\")\n                        else:\n                            self.pose_ready = False\n                            self.get_logger().warn(f\"❌ Unreachable pose: x={pos.x:.2f}, z={pos.z:.2f}\")\n                    except (LookupException, TransformException) as e:\n                        self.get_logger().warn(f\"❌ TF failed: {str(e)}\")\n                else:\n                    self.get_logger().warn(\"⚠️ Invalid depth value.\")\n\n    def is_reachable_pose(self, pos):\n        return pos.x > 0.1 and pos.z > 0.3\n\n    def try_motion(self):\n        if self.arm_triggered or self.finalized or self.execution_failed:\n            return\n\n        if self.pose_ready:\n            position = self.last_pose.pose.position\n            orientation = self.last_pose.pose.orientation\n            self.get_logger().info(\n                f\"🎯 Executing MoveIt to: x={position.x:.3f}, y={position.y:.3f}, z={position.z:.3f}, \"\n                f\"q=({orientation.x:.2f}, {orientation.y:.2f}, {orientation.z:.2f}, {orientation.w:.2f})\"\n            )\n            try:\n                self.moveit2.move_to_pose(self.last_pose)  # CORRECTED\n                self.arm_triggered = True\n                self.start_time = time.time()\n                self.create_timer(0.5, self.monitor_execution)\n            except Exception as e:\n                self.get_logger().error(f\"🚨 MoveIt2 execution error: {str(e)}\")\n                self.execution_failed = True\n                self.ask_user_for_next_step()\n        else:\n            self.rotate_robot()\n\n    def rotate_robot(self):\n        twist = Twist()\n        twist.angular.z = 0.3\n        self.cmd_vel_pub.publish(twist)\n        self.get_logger().info(\"🔁 Rotating to search for reachable pose...\")\n\n    def monitor_execution(self):\n        if not self.arm_triggered or self.finalized:\n            return\n\n        if self.moveit2.is_executed():\n            self.get_logger().info(\"✅ MoveIt executed. Closing gripper.\")\n            self.close_gripper()\n            self.finalize_task()\n        elif time.time() - self.start_time > 10:\n            self.get_logger().warn(\"❌ MoveIt execution timeout.\")\n            self.arm_triggered = False  # allow retry\n            self.execution_failed = True\n            self.ask_user_for_next_step()\n\n    def ask_user_for_next_step(self):\n        def prompt():\n            print(\"❓ MoveIt execution timed out or failed.\")\n            ans = input(\"Would you like to continue execution of table.py? (y/n): \").strip().lower()\n            if ans == 'y':\n                self.get_logger().info(\"📥 User chose to proceed with table.py\")\n                self.finalize_task()\n            elif ans == 'n':\n                self.get_logger().info(\"⏸️ Execution paused. You can retry or kill manually.\")\n            else:\n                self.get_logger().warn(\"⚠️ Invalid input. Staying idle.\")\n\n        threading.Thread(target=prompt, daemon=True).start()\n\n    def close_gripper(self):\n        traj = JointTrajectory()\n        traj.joint_names = [\"gripper_left_finger_joint\", \"gripper_right_finger_joint\"]\n        point = JointTrajectoryPoint()\n        point.positions = [0.01, 0.01]\n        point.time_from_start.sec = 1\n        traj.points.append(point)\n        traj.header.stamp = self.get_clock().now().to_msg()\n        self.gripper_pub.publish(traj)\n        self.get_logger().info(\"🤏 Gripper command sent.\")\n\n    def finalize_task(self):\n        if self.finalized:\n            return\n        self.finalized = True\n\n        try:\n            self.get_logger().info(\"🧭 Launching table.py as next step...\")\n            subprocess.Popen([\"python3\", \"table.py\"])\n        except Exception as e:\n            self.get_logger().error(f\"❌ Failed to launch table.py: {str(e)}\")\n\n        self.get_logger().info(\"🛑 Task complete. Shutting down.\")\n        self.destroy_node()\n        rclpy.shutdown()\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = ArmExecutor()\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        node.finalize_task()\n    finally:\n        if rclpy.ok():\n            node.destroy_node()\n            rclpy.shutdown()\n\n\nif __name__ == \"__main__\":\n    main()\n\n"}\n{"instruction": "Write a ROS2 Python node named planning_scene_block_gt.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "#!/usr/bin/env python\n\n\"\"\"\nCS 6341 Homework 3 Programming\nPlanning scene, FK and IK\n\"\"\"\n\nimport rclpy\nfrom rclpy.node import Node\nfrom rclpy.callback_groups import ReentrantCallbackGroup\nfrom rclpy.task import Future\nfrom geometry_msgs.msg import Pose\nfrom sensor_msgs.msg import JointState\n\nfrom pymoveit2 import MoveIt2\nfrom pymoveit2.robots import fetch as robot\n\nimport numpy as np\nfrom transforms3d.quaternions import mat2quat, quat2mat\n\n\ndef ros_quat(tf_quat): #wxyz -> xyzw\n    quat = np.zeros(4)\n    quat[-1] = tf_quat[0]\n    quat[:-1] = tf_quat[1:]\n    return quat\n\n\n# Convert quaternion and translation to a 4x4 tranformation matrix\n# See Appendix B.3 in Lynch and Park, Modern Robotics for the definition of quaternion\ndef ros_qt_to_rt(rot, trans):\n    qt = np.zeros((4,), dtype=np.float32)\n    qt[0] = rot[3]\n    qt[1] = rot[0]\n    qt[2] = rot[1]\n    qt[3] = rot[2]\n    obj_T = np.eye(4)\n    obj_T[:3, :3] = quat2mat(qt)\n    obj_T[:3, 3] = trans\n\n    return obj_T\n\n\n# Convert a ROS pose message to a 4x4 tranformation matrix\ndef ros_pose_to_rt(pose):\n    qarray = [0, 0, 0, 0]\n    qarray[0] = pose.orientation.x\n    qarray[1] = pose.orientation.y\n    qarray[2] = pose.orientation.z\n    qarray[3] = pose.orientation.w\n\n    t = [0, 0, 0]\n    t[0] = pose.position.x\n    t[1] = pose.position.y\n    t[2] = pose.position.z\n\n    return ros_qt_to_rt(qarray, t)\n\n\ndef get_message_once(node, topic_name, msg_type, timeout=5.0):\n    future = Future()\n\n    def callback(msg):\n        if not future.done():\n            future.set_result(msg)\n            node.destroy_subscription(sub)\n\n    sub = node.create_subscription(msg_type, topic_name, callback, 10)\n\n    # Spin this node until a message is received or timeout\n    rclpy.spin_until_future_complete(node, future, timeout_sec=timeout)\n\n    return future.result() if future.done() else None\n\n\nMODEL = 'cube'\nROBOT = 'fetch'\n\n# Query pose of frames from the Gazebo environment\ndef get_pose_gazebo(node):\n\n    pose_model = get_message_once(node, f'/model/{MODEL}/pose', Pose, timeout=2.0)\n    # convert the cube pose in world frame T_wo\n    T_wo = ros_pose_to_rt(pose_model)\n    print('T_wo', T_wo)\n\n    pose_robot = get_message_once(node, f'/model/{ROBOT}/pose', Pose, timeout=2.0)\n    # convert the robot pose in world frame T_wb\n    T_wb = ros_pose_to_rt(pose_robot)\n    print('T_wb', T_wb)\n    \n    # compute the object pose in robot base link T_bo\n    T_bo = np.matmul(np.linalg.inv(T_wb), T_wo)\n    return T_bo\n\n\ndef get_current_joint_states(node):\n    \"\"\"Return one JointState message from /joint_states, or None if timeout.\"\"\"\n    msg = get_message_once(node, '/joint_states', JointState, timeout=2.0)\n    print(msg)\n\n    # get the joint names in the Fetch robot group\n    names = robot.joint_names()\n    joint_positions = extract_specific_joints(msg, names)\n    return joint_positions\n\n\n# extract the joint positions from the msg\ndef extract_specific_joints(msg, names):\n    joint_positions = np.zeros((len(names), ), np.float32)\n    for (i, name) in enumerate(names):\n        joint_positions[i] = msg.position[msg.name.index(name)]\n        print(name, joint_positions[i])\n    return joint_positions    \n\n    \nif __name__ == \"__main__\":\n    \"\"\"\n    Main function to run the code\n    \"\"\"\n\n    rclpy.init()\n\n    # Create node for this example\n    node = Node(\"cs6341_homework3\")    \n\n    # Create callback group that allows execution of callbacks in parallel without restrictions\n    callback_group = ReentrantCallbackGroup()\n\n    # Create MoveIt 2 interface\n    moveit2 = MoveIt2(\n        node=node,\n        joint_names=robot.joint_names(),\n        base_link_name=robot.base_link_name(),\n        end_effector_name=robot.end_effector_name(),\n        group_name=robot.MOVE_GROUP_ARM,\n        callback_group=callback_group,\n    )    \n    \n    # query the pose of the cube\n    T_bo = get_pose_gazebo(node)\n    print('T_bo', T_bo)\n\n    # add a collision box in moveit scene for the cube\n    object_id = 'cube'\n    position = T_bo[:3, 3]\n    dimensions = [0.06, 0.06, 0.06]\n    quat_xyzw = ros_quat(mat2quat(T_bo[:3, :3]))\n    moveit2.add_collision_box(\n        id=object_id, position=position, quat_xyzw=quat_xyzw, size=dimensions\n    )\n\n    # get the current robot joints\n    joint_positions = get_current_joint_states(node)\n    print(joint_positions)\n\n    # forward kinematics\n    retval = None\n    retval = moveit2.compute_fk(joint_positions)\n    if retval is None:\n        print(\"Forward kinematics failed.\")\n    else:\n        print(\"Forward kinematics succeeded. Result: \" + str(retval))\n        print(\"---------------------------\")\n        # extract the pose for the result\n        p = retval.pose.position\n        q = retval.pose.orientation\n        print(f\"{robot.end_effector_name()} in {retval.header.frame_id}: \"\n              f\"pos=({p.x:.4f}, {p.y:.4f}, {p.z:.4f}), \"\n              f\"quat=({q.x:.4f}, {q.y:.4f}, {q.z:.4f}, {q.w:.4f})\")             \n\n        # compute IK using the end-effector pose\n        print(\"---------------------------\")\n        retval_ik = None\n        retval_ik = moveit2.compute_ik(p, q)\n        if retval_ik is None:\n            print(\"Inverse kinematics failed.\")\n        else:\n            print(\"Inverse kinematics succeeded. Result: \" + str(retval_ik))\n\n            # extract the arm joints\n            print(\"---------------------------\")\n            names = robot.joint_names()\n            joint_positions_ik = extract_specific_joints(retval_ik, names)\n\n            # compute the distances between joints\n            distance = np.linalg.norm(joint_positions - joint_positions_ik)\n            print('joint distance:', distance)"}\n{"instruction": "Write a ROS2 Python node named url_list.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "crawl_urls = [\n  # ROS2\n    # github\n    \"https://github.com/ros2/rcl\",\n    # \"https://github.com/ros2/rcl_interfaces\",\n    # \"https://github.com/ros2/rclcpp\",\n    # \"https://www.youtube.com/watch?v=Gg25GfA456o\",\n    # \"https://www.youtube.com/watch?v=c5DRTN2b2kY\",\n\n    # \"https://github.com/ros2/rclpy\",\n    # \"https://github.com/ros2/rcpputils\",\n    # \"https://github.com/ros2/rcutils\",\n    # \"https://www.youtube.com/watch?v=DnWu6iVcVRU\",\n    # \"https://www.youtube.com/watch?v=WxskRU5KjVQ\",\n\n    # \"https://github.com/ros2/rmw\",\n    # \"https://github.com/ros2/ros2_documentation\", \n    # \"https://github.com/ros2/ros2cli\",\n    # \"https://www.youtube.com/watch?v=MJnfuoTHR_g\",\n     \n\n\n  # nav2\n    # github\n    # \"https://github.com/ros-navigation/navigation2\",\n    # \"https://github.com/ros-navigation/docs.nav2.org\",\n    \"https://github.com/ros-navigation/navigation2_tutorials\",\n    # \"https://www.youtube.com/watch?v=idQb2pB-h2Q\",\n    # \"https://www.youtube.com/watch?v=KIbgZqfppAI\",\n\n    # \"https://github.com/ros-navigation/nav2_docker\",\n    # \"https://github.com/ros-navigation/nav2_minimal_turtlebot_simulation\",\n    # \"https://github.com/ros-navigation/nav2.org\",\n    # \"https://www.youtube.com/watch?v=GSuqO0p2mIk\",\n    # \"https://www.youtube.com/watch?v=6CO58W3i1h8\",\n\n    # \"https://github.com/ros-navigation/navigation2_dynamic\",\n    # \"https://github.com/ros-navigation/navigation2_auxiliary\",\n    # \"https://www.youtube.com/watch?v=jkoGkAd0GYk\",\n\n\n  # movit2\n    # github\n    \"https://github.com/moveit/moveit_task_constructor\",\n    # \"https://www.youtube.com/watch?v=k85fH0snRm8\",\n    # \"https://www.youtube.com/watch?v=GuOgQzuwNB0\",\n\n    # \"https://github.com/moveit/moveit_visual_tools\",\n    # \"https://github.com/moveit/moveit_msgs\",\n    # \"https://www.youtube.com/watch?v=mssxW3VJ1IQ\",\n    # \"https://www.youtube.com/watch?v=kR7w5uvykRg\",\n\n    # \"https://github.com/moveit/moveit_drake\",\n    # \"https://github.com/moveit/moveit_middleware_benchmark\",\n    # \"https://www.youtube.com/watch?v=2K5l_mIEzcw\",\n\n\n  # gazebo\n    # github\n    # \"https://github.com/gazebosim/gz-sim\",\n    # \"https://github.com/gazebosim/gz-math\",\n    # \"https://github.com/gazebosim/gz-plugin\",\n    # \"https://www.youtube.com/watch?v=E7njvQ5BDPg\",\n    # \"https://www.youtube.com/watch?v=PM_1Nb9u-N0\", \n\n    # \"https://github.com/gazebosim/gz-gui\",\n    # \"https://github.com/gazebosim/gz-tools\",\n    # \"https://github.com/gazebosim/gz-cmake\",\n    # \"https://www.youtube.com/watch?v=AK1Febgqkec\",\n    # \"https://www.youtube.com/watch?v=laWn7_cj434\",\n\n    # \"https://github.com/gazebosim/gz-fuel-tools\",\n    \"https://github.com/gazebosim/ros_gz\",\n    # \"https://github.com/gazebosim/sdformat\",\n    # \"https://www.youtube.com/watch?v=CDafpwH4IuE\",\n\n]"}\n{"instruction": "Write a ROS2 Python node named touch.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "\nfrom groun_truth_msgs.srv import CalcDiameter\n\nimport rclpy\nfrom rclpy.node import Node\n\nfrom rclpy.executors import MultiThreadedExecutor\nfrom rclpy.callback_groups import ReentrantCallbackGroup\n\nfrom geometry_msgs.msg import PoseStamped, TransformStamped, Point, TwistStamped, Vector3\nfrom tf2_ros import TransformException\n\nfrom tf2_ros.buffer import Buffer\nfrom tf2_ros.transform_listener import TransformListener\nfrom controller_manager_msgs.srv import SwitchController\nimport numpy as np\n\nfrom std_msgs.msg import Float32, Bool\nfrom sensor_msgs.msg import JointState\nimport time \nimport matplotlib.pyplot as plt\n\n'''\nfrom moveit_msgs.action import MoveGroup\nfrom moveit_msgs.msg import (\n    MotionPlanRequest,\n    PlanningOptions,\n    Constraints,\n    JointConstraint,\n)\nfrom rclpy.action import ActionClient\n'''\nimport time \n\n\nclass Touch(Node):\n\n    def __init__(self):\n        super().__init__('touch')\n\n    \n        #Create publishers and subscripers \n        self.sub = self.create_subscription(Bool, 'touching_tree_flag', self.callback_tree, 10) \n        self.pub_vel_commands = self.create_publisher(TwistStamped, '/servo_node/delta_twist_cmds', 10)\n        self.sub_flag = self.create_subscription(Bool, 'touch',self.calback_touch_flag, 10 )\n        \n\n        #initalize states '\n        self.touch_flag = False\n        self.tree_touch = False\n        \n        \n        #create timers \n        self.control_timer = self.create_timer(1/10, self.main_control)\n\n        #initialaize variables \n        self.count = 0\n        \n\n        \n\n\n    def main_control (self):\n        #This function is called every 0.1 seconds and holds the main control structure for touching the tree \n        #The arm will move forward until the tree is touched \n        \n        if self.touch_flag:\n            if self.tree_touch == True: \n                self.get_logger().info(\"Touch Detected \")\n                for x in range (0,3):\n                    self.publish_twist([0.0, 0.0, 0.0], [0.0, 0.0, 0.0]) #stop moving\n               \n                self.count = 0 \n                self.touch_flag = False\n                self.tree_touch = False\n            else: \n                self.publish_twist([0.0, 0.0, 0.1], [0.0, 0.0, 0.0]) #move forward in the z position at 0.1 m/s\n      \n\n    def publish_twist(self, linear_speed, rot_speed):\n        #publish a velocity command with the specified linear speed and rotation speed \n        my_twist_linear = linear_speed \n        my_twist_angular = rot_speed\n        cmd = TwistStamped()\n        cmd.header.frame_id = 'tool0'\n        cmd.twist.angular = Vector3(x=my_twist_angular[0], y=my_twist_angular[1], z=my_twist_angular[2])\n        cmd.twist.linear = Vector3(x=my_twist_linear[0], y=my_twist_linear[1], z=my_twist_linear[2])\n        cmd.header.stamp = self.get_clock().now().to_msg()\n        self.pub_vel_commands.publish(cmd)\n        self.get_logger().info(f\"Sending: linear: {cmd.twist.linear} angular: {cmd.twist.angular}\")\n\n    def callback_tree (self, msg):\n        #self.get_logger().info(f\"GOT msg and setting self.touch_tree to: {msg.data}\")\n        if self.touch_flag: \n            self.tree_touch = msg.data \n    \n    def calback_touch_flag(self, msg): \n        self.touch_flag = msg.data \n\n\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    ang_check = Touch()\n\n    rclpy.spin(ang_check)\n\n    rclpy.shutdown()\n\n\nif __name__ == '__main__':\n    main()"}\n{"instruction": "Write a ROS2 Python node named pick_goal.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "#!/usr/bin/env python3\n\"\"\"\nExample of moving to a pose goal.\n- ros2 run pymoveit2 ex_pose_goal.py --ros-args -p position:=\"[0.25, 0.0, 1.0]\" -p quat_xyzw:=\"[0.0, 0.0, 0.0, 1.0]\" -p cartesian:=False\n\"\"\"\n\nfrom threading import Thread\nimport math\nfrom time import sleep\nimport rclpy\nfrom rclpy.callback_groups import ReentrantCallbackGroup\nfrom rclpy.node import Node\nfrom io_port_toggle import toggle_gripper\nfrom pymoveit2 import MoveIt2\nfrom pymoveit2 import MoveIt2_sim\nfrom pymoveit2.robots import ur5\nfrom pymoveit2.robots import ur5_sim\nfrom pyquaternion import Quaternion\nfrom moveit_msgs.msg import CollisionObject\nfrom geometry_msgs.msg import Pose\nfrom moveit_msgs.msg import PlanningScene\nfrom shape_msgs.msg import Plane\nfrom transforms import Transformations\n\ndef move_to_pose(pickPose, standalone, sim):\n        # TCP offsets\n        Transforms = Transformations()\n        tcp_x = Transforms.tcp_offset_x\n        tcp_y = Transforms.tcp_offset_y\n        tcp_z = Transforms.tcp_offset_z\n\n        if standalone:\n            rclpy.init()\n    \n        # Create node\n        if sim:\n            node = Node(\"moveit2_pose_goal\", namespace=\"arm1\")\n        else:\n            node = Node(\"moveit2_pose_goal\")\n\n        # Declare parameter for Cartesian or joint-space control       \n        node.declare_parameter(\"cartesian\", True)\n\n        # Create Transformations object\n        trans = Transformations()\n        # Convert camera coordinates to robot coordinates\n        robot_coords = trans.camera_to_robot(pickPose)\n        print(f\"Robot coordinates: {robot_coords}\")\n\n        # Declare parameters for position and orientation\n        node.declare_parameter(\"position1\", [tcp_x -0.5, tcp_y + 0.0, tcp_z - 0.02])\n        node.declare_parameter(\"position2\", robot_coords)\n        robot_coords_push = [robot_coords[0], robot_coords[1] + 0.3, robot_coords[2]]\n        node.declare_parameter(\"position3\", robot_coords_push)\n\n        # Declare parameters for Euler angles (roll, pitch, yaw)\n        node.declare_parameter(\"euler_xyz1\", [math.radians(0), math.radians(0), math.radians(0)])  # roll, pitch, yaw for position1\n        node.declare_parameter(\"euler_xyz2\", [math.radians(0), math.radians(0), math.radians(0)])  # roll, pitch, yaw for position2\n        node.declare_parameter(\"euler_xyz3\", [math.radians(0), math.radians(0), math.radians(0)])  # roll, pitch, yaw for position3\n\n        # Get parameters\n        euler_xyz1 = node.get_parameter(\"euler_xyz1\").get_parameter_value().double_array_value\n        euler_xyz2 = node.get_parameter(\"euler_xyz2\").get_parameter_value().double_array_value\n        euler_xyz3 = node.get_parameter(\"euler_xyz3\").get_parameter_value().double_array_value\n\n        # Convert Euler angles to quaternion\n        node.declare_parameter(\"quat_xyzw1\", [0.0, 1.0, 0.0, 0.0])  # default value is a unit quaternion\n        node.declare_parameter(\"quat_xyzw2\", [0.0, 1.0, 0.0, 0.0])  # default value is a unit quaternion\n        node.declare_parameter(\"quat_xyzw3\", [0.0, 1.0, 0.0, 0.0])  # default value is a unit quaternion\n\n        quat_xyzw1 = Quaternion(axis=[1, 0, 0], angle=euler_xyz1[0]) * Quaternion(axis=[0, 1, 0], angle=euler_xyz1[1]) * Quaternion(axis=[0, 0, 1], angle=euler_xyz1[2])\n        quat_xyzw2 = Quaternion(axis=[1, 0, 0], angle=euler_xyz2[0]) * Quaternion(axis=[0, 1, 0], angle=euler_xyz2[1]) * Quaternion(axis=[0, 0, 1], angle=euler_xyz2[2])\n        quat_xyzw3 = Quaternion(axis=[1, 0, 0], angle=euler_xyz3[0]) * Quaternion(axis=[0, 1, 0], angle=euler_xyz3[1]) * Quaternion(axis=[0, 0, 1], angle=euler_xyz3[2])\n        \n        # Update the parameters in the node\n        node.set_parameters([rclpy.parameter.Parameter(\"quat_xyzw1\", rclpy.parameter.Parameter.Type.DOUBLE_ARRAY, list(quat_xyzw1.elements))])\n        node.set_parameters([rclpy.parameter.Parameter(\"quat_xyzw2\", rclpy.parameter.Parameter.Type.DOUBLE_ARRAY, list(quat_xyzw2.elements))])\n        node.set_parameters([rclpy.parameter.Parameter(\"quat_xyzw3\", rclpy.parameter.Parameter.Type.DOUBLE_ARRAY, list(quat_xyzw3.elements))])\n        \n\n\n        # Create callback group that allows execution of callbacks in parallel without restrictions\n        callback_group = ReentrantCallbackGroup()\n\n        if sim:\n            # Create MoveIt 2 interface Robot\n            moveit2 = MoveIt2_sim(\n                node=node,\n                joint_names=ur5_sim.joint_names(),\n                base_link_name=ur5_sim.base_link_name(),\n                end_effector_name=ur5_sim.end_effector_name(),\n                group_name=ur5_sim.MOVE_GROUP_ARM,\n                callback_group=callback_group,\n            )\n        else:\n            \n            # Create MoveIt 2 interface Simulation\n            moveit2 = MoveIt2(\n                node=node,\n                joint_names=ur5.joint_names(),\n                base_link_name=ur5.base_link_name(),\n                end_effector_name=ur5.end_effector_name(),\n                group_name=ur5.MOVE_GROUP_ARM,\n                callback_group=callback_group,\n            )\n        \n\n\n        # Spin the node in background thread(s) and wait a bit for initialization\n        executor = rclpy.executors.MultiThreadedExecutor(2)\n        executor.add_node(node)\n        executor_thread = Thread(target=executor.spin, daemon=True, args=())\n        executor_thread.start()\n        node.create_rate(1.0).sleep()\n\n        # Scale down velocity and acceleration of joints (percentage of maximum)\n        moveit2.max_velocity = 0.5\n        moveit2.max_acceleration = 0.5\n\n        # Get parameters\n        position1 = node.get_parameter(\"position1\").get_parameter_value().double_array_value\n        position2 = node.get_parameter(\"position2\").get_parameter_value().double_array_value\n        position3 = node.get_parameter(\"position3\").get_parameter_value().double_array_value\n        quat_xyzw1 = node.get_parameter(\"quat_xyzw1\").get_parameter_value().double_array_value\n        quat_xyzw2 = node.get_parameter(\"quat_xyzw2\").get_parameter_value().double_array_value\n        quat_xyzw3 = node.get_parameter(\"quat_xyzw3\").get_parameter_value().double_array_value\n        cartesian = node.get_parameter(\"cartesian\").get_parameter_value().bool_value\n\n\n        # Move to pose\n        node.get_logger().info(\n            f\"Moving to {{position: {list(position1)}, quat_xyzw: {list(quat_xyzw1)}}}\"\n        )\n\n        node.get_logger().info(\n            f\"Moving to {{position: {list(position2)}, quat_xyzw: {list(quat_xyzw2)}}}\"\n        )\n\n        node.get_logger().info(\n            f\"Moving to {{position: {list(position3)}, quat_xyzw: {list(quat_xyzw3)}}}\"\n        )\n\n        node.get_logger().info(\n            f\"Moving to {{position: {list(position1)}, quat_xyzw: {list(quat_xyzw1)}}}\"\n        )\n\n        try:\n            add_ground_plane(node)\n\n            # Open the gripper before moving to the first position\n            toggle_gripper(1, simulation=sim)  # Call toggle_gripper with trigger = 1 to open the gripper\n            moveit2.move_to_pose(position=position1, quat_xyzw=quat_xyzw1, cartesian=cartesian)\n            moveit2.wait_until_executed()\n\n            moveit2.move_to_pose(position=position2, quat_xyzw=quat_xyzw2, cartesian=cartesian)\n            moveit2.wait_until_executed()\n\n            # sleep(t_cam2Pick) # Wait for the conveyor to move the object to the next position seconds\n\n            moveit2.move_to_pose(position=position3, quat_xyzw=quat_xyzw3, cartesian=cartesian)\n            moveit2.wait_until_executed()\n\n            # Close the gripper after reaching the first position\n            toggle_gripper(0, simulation=sim)  # Call toggle_gripper with trigger = 0 to close the gripper\n            # moveit2.move_to_pose(position=position3, quat_xyzw=quat_xyzw1, cartesian=cartesian)\n            # moveit2.wait_until_executed()\n\n        except Exception as e:\n            print(f\"An error occurred: {e}\")\n        finally:\n            if standalone:\n                rclpy.shutdown()\n                print(\"Stand alone\")\n                # executor_thread.join()\n\n        node.get_logger().info(f'Movement completed')\n\n\n\ndef add_ground_plane(node):\n\n    # Create a CollisionObject message\n    collision_object = CollisionObject()\n    collision_object.id = \"ground_plane\"\n    collision_object.header.frame_id = \"world\"\n\n    # Define the ground plane as a box shape\n    ground_plane = Plane()\n    ground_plane.coef = [0.0, 0.0, 1.0, 0.0]\n\n    # Set the ground plane's pose\n    ground_plane_pose = Pose()\n    ground_plane_pose.position.z = -0.005  # Adjust the height of the ground plane\n\n    collision_object.planes.append(ground_plane)\n    collision_object.plane_poses.append(ground_plane_pose)\n\n    # Create a PlanningScene message\n    scene = PlanningScene()\n    scene.world.collision_objects.append(collision_object)\n    scene.is_diff = True\n    \n    publisher_ = node.create_publisher(PlanningScene, 'planning_scene', 10)\n    publisher_.publish(scene)\n\n\nif __name__ == \"__main__\":\n    move_to_pose(-0.4, standalone=True, sim=True)  # Call move_to_pose with pickPose = -0.4 to -0.6 is the -x value of the pickPose"}\n{"instruction": "Write a ROS2 Python node named cfs_service.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "# add current path to sys.path\nimport sys\nimport os\n\nsys.path.append(os.getcwd())\n\nfrom juliacall import Main as jl\nimport rclpy\nfrom rclpy.node import Node\nfrom rclpy.parameter import Parameter\nfrom rcl_interfaces.srv import GetParameters\nfrom moveit_msgs.srv import GetMotionPlan\nfrom moveit_msgs.msg import MotionPlanRequest, RobotState\nfrom sensor_msgs.msg import JointState\nfrom trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint\nimport numpy as np\nimport tempfile\n\nimport re\nimport os\nfrom ament_index_python.packages import (\n    get_package_share_directory,\n    PackageNotFoundError\n)\n\nos.environ[\"JULIA_NUM_THREADS\"] = \"1\"\n# jl.include(\"julia/CFSRos.jl\")\njl.seval('using CFSRos')\n\ndef plan(jl_setup, motion_plan_request):\n    # check goal type\n    if len(motion_plan_request.goal_constraints) == 0:\n        return None\n    elif len(motion_plan_request.goal_constraints) > 1:\n        # not supported\n        return None\n    else:\n        start_joint_names = np.array(motion_plan_request.start_state.joint_state.name)\n        start_joint_positions = np.array(\n            motion_plan_request.start_state.joint_state.position\n        )\n        goal_constraint = motion_plan_request.goal_constraints[0]\n        if len(goal_constraint.joint_constraints) > 0:\n            # number of joint constraints should be equal to length of start state joint names\n            if len(goal_constraint.joint_constraints) != len(\n                motion_plan_request.start_state.joint_state.name\n            ):\n                return None\n            goal_joint_names = np.array(\n                [x.joint_name for x in goal_constraint.joint_constraints]\n            )\n            goal_joint_positions = np.array(\n                [x.position for x in goal_constraint.joint_constraints]\n            )\n            return jl.CFSRos.plan_motion_joint(\n                jl_setup,\n                start_joint_names,\n                start_joint_positions,\n                goal_joint_names,\n                goal_joint_positions,\n            )\n        else:\n            if not (\n                len(goal_constraint.position_constraints) == 1\n                and len(goal_constraint.orientation_constraints) == 1\n            ):\n                # not supported\n                return None\n            pos_constraint = goal_constraint.position_constraints[0]\n            ori_constraint = goal_constraint.orientation_constraints[0]\n\n            if pos_constraint.link_name != ori_constraint.link_name:\n                # not supported\n                return None\n\n            frame_id = pos_constraint.header.frame_id\n            goal_link_name = str(pos_constraint.link_name)\n            goal_pos = pos_constraint.target_point_offset\n            goal_pos = np.array([goal_pos.x, goal_pos.y, goal_pos.z])\n            goal_ori = ori_constraint.orientation\n            goal_ori = np.array([goal_ori.w, goal_ori.x, goal_ori.y, goal_ori.z])\n            return jl.CFSRos.plan_motion_cart(\n                jl_setup,\n                start_joint_names,\n                start_joint_positions,\n                frame_id,\n                goal_link_name,\n                goal_pos,\n                goal_ori,\n            )\n\n\nclass CFSClient(Node):\n    def __init__(self):\n        super().__init__(\"cfs_client\")\n        self.robot_state_publisher_client = self.create_client(\n            GetParameters, \"/robot_state_publisher/get_parameters\"\n        )\n        while not self.robot_state_publisher_client.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info(\n                \"robot_state_publisher service not available, waiting again...\"\n            )\n        self.get_logger().info(\"robot_state_publisher service available\")\n\n        # Create a service for motion planning requests\n        self.srv = self.create_service(\n            GetMotionPlan, \"/plan_kinematic_path_cfs\", self.plan_callback\n        )\n        self.get_logger().info(\"MotionPlanRequest server is ready.\")\n\n        self.jl_setup = jl.CFSRos.robotsetup_setup(self.get_urdf())\n        self.get_logger().info(\"CFSClient is ready.\")\n\n    def get_urdf(self):\n        self.request = GetParameters.Request()\n        self.request.names.append(\"robot_description\")\n        self.future = self.robot_state_publisher_client.call_async(self.request)\n        # wait for the future to be done\n        rclpy.spin_until_future_complete(self, self.future)\n        params = self.future.result()\n        urdf_string = params.values[0].string_value\n        pattern = r'package://([^/]+)(.*)'\n        def replacer(match):\n            pkg_name = match.group(1)\n            relative_path = match.group(2)  # includes the leading '/'\n            try:\n                pkg_share = get_package_share_directory(pkg_name)\n                return os.path.join(pkg_share, relative_path.lstrip('/'))\n            except PackageNotFoundError:\n                # If not found, just return the original string or handle it\n                self.get_logger().warn(f\"Package '{pkg_name}' not found; leaving reference unchanged.\")\n                return match.group(0)  # 'package://pkg_name/...'\n        urdf_string = re.sub(pattern, replacer, urdf_string)\n        # save urdf_string to temporary file\n        temp_file = tempfile.NamedTemporaryFile(delete=False)\n        with open(temp_file.name, 'w') as f:\n            f.write(urdf_string)\n        return temp_file.name\n\n    def plan_callback(self, request, response):\n        \"\"\"Handles motion planning requests\"\"\"\n        self.get_logger().info(\n            f\"Received planning request for {request.motion_plan_request.group_name}\"\n        )\n\n        traj = plan(self.jl_setup, request.motion_plan_request)\n        if traj is None:\n            response.motion_plan_response.error_code.val = 2\n            return response\n        else:\n            ts, trajj = traj\n            # Assume a basic motion plan with a simple interpolation\n            planned_trajectory = JointTrajectory()\n            planned_trajectory.joint_names = request.motion_plan_request.start_state.joint_state.name\n\n            for (i, t) in enumerate(ts):\n                pt = JointTrajectoryPoint()\n                pt.positions = trajj[:, i]\n                pt.time_from_start.sec = int(t)\n                pt.time_from_start.nanosec = int((t - int(t)) * 1e9)\n                planned_trajectory.points.append(pt)\n\n            # Fill response\n            response.motion_plan_response.trajectory.joint_trajectory = (\n                planned_trajectory\n            )\n            response.motion_plan_response.error_code.val = 1  # Success\n\n            self.get_logger().info(\"Motion plan generated successfully.\")\n            return response\n\n\ndef run_node(args=None):\n    rclpy.init(args=args)\n    cfs_client = CFSClient()\n    rclpy.spin(cfs_client)\n    cfs_client.destroy_node()\n    rclpy.shutdown()\n"}\n{"instruction": "Write a ROS2 Python node named reset.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "import rclpy\nfrom rclpy.node import Node\nfrom pymoveit2 import MoveIt2\nfrom rcl_interfaces.srv import GetParameters\nimport xml.etree.ElementTree as ET\nimport time\nimport numpy as np\n\nARM_GROUP_NAME = 'arm34'\nGRIPPER_GROUP_NAME = 'gripper34'\nPOSE_NAME = 'rest'\nVELOCITY_FACTOR = 0.1\nACCELERATION_FACTOR = 0.1\nPLANNING_TIME = 5.0\nPLANNING_ATTEMPTS = 10\n\n\nclass Moveit:\n    def __init__(self):\n        self.moveit_node = Node('reset_moveit_node')\n        self.get_param_cli = None\n\n    def setup_get_move_group_params(self, get_parameters='/move_group/get_parameters'):\n        self.get_param_cli = self.moveit_node.create_client(GetParameters, get_parameters)\n        while not self.get_param_cli.wait_for_service(timeout_sec=1.0):\n            self.moveit_node.get_logger().info('[Env] [Moveit] service not available, waiting again...')\n        self.req = GetParameters.Request()\n        return\n\n    def get_move_group_params(self, param):\n        if self.get_param_cli is None: self.setup_get_move_group_params()\n        self.req.names = [param]\n        itreation = 0\n        while True:\n            itreation += 1\n            self.future = self.get_param_cli.call_async(self.req)\n            rclpy.spin_until_future_complete(self.moveit_node, self.future, timeout_sec=1.0)\n            if self.future.result() is not None:\n                return self.future.result().values[0]\n            elif itreation > 10:\n                return False\n            else:\n                print(\"Service call failed %r\" % (self.future.exception(),))\n                time.sleep(1)\n                continue\n\n    def moveit_extract_joint_info(self):\n        semantic_description = self.get_move_group_params('robot_description_semantic')\n        self.moveit_info = ET.fromstring(semantic_description.string_value)\n        self.moveit_group_poses, self.moveit_arms_joint_names, self.moveit_hand_joint_names = {}, [], []\n        for child in self.moveit_info:\n            if child.tag == 'group_state' and child.attrib['group'] == ARM_GROUP_NAME:\n                if ARM_GROUP_NAME not in self.moveit_group_poses:\n                    self.moveit_group_poses[ARM_GROUP_NAME] = {}\n                self.moveit_group_poses[ARM_GROUP_NAME][child.attrib['name']] = []\n                for joint in child:\n                    self.moveit_group_poses[ARM_GROUP_NAME][child.attrib['name']].append(\n                        float(joint.attrib['value']))\n                if len(self.moveit_arms_joint_names) == 0:\n                    self.moveit_arms_joint_names = [joint.attrib['name'] for joint in child]\n            elif child.tag == 'group_state' and child.attrib['group'] == GRIPPER_GROUP_NAME:\n                if GRIPPER_GROUP_NAME not in self.moveit_group_poses:\n                    self.moveit_group_poses[GRIPPER_GROUP_NAME] = {}\n                self.moveit_group_poses[GRIPPER_GROUP_NAME][child.attrib['name']] = []\n                for joint in child:\n                    self.moveit_group_poses[GRIPPER_GROUP_NAME][child.attrib['name']].append(\n                        float(joint.attrib['value']))\n                if len(self.moveit_hand_joint_names) == 0:\n                    self.moveit_hand_joint_names = [joint.attrib['name'] for joint in child]\n        return\n\n    def setup_moveit(self):\n        self.moveit_extract_joint_info()\n        self.arms_group = MoveIt2(node=self.moveit_node, joint_names=self.moveit_arms_joint_names,\n                                  base_link_name='', end_effector_name='',\n                                  group_name=ARM_GROUP_NAME,\n                                  use_move_group_action=True)\n        self.arms_group.num_planning_attempts = PLANNING_ATTEMPTS\n        self.arms_group.allowed_planning_time = PLANNING_TIME\n        self.arms_group.max_velocity = VELOCITY_FACTOR\n        self.arms_group.max_acceleration = ACCELERATION_FACTOR\n\n        self.arms_group.move_to_configuration(self.moveit_group_poses[ARM_GROUP_NAME][POSE_NAME])\n        self.arms_group.wait_until_executed()\n\n        if self.moveit_hand_joint_names:\n            self.hand_group = MoveIt2(node=self.moveit_node, joint_names=self.moveit_hand_joint_names,\n                                      base_link_name='', end_effector_name='',\n                                      group_name=GRIPPER_GROUP_NAME, use_move_group_action=True)\n            self.hand_group.num_planning_attempts = PLANNING_ATTEMPTS\n            self.hand_group.allowed_planning_time = PLANNING_TIME\n            self.hand_group.max_velocity = VELOCITY_FACTOR\n            self.hand_group.max_acceleration = ACCELERATION_FACTOR\n            if POSE_NAME in self.moveit_group_poses[GRIPPER_GROUP_NAME]:\n                self.hand_group.move_to_configuration(\n                    self.moveit_group_poses[GRIPPER_GROUP_NAME][POSE_NAME])\n            else:\n                self.hand_group.move_to_configuration(self.moveit_group_poses[GRIPPER_GROUP_NAME]['init'])\n            self.hand_group.wait_until_executed()\n        return\n\nif __name__ == '__main__':\n    rclpy.init()\n    moveit = Moveit()\n    moveit.setup_moveit()\n    print(\"MoveIt setup complete.\")\n    rclpy.shutdown()\n\n"}\n{"instruction": "Write a ROS2 Python node named moveit_ik.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "import rclpy\nfrom rclpy.node import Node\n\nfrom sensor_msgs.msg import JointState\nfrom tf2_ros import TransformException\nfrom tf2_ros.buffer import Buffer\nfrom tf2_ros.transform_listener import TransformListener\nfrom moveit_msgs.srv import GetPositionIK\n\nimport numpy as np\n\ntarget_angles = None\nglobal_joint_states = None\ntf_base_link_P = None\n\n\nclass MinimalClientAsync:\n    def __init__(self, node):\n        self.logger = node.get_logger()\n        self.clock = node.get_clock()\n        self.node = node\n\n        self.tf_buffer = Buffer()\n        self.tf_listener = TransformListener(self.tf_buffer, node)\n        self.timer = node.create_timer(1.0, self.on_timer)\n        node.create_subscription(JointState, \"/joint_states\", self.joint_states_cb, 1)\n\n        self.cli = node.create_client(GetPositionIK, \"/compute_ik\")\n        while not self.cli.wait_for_service(timeout_sec=1.0):\n            self.logger.info(\"service not available, waiting again...\")\n\n    def on_timer(self):\n        global tf_base_link_P\n        # Look up for the transformation between target_frame and turtle2 frames\n        # and send velocity commands for turtle2 to reach target_frame\n        try:\n            t = self.tf_buffer.lookup_transform(\n                \"base_link\", \"P\", rclpy.time.Time(), rclpy.duration.Duration(seconds=1)\n            )\n\n            tf_base_link_P = [\n                t.transform.translation.x,\n                t.transform.translation.y,\n                t.transform.translation.z,\n                t.transform.rotation.x,\n                t.transform.rotation.y,\n                t.transform.rotation.z,\n                t.transform.rotation.w,\n            ]\n            self.tf_base_link_P = tf_base_link_P\n        except TransformException as ex:\n            self.logger.info(f\"Could not transform base_link to P: {ex}\")\n            return\n\n    def joint_states_cb(self, joint_state):\n        global global_joint_states\n        global_joint_states = joint_state\n        self.joint_state = joint_state\n\n    def moveit_ik(self):\n        group_name = \"spot_arm\"\n        self.req.ik_request.group_name = group_name\n        self.req.ik_request.robot_state.joint_state = self.joint_state\n        self.req.ik_request.avoid_collisions = True\n\n        self.req.ik_request.pose_stamped.header.stamp = self.clock.now().to_msg()\n        self.req.ik_request.pose_stamped.header.frame_id = \"base_link\"\n\n        self.req.ik_request.pose_stamped.pose.position.x = self.tf_base_link_P[0]\n        self.req.ik_request.pose_stamped.pose.position.y = self.tf_base_link_P[1]\n        self.req.ik_request.pose_stamped.pose.position.z = self.tf_base_link_P[2] + 0.05\n\n        self.req.ik_request.pose_stamped.pose.orientation.x = self.tf_base_link_P[3]\n        self.req.ik_request.pose_stamped.pose.orientation.y = self.tf_base_link_P[4]\n        self.req.ik_request.pose_stamped.pose.orientation.z = self.tf_base_link_P[5]\n        self.req.ik_request.pose_stamped.pose.orientation.w = self.tf_base_link_P[6]\n\n        self.req.ik_request.timeout.sec = 5\n\n        return self.req.ik_request\n\n    def send_request(self):\n        self.req = GetPositionIK.Request()\n        self.req.ik_request = self.moveit_ik()\n\n        self.future = self.cli.call_async(self.req)\n        rclpy.spin_until_future_complete(self.node, self.future)\n        return self.future.result()\n\n\ndef main():\n    rclpy.init()\n    node = Node(\"moveit_ik_python\")\n\n    minimal_client = MinimalClientAsync(node)\n    while global_joint_states is None or tf_base_link_P is None:\n        rclpy.spin_once(node)\n    response = minimal_client.send_request()\n    print(response.solution.joint_state.name[:7])\n    target_angles = list(response.solution.joint_state.position)[:7]\n\n    if not len(target_angles):\n        print(\"No IK solution found\")\n        node.destroy_node()\n        rclpy.shutdown()\n        return\n    print([round(np.rad2deg(ta)) for ta in target_angles])\n\n\nif __name__ == \"__main__\":\n    main()\n"}\n{"instruction": "Write a ROS2 Python node named moveit_servo.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "# Copyright 2024 The HuggingFace Inc. team. All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport logging\n\nfrom geometry_msgs.msg import TwistStamped\nfrom moveit_msgs.srv import ServoCommandType\nfrom rclpy import qos\nfrom rclpy.callback_groups import CallbackGroup\nfrom rclpy.node import Node\nfrom std_srvs.srv import SetBool\n\nlogger = logging.getLogger(__name__)\n\n\nclass MoveIt2Servo:\n    \"\"\"\n    Python interface for MoveIt2 Servo.\n    \"\"\"\n\n    def __init__(\n        self,\n        node: \"Node\",\n        frame_id: str,\n        callback_group: \"CallbackGroup\",\n    ):\n        self._node = node\n        self._frame_id = frame_id\n        self._enabled = False\n\n        self._twist_pub = node.create_publisher(\n            TwistStamped,\n            \"/servo_node/delta_twist_cmds\",\n            qos.QoSProfile(\n                durability=qos.QoSDurabilityPolicy.VOLATILE,\n                reliability=qos.QoSReliabilityPolicy.RELIABLE,\n                history=qos.QoSHistoryPolicy.KEEP_ALL,\n            ),\n            callback_group=callback_group,\n        )\n        self._pause_srv = node.create_client(\n            SetBool, \"/servo_node/pause_servo\", callback_group=callback_group\n        )\n        self._cmd_type_srv = node.create_client(\n            ServoCommandType, \"/servo_node/switch_command_type\", callback_group=callback_group\n        )\n        self._twist_msg = TwistStamped()\n        self._enable_req = SetBool.Request(data=False)\n        self._disable_req = SetBool.Request(data=True)\n        self._twist_type_req = ServoCommandType.Request(command_type=ServoCommandType.Request.TWIST)\n\n    def enable(self, wait_for_server_timeout_sec=1.0) -> bool:\n        if not self._pause_srv.wait_for_service(timeout_sec=wait_for_server_timeout_sec):\n            logger.warning(\"Pause service not available.\")\n            return False\n        if not self._cmd_type_srv.wait_for_service(timeout_sec=wait_for_server_timeout_sec):\n            logger.warning(\"Command type service not available.\")\n            return False\n        result = self._pause_srv.call(self._enable_req)\n        if not result or not result.success:\n            logger.error(f\"Enable failed: {getattr(result, 'message', '')}\")\n            self._enabled = False\n            return False\n        cmd_result = self._cmd_type_srv.call(self._twist_type_req)\n        if not cmd_result or not cmd_result.success:\n            logger.error(\"Switch to TWIST command type failed.\")\n            self._enabled = False\n            return False\n        logger.info(\"MoveIt Servo enabled.\")\n        self._enabled = True\n        return True\n\n    def disable(self, wait_for_server_timeout_sec=1.0) -> bool:\n        if not self._pause_srv.wait_for_service(timeout_sec=wait_for_server_timeout_sec):\n            logger.warning(\"Pause service not available.\")\n            return False\n        result = self._pause_srv.call(self._disable_req)\n        self._enabled = not (result and result.success)\n        return bool(result and result.success)\n\n    def servo(self, linear=(0.0, 0.0, 0.0), angular=(0.0, 0.0, 0.0), enable_if_disabled=True):\n        if not self._enabled and enable_if_disabled and not self.enable():\n            logger.warning(\"Dropping servo command because MoveIt2 Servo is not enabled.\")\n            return\n\n        self._twist_msg.header.frame_id = self._frame_id\n        self._twist_msg.header.stamp = self._node.get_clock().now().to_msg()\n        self._twist_msg.twist.linear.x = float(linear[0])\n        self._twist_msg.twist.linear.y = float(linear[1])\n        self._twist_msg.twist.linear.z = float(linear[2])\n        self._twist_msg.twist.angular.x = float(angular[0])\n        self._twist_msg.twist.angular.y = float(angular[1])\n        self._twist_msg.twist.angular.z = float(angular[2])\n        self._twist_pub.publish(self._twist_msg)\n"}\n{"instruction": "Write a ROS2 Python node named moveit2.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "\"\"\"\nA simple python interface with MoveIt2 services (and actions). This is an alternative to\nmoveit_commander, which is not yet ported to ROS 2 (as of Oct 2020).\nNote: This module is currently configured for Franka Emika Panda robot.\nNote: There is no Ignition-specific code in this module (this repo is just a convinient place).\n\nthe code is from https://github.com/AndrejOrsula/ign_moveit2 ,and is modified.\n\"\"\"\n\nimport threading\n\nimport rclpy\nfrom rclpy.node import Node\nfrom rclpy.action import ActionClient\n\nfrom std_msgs.msg import Float32\nfrom builtin_interfaces.msg import Duration\nfrom geometry_msgs.msg import Pose, Quaternion\nfrom shape_msgs.msg import SolidPrimitive\nfrom sensor_msgs.msg import JointState\nfrom trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint\nfrom moveit_msgs.msg import Constraints, JointConstraint, PositionConstraint, OrientationConstraint\nfrom moveit_msgs.msg import PositionIKRequest, RobotTrajectory\nfrom moveit_msgs.srv import GetPositionIK, GetPositionFK, GetMotionPlan, GetCartesianPath\nfrom moveit_msgs.action import MoveGroup\nfrom action_msgs.msg import GoalStatus\n\n\nclass MoveIt2Interface(Node):\n\n    def __init__(self):\n        super().__init__(\"ign_moveit2_py\")\n        self.init_robot()\n        self.init_compute_fk()\n        self.init_compute_ik()\n        self.init_plan_kinematic_path()\n        self.init_plan_cartesian_path()\n        self.get_logger().info(\"ign_moveit2_py initialised successfuly\")\n\n    def init_robot(self):\n        \"\"\"\n        Initialise robot groups, links and joints. This would normally get loaded from URDF via\n        `moveit_commander`.\n        This also initialises subscriber to joint states and publisher to joint trajectories.\n        \"\"\"\n        self.robot_group_name = \"ur10\"\n        # Arm\n        self.arm_group_name = \"manipulator\"\n        self.arm_joints = [\"shoulder_pan_joint\",\n                           \"shoulder_lift_joint\",\n                           \"elbow_joint\",\n                           \"wrist_1_joint\",\n                           \"wrist_2_joint\",\n                           \"wrist_3_joint\"]\n        self.arm_links = [\"base_link\",\n                          \"shoulder_link\",\n                          \"upper_arm_link\",\n                          \"forearm_link\",\n                          \"wrist_1_link\",\n                          \"wrist_2_link\",\n                          \"wrist_3_link\",\n                          \"ee_link\"]\n        self.arm_base_link = self.arm_links[0]\n        self.arm_end_effector = self.arm_links[-1]\n\n        # Publisher of trajectories\n        self.joint_trajectory_pub = self.create_publisher(JointTrajectory,\n                                                          \"set_joint_trajectory\", 1)\n\n        # Subscriber of current joint states\n        self.joint_state = JointState()\n        self.joint_state_mutex = threading.Lock()\n        self.joint_state_sub = self.create_subscription(JointState,\n                                                        \"joint_states\",\n                                                        self.joint_state_callback, 1)\n\n        # Subscriber of joint trajectory progress\n        self.joint_progress = 1.0\n        self.joint_progress_cond = threading.Condition()\n        self.joint_progress_sub = self.create_subscription(Float32,\n                                                           \"joint_trajectory_progress\",\n                                                           self.joint_progress_callback, 1)\n\n    def joint_state_callback(self, msg):\n        \"\"\"\n        Callback for getting current joint states.\n        \"\"\"\n        self.joint_state_mutex.acquire()\n        self.joint_state = msg\n        self.joint_state_mutex.release()\n\n    def get_joint_state(self) -> JointState:\n        \"\"\"\n        Get current joint states.\n        \"\"\"\n        self.joint_state_mutex.acquire()\n        joint_state = self.joint_state\n        self.joint_state_mutex.release()\n        return joint_state\n\n    def joint_progress_callback(self, msg):\n        \"\"\"\n        Callback for getting joint trajectory progress.\n        \"\"\"\n        with self.joint_progress_cond:\n            self.joint_progress = msg.data\n            self.joint_progress_cond.notify_all()\n\n    def wait_until_executed(self):\n        \"\"\"\n        Function that halts execution on the current thread until trajectory is executed.\n        \"\"\"\n        with self.joint_progress_cond:\n            while not self.joint_progress == 1.0:\n                self.joint_progress_cond.wait(timeout=0.5)\n\n    def pub_trajectory(self, trajectory):\n        \"\"\"\n        Publish trajectory such that it can be executed, e.g. by `JointTrajectoryController`\n        Ignition plugin.\n        \"\"\"\n        if isinstance(trajectory, JointTrajectory):\n            self.joint_trajectory_pub.publish(trajectory)\n            self.get_logger().info(\"pub trajectory msg!\")\n        elif isinstance(trajectory, RobotTrajectory):\n            self.joint_trajectory_pub.publish(trajectory.joint_trajectory)\n        else:\n            raise Exception(\"Invalid type passed into pub_trajectory()\")\n\n    def execute(self, joint_trajectory=None) -> bool:\n        \"\"\"\n        Execute last planned motion plan, or the `joint_trajectory` specified as argument.\n        \"\"\"\n\n        if joint_trajectory == None:\n            plan = self.motion_plan_.joint_trajectory\n        else:\n            plan = joint_trajectory\n\n        # Make sure there is a plan to follow\n        if not plan.points:\n            self.get_logger().warn(\n                \"Cannot execute motion plan because it does not contain any trajectory points\")\n            return False\n\n        # Reset joint progress\n        self.joint_progress = 0.0\n\n        self.pub_trajectory(plan)\n        return True\n\n    def move_to_joint_state(self, joint_state,\n                            set_position=True,\n                            set_velocity=True,\n                            set_effort=True):\n        \"\"\"\n        Set joint target on all joints defined in `joint_state`. This function does NOT plan a\n        smooth trajectory and only publishes joint_state as the next goal that should be reached\n        immediately.\n        \"\"\"\n        joint_trajectory = JointTrajectory()\n        joint_trajectory.joint_names = joint_state.name\n\n        point = JointTrajectoryPoint()\n        if set_position:\n            point.positions = joint_state.position\n        if set_velocity:\n            point.velocities = joint_state.velocity\n        if set_effort:\n            point.effort = joint_state.effort\n        joint_trajectory.points.append(point)\n\n        self.pub_trajectory(joint_trajectory)\n\n    # compute_fk\n    def init_compute_fk(self):\n        \"\"\"\n        Initialise `compute_fk` service.\n        \"\"\"\n        self.compute_fk_client = self.create_client(GetPositionFK,\n                                                    \"compute_fk\")\n        while not self.compute_fk_client.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info(\n                \"Service [compute_fk] not currently available, waiting...\")\n\n        self.fk_request = GetPositionFK.Request()\n        self.fk_request.header.frame_id = self.arm_base_link\n        # self.fk_request.header.stamp = \"Set during request\"\n        # self.fk_request.fk_link_names = \"Set during request\"\n        # self.fk_request.robot_state.joint_state = \"Set during request\"\n        # self.fk_request.robot_state.multi_dof_joint_state = \"Ignored\"\n        # self.fk_request.robot_state.attached_collision_objects = \"Ignored\"\n        self.fk_request.robot_state.is_diff = False\n\n    def compute_fk(self, fk_link_names=None, joint_state=None) -> GetPositionFK.Response:\n        \"\"\"\n        Call `compute_fk` service.\n        \"\"\"\n        if fk_link_names == None:\n            self.fk_request.fk_link_names = [self.arm_end_effector]\n        else:\n            self.fk_request.fk_link_names = fk_link_names\n\n        if joint_state == None:\n            self.fk_request.robot_state.joint_state = self.get_joint_state()\n        else:\n            self.fk_request.robot_state.joint_state = joint_state\n\n        self.fk_request.header.stamp = self._clock.now().to_msg()\n\n        self.compute_fk_client.wait_for_service()\n        return self.compute_fk_client.call(self.fk_request)\n\n    # compute_ik\n    def init_compute_ik(self):\n        \"\"\"\n        Initialise `compute_ik` service.\n        \"\"\"\n        # Service client for IK\n        self.compute_ik_client = self.create_client(GetPositionIK,\n                                                    \"compute_ik\")\n        while not self.compute_ik_client.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info(\n                \"Service [compute_ik] not currently available, waiting...\")\n\n        self.ik_request = GetPositionIK.Request()\n        self.ik_request.ik_request.group_name = self.arm_group_name\n        # self.ik_request.ik_request.robot_state.joint_state = \"Set during request\"\n        # self.ik_request.ik_request.robot_state.multi_dof_joint_state = \"Ignored\"\n        # self.ik_request.ik_request.robot_state.attached_collision_objects = \"Ignored\"\n        self.ik_request.ik_request.robot_state.is_diff = False\n        # self.ik_request.ik_request.constraints = \"Set during request OR Ignored\"\n        self.ik_request.ik_request.avoid_collisions = True\n        # self.ik_request.ik_request.ik_link_name = \"Ignored\"\n        self.ik_request.ik_request.pose_stamped.header.frame_id = self.arm_base_link\n        # self.ik_request.ik_request.pose_stamped.header.stamp = \"Set during request\"\n        # self.ik_request.ik_request.pose_stamped.pose = \"Set during request\"\n        # self.ik_request.ik_request.ik_link_names = \"Ignored\"\n        # self.ik_request.ik_request.pose_stamped_vector = \"Ignored\"\n        # self.ik_request.ik_request.timeout.sec = \"Ignored\"\n        # self.ik_request.ik_request.timeout.nanosec = \"Ignored\"\n\n    def compute_ik(self, pose, start_joint_state=None, constrains=None) -> GetPositionIK.Response:\n        \"\"\"\n        Call `compute_ik` service.\n        \"\"\"\n        if start_joint_state == None:\n            self.ik_request.ik_request.robot_state.joint_state = self.get_joint_state()\n        else:\n            self.ik_request.ik_request.robot_state.joint_state = start_joint_state\n\n        if constrains != None:\n            self.ik_request.ik_request.constraints = constrains\n\n        self.ik_request.ik_request.pose_stamped.pose = pose\n\n        self.ik_request.ik_request.pose_stamped.header.stamp = self._clock.now().to_msg()\n\n        self.compute_ik_client.wait_for_service()\n        return self.compute_ik_client.call(self.ik_request)\n\n    # plan_kinematic_path\n    def init_plan_kinematic_path(self):\n        \"\"\"\n        Initialise `plan_kinematic_path` service.\n        \"\"\"\n        # Service client for IK\n        self.plan_kinematic_path_client = self.create_client(GetMotionPlan,\n                                                             \"plan_kinematic_path\")\n        while not self.plan_kinematic_path_client.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info(\n                \"Service [plan_kinematic_path] not currently available, waiting...\")\n\n        self.kinematic_path_request = GetMotionPlan.Request()\n        self.kinematic_path_request.motion_plan_request.workspace_parameters.header.frame_id = \\\n            self.arm_base_link\n        # self.kinematic_path_request.motion_plan_request.workspace_parameters.header.stamp = \\\n        # \"Set during request\"\n        self.kinematic_path_request.motion_plan_request.workspace_parameters.min_corner.x = -0.855\n        self.kinematic_path_request.motion_plan_request.workspace_parameters.min_corner.y = -0.855\n        self.kinematic_path_request.motion_plan_request.workspace_parameters.min_corner.z = -0.36\n        self.kinematic_path_request.motion_plan_request.workspace_parameters.max_corner.x = 0.855\n        self.kinematic_path_request.motion_plan_request.workspace_parameters.max_corner.y = 0.855\n        self.kinematic_path_request.motion_plan_request.workspace_parameters.max_corner.z = 1.19\n        # self.kinematic_path_request.motion_plan_request.start_state = \"Ignored\"\n        self.kinematic_path_request.motion_plan_request.goal_constraints = \\\n            [Constraints()]\n        # self.kinematic_path_request.motion_plan_request.path_constraints = \"Ignored\"\n        # self.kinematic_path_request.motion_plan_request.trajectory_constraints = \"Ignored\"\n        # self.kinematic_path_request.motion_plan_request.reference_trajectories = \"Ignored\"\n        # self.kinematic_path_request.motion_plan_request.planner_id = \"Ignored\"\n        self.kinematic_path_request.motion_plan_request.group_name = self.arm_group_name\n        # self.kinematic_path_request.motion_plan_request.num_planning_attempts = \\\n        # \"Set during request\"\n        # self.kinematic_path_request.motion_plan_request.allowed_planning_time = \\\n        # \"Set during request\"\n        self.kinematic_path_request.motion_plan_request.max_velocity_scaling_factor = 0.0\n        self.kinematic_path_request.motion_plan_request.max_acceleration_scaling_factor = 0.0\n        self.kinematic_path_request.motion_plan_request.cartesian_speed_end_effector_link = \\\n            self.arm_end_effector\n        self.kinematic_path_request.motion_plan_request.max_cartesian_speed = 0.0\n\n    def set_max_velocity(self, scaling_factor):\n        \"\"\"\n        Set maximum velocity of joints as a factor of joint limits.\n        \"\"\"\n        self.kinematic_path_request.motion_plan_request.max_velocity_scaling_factor = scaling_factor\n\n    def set_max_acceleration(self, scaling_factor):\n        \"\"\"\n        Set maximum acceleration of joints as a factor of joint limits.\n        \"\"\"\n        self.kinematic_path_request.motion_plan_request.max_acceleration_scaling_factor = \\\n            scaling_factor\n\n    def set_max_cartesian_speed(self, speed):\n        \"\"\"\n        Set maximum cartesian speed of end effector.\n        \"\"\"\n        self.kinematic_path_request.motion_plan_request.max_cartesian_speed = speed\n\n    def plan_kinematic_path(self,\n                            allowed_planning_time=5.0,\n                            num_planning_attempts=10) -> GetMotionPlan.Response:\n        \"\"\"\n        Call `plan_kinematic_path` service, with goal set using either `set_joint_goal()`,\n        `set_position_goal()`, `set_orientation_goal()` or `set_pose_goal()`.\n        \"\"\"\n\n        self.kinematic_path_request.motion_plan_request.num_planning_attempts = \\\n            num_planning_attempts\n        self.kinematic_path_request.motion_plan_request.allowed_planning_time = \\\n            allowed_planning_time\n\n        self.kinematic_path_request.motion_plan_request.workspace_parameters.header.stamp = \\\n            self._clock.now().to_msg()\n\n        # Stamp message with current time\n        clock_time_now_msg = self._clock.now().to_msg()\n        self.kinematic_path_request.motion_plan_request.workspace_parameters.header.stamp = \\\n            clock_time_now_msg\n        for contraints in self.kinematic_path_request.motion_plan_request.goal_constraints:\n            for position_constraint in contraints.position_constraints:\n                position_constraint.header.stamp = clock_time_now_msg\n            for orientation_constraint in contraints.orientation_constraints:\n                orientation_constraint.header.stamp = clock_time_now_msg\n\n        self.plan_kinematic_path_client.wait_for_service()\n        response = self.plan_kinematic_path_client.call(\n            self.kinematic_path_request)\n\n        self.clear_goal_constraints()\n        self.motion_plan_ = response.motion_plan_response.trajectory\n\n        return response\n\n    def clear_goal_constraints(self):\n        \"\"\"\n        Clear all goal constraints that were previously set.\n        Note that this function is called automatically after each `plan_kinematic_path()`.\n        \"\"\"\n        self.kinematic_path_request.motion_plan_request.goal_constraints = \\\n            [Constraints()]\n\n    def create_new_goal_constraint(self):\n        \"\"\"\n        Create a new set of goal contraints that will be set together with the request. Each\n        subsequent setting of goals with `set_joint_goal()`, `set_pose_goal()` and others will be\n        added under this newly created set of contraints.\n        \"\"\"\n        (self.kinematic_path_request.motion_plan_request.goal_constraints\n         .append(Constraints()))\n\n    def set_joint_goal(self, joint_positions, tolerance=0.001, weight=1.0, joint_names=None):\n        \"\"\"\n        Set goal position in joint space. With `joint_names` specified, `joint_positions` can be\n        defined for specific joints. Otherwise, first `n` joints defined in `init_robot()` will be\n        used, where `n` is the length of `joint_positions`.\n        \"\"\"\n        if joint_names == None:\n            joint_names = self.arm_joints\n\n        for i in range(len(joint_positions)):\n            joint_constraint = JointConstraint()\n            joint_constraint.joint_name = joint_names[i]\n            joint_constraint.position = joint_positions[i]\n            joint_constraint.tolerance_above = tolerance\n            joint_constraint.tolerance_below = tolerance\n            joint_constraint.weight = weight\n\n            (self.kinematic_path_request.motion_plan_request.goal_constraints[-1].\n             joint_constraints.append(joint_constraint))\n\n    def set_position_goal(self, position, tolerance=0.001, weight=1.0, frame=None):\n        \"\"\"\n        Set goal position of `frame` in Cartesian space. Defaults to the end-effector `frame`.\n        \"\"\"\n        if frame == None:\n            frame = self.arm_base_link\n\n        position_constraint = PositionConstraint()\n        position_constraint.header.frame_id = frame\n        position_constraint.link_name = self.arm_end_effector\n        position_constraint.constraint_region.primitive_poses.append(Pose())\n        position_constraint.constraint_region.primitive_poses[0].position.x = position[0]\n        position_constraint.constraint_region.primitive_poses[0].position.y = position[1]\n        position_constraint.constraint_region.primitive_poses[0].position.z = position[2]\n\n        # Goal is defined as a sphere with radius equal to tolerance\n        position_constraint.constraint_region.primitives.append(\n            SolidPrimitive())\n        position_constraint.constraint_region.primitives[0].type = 2\n        position_constraint.constraint_region.primitives[0].dimensions = [\n            tolerance]\n        position_constraint.weight = weight\n\n        (self.kinematic_path_request.motion_plan_request.goal_constraints[-1].position_constraints\n         .append(position_constraint))\n\n    def set_orientation_goal(self, quaternion, tolerance=0.001, weight=1.0, frame=None):\n        \"\"\"\n        Set goal orientation of `frame`. Defaults to the end-effector `frame`.\n        \"\"\"\n        if frame == None:\n            frame = self.arm_end_effector\n\n        orientation_constraint = OrientationConstraint()\n        orientation_constraint.header.frame_id = self.arm_base_link\n        orientation_constraint.link_name = frame\n        orientation_constraint.orientation = quaternion\n        orientation_constraint.absolute_x_axis_tolerance = tolerance\n        orientation_constraint.absolute_y_axis_tolerance = tolerance\n        orientation_constraint.absolute_z_axis_tolerance = tolerance\n        orientation_constraint.weight = weight\n\n        (self.kinematic_path_request.motion_plan_request.goal_constraints[-1]\n         .orientation_constraints.append(orientation_constraint))\n\n    def set_pose_goal(self, position, quaternion,\n                      tolerance_position=0.001, tolerance_orientation=0.001,\n                      weight_position=1.0, weight_orientation=1.0,\n                      frame=None):\n        \"\"\"\n        Set goal pose. This is direct combination of `set_position_goal()` and\n        `set_orientation_goal()`.\n        \"\"\"\n        self.set_position_goal(\n            position, tolerance_position, weight_position, frame)\n        self.set_orientation_goal(\n            quaternion, tolerance_orientation, weight_orientation, frame)\n\n    # plan_cartesian_path\n    def init_plan_cartesian_path(self):\n        \"\"\"\n        Initialise `compute_cartesian_path` service.\n        \"\"\"\n        # TODO\n        pass\n\n    def plan_cartesian_path(self, pose,\n                            start_joint_state=None,\n                            constrains=None) -> GetCartesianPath.Response:\n        \"\"\"\n        Call `compute_cartesian_path` service.\n        \"\"\"\n        # TODO\n        pass\n"}\n{"instruction": "Write a ROS2 Python node named checker.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "import subprocess as sp\nimport threading\nimport os\nimport pickle\nimport time\nimport math\nimport json\nimport statistics\n\nimport numpy as np\n\nimport constants as c\n\nimport rclpy\nfrom rclpy.node import Node\n\nimport ros_utils\n\n# import checkers\nimport oracles.turtlesim\nimport oracles.turtlebot\nimport oracles.px4\nimport oracles.moveit\nimport oracles.rosidl\n\n\nclass StateMonitorNode(Node):\n    subs = dict()\n    msg_queue = list()\n    rosbag_proc = None\n\n    def __init__(self, fuzzer):\n        super().__init__(\"_checker\")\n\n        self.fuzzer = fuzzer\n\n    def retrieve_states(self, exec_cnt):\n        \"\"\"\n        Retrieve recorded states by re-playing a rosbag file\n        \"\"\"\n        print(\"[checker] retrieving states\")\n\n        watchlist_file = self.fuzzer.config.watchlist\n\n        with open(watchlist_file, \"r\") as fp:\n            data = fp.read()\n\n        self.watchlist = json.loads(data)\n\n        for target_topic in self.watchlist:\n            topic_msg_type = self.watchlist[target_topic]\n            pkg_name = \".\".join(topic_msg_type.split(\"/\")[:-1])\n            module_name = topic_msg_type.split(\"/\")[-1]\n\n            msg_type_class = ros_utils.get_msg_class_from_name(\n                pkg_name.split(\".\")[0], module_name\n            )\n\n            self.subs[target_topic] = self.create_subscription(\n                msg_type_class, target_topic, self.msg_callback, 500\n            )\n\n            print(f\"[state monitor] subscribed to {target_topic}\")\n            time.sleep(1)\n\n        # self.play_rosbag(exec_cnt)\n\n    def msg_callback(self, msg):\n        \"\"\"\n        Generic callback for storing re-played messages of any topic\n        \"\"\"\n\n        self.msg_queue.append(msg)\n\n    def play_rosbag(self, exec_cnt):\n        rosbag_cmd = f\"ros2 bag play states-{exec_cnt}.bag\"\n\n        self.rosbag_proc = sp.Popen(\n            rosbag_cmd, shell=True, stdout=sp.PIPE, stderr=sp.PIPE\n        )\n        print(\"[checker] started ros2 bag play:\", rosbag_cmd)\n\n    def check_rosbag(self):\n        # check if ros2 bag play is still running\n        pass\n\n\ndef group_msgs_by_topic(states):\n    \"\"\"\n    input: queue of messages of various topics\n    output: dictionary mapping each topic to corresponding messages\n    \"\"\"\n\n    topic_to_msg_dict = {}\n    for msg in states:\n        msg_type_name = f\"{msg.__class__.__module__}.{msg.__class__.__name__}\"\n        try:\n            topic_to_msg_dict[msg_type_name].append(msg)\n        except KeyError:\n            topic_to_msg_dict[msg_type_name] = [msg]\n\n    return topic_to_msg_dict\n\n\ndef retrieve_states():\n    state_msgs = pickle.load(open(\"states.pkl\", \"rb\"))\n    print(\"recorded:\", len(state_msgs))\n\n    try:\n        os.remove(\"states.pkl\")\n    except:\n        print(\"[-] cannot remove states file\")\n    # print(\"[monitor] retrieved states\")\n\n    return state_msgs\n\n\ndef run_checks(config, msg_list, state_dict, feedback_list=[]):\n    \"\"\"invoke checks of the oracles defined for each target package\n\n    Parameters\n    ----------\n    config : RuntimeConfig object\n    msg_list : list of messages published\n    state_dict : dict of messages captured by pre-defined state topics\n    feedback_list : list of Feedback objects\n    \"\"\"\n\n    errs = []\n    if config.rospkg == \"turtlesim\":\n        try:\n            pose_list = state_dict[\"/turtle1/pose\"]\n        except KeyError:\n            print(\"[checker] no Pose available\")\n            return errs\n\n        errs = oracles.turtlesim.check(config, msg_list, pose_list, feedback_list)\n\n    elif config.tb3_sitl or config.tb3_hitl:\n        if (\n            \"/imu\" not in state_dict\n            and \"/odom\" not in state_dict\n            and \"/scan_list\" not in state_dict\n        ):\n            print(\"[checker] no state available\")\n            return errs\n\n        errs = oracles.turtlebot.check(config, msg_list, state_dict, feedback_list)\n\n    elif config.px4_sitl:\n        if (\n            \"/ActuatorArmed_PubSubTopic\" not in state_dict\n            and \"/ActuatorOutputs_PubSubTopic\" not in state_dict\n            and \"/BatteryStatus_PubSubTopic\" not in state_dict\n            and \"/SensorAccel_PubSubTopic\" not in state_dict\n            and \"/SensorBaro_PubSubTopic\" not in state_dict\n            and \"/SensorGps_PubSubTopic\" not in state_dict\n            and \"/SensorGyro_PubSubTopic\" not in state_dict\n            and \"/SensorsStatusImu_PubSubTopic\" not in state_dict\n            and \"/SensorCombined_PubSubTopic\" not in state_dict\n            and \"/VehicleOdometry_PubSubTopic\" not in state_dict\n            and \"/VehicleImu_PubSubTopic\" not in state_dict\n            and \"/VehicleGpsPosition_PubSubTopic\" not in state_dict\n            and \"/VehicleLocalPosition_PubSubTopic\" not in state_dict\n            and \"/VehicleGlobalPosition_PubSubTopic\" not in state_dict\n            and \"/VehicleAttitude_PubSubTopic\" not in state_dict\n            and \"/VehicleAcceleration_PubSubTopic\" not in state_dict\n            and \"/VehicleAngularAcceleration_PubSubTopic\" not in state_dict\n            and \"/VehicleAngularVelocity_PubSubTopic\" not in state_dict\n        ):\n            print(\"[checker] no state available\")\n            return errs\n\n        errs = oracles.px4.check(config, msg_list, state_dict, feedback_list)\n\n    elif config.test_moveit:\n        if (\n            \"/joint_states\" not in state_dict\n            and \"/panda_arm_controller/state\" not in state_dict\n            and \"/move_action/_action/status\" not in state_dict\n            and \"/motion_plan_request\" not in state_dict\n        ):\n            print(\"[checker] no state available\")\n            return errs\n\n        errs = oracles.moveit.check(config, msg_list, state_dict, feedback_list)\n\n    elif config.test_rosidl:\n        if len(msg_list) != 1:\n            print(\"[-] msg_list contains more than one message\")\n            exit(1)\n\n        errs = oracles.rosidl.check(config, msg_list, state_dict, feedback_list)\n\n    elif config.test_cli:\n        try:\n            with open(\"out-0\", \"r\") as f:\n                out0 = \"\\n\".join(f.readlines())\n        except:\n            print(\"[checker] out-0 does not exist\")\n            exit(1)\n\n        try:\n            with open(\"out-1\", \"r\") as f:\n                out1 = \"\\n\".join(f.readlines())\n        except:\n            print(\"[checker] out-1 does not exist\")\n            exit(1)\n\n        if out0 != out1:\n            errs = [f\"CLI outputs do not match: {out0} vs {out1}\"]\n\n    # Print result\n    if len(errs) > 0:\n        if len(errs) > 10:\n            print(f\"{c.RED}ERROR DETECTED: {len(errs)}\")\n            for err in list(set(errs))[:10]:\n                print(\"-\", err)\n            print(\"- ...\")\n            print(c.END)\n        else:\n            print(f\"{c.RED}ERROR DETECTED: {len(errs)}\")\n            for err in list(set(errs)):\n                print(\"-\", err)\n            print(c.END)\n\n    return errs\n\n\ndef run_rpt_checks(config, state_dict_list):\n    \"\"\"check if repeated executions over the same messages result in the identical states\"\"\"\n\n    print(\n        f\"[checker] cross-checking states from {len(state_dict_list)} executions\"\n    )\n\n    last_states = dict()\n\n    for state_dict in state_dict_list:\n        for topic in state_dict:\n            last_state = state_dict[topic][-1]\n            if topic not in last_states:\n                last_states[topic] = [last_state]\n            else:\n                last_states[topic].append(last_state)\n\n    errs = []\n\n    for topic in last_states:\n        last_msgs = last_states[topic]\n        num_last_states = len(last_msgs)\n        if num_last_states != len(state_dict_list):\n            errs.append(f\"number of topics do not match: {topic}\")\n\n        # TODO: cross-check messages in last_msgs\n\n    return errs\n\n\nclass APIChecker:\n    def __init__(self, feature, targets, job):\n        self.tracer = \"ltrace\"\n        self.feature = feature\n        self.targets = targets\n        self.job = job\n\n    def config_trace(self):\n        pass\n\n    def get_timestamp(self, filename=\"out\"):\n        if not os.path.isfile(filename):\n            print(f\"[tracer] Cannot find trace file {filename}\")\n            return -1\n\n        with open(filename, \"r\") as fp:\n            out_raw = fp.readlines()\n\n        t0 = -1\n        t1 = 2147483647.0\n        for line in out_raw:\n            if \"time1\" in line:\n                t0 = line.strip().split(\" \")[-1]\n                if \".\" not in t0:\n                    t0 = (\n                        int(t0) / 1000000.0\n                    )  # c++/rust prints us w/o decimal point\n                else:\n                    t0 = float(t0)\n            elif \"time2\" in line:\n                t1 = line.strip().split(\" \")[-1]\n                if \".\" not in t1:\n                    t1 = (\n                        int(t1) / 1000000.0\n                    )  # c++/rust prints us w/o decimal point\n                else:\n                    t1 = float(t1)\n                break\n\n        self.t0 = t0\n        self.t1 = t1\n\n    def parse_trace(self, filename=\"trace\"):\n        if not os.path.isfile(filename):\n            print(f\"[tracer] Cannot find trace file {filename}\")\n            return -1\n\n        func_dict = dict()\n\n        with open(filename, \"r\") as fp:\n            trace_raw = fp.readlines()\n\n        for line in trace_raw:\n            line = line.strip()\n            timestamp = float(line.split(\" \")[0])\n\n            if timestamp < self.t0 or timestamp > self.t1:\n                continue\n\n            if \"<unfinished ...>\" in line:\n                func_name = line.split(\" \")[1].split(\"@\")[0]\n                retval = None\n                if func_name in func_dict:\n                    func_dict[func_name].append([timestamp, retval])\n                else:\n                    func_dict[func_name] = [[timestamp, retval]]\n\n            elif \"<...\" in line and \"resumed>\" in line:\n                func_name = line.split(\" \")[2]\n                retval = line.split(\"= \")[-1]\n\n                if func_name not in func_dict:\n                    print(f\"[tracer] fatal error: {func_name} not seen yet\")\n                    return -1\n\n                # update retval\n                func_dict[func_name][-1][1] = retval\n\n            elif \".so\" in line:\n                func_name = line.split(\" \")[1].split(\"@\")[0]\n                retval = line.split(\"= \")[-1]\n\n                if func_name in func_dict:\n                    func_dict[func_name].append([timestamp, retval])\n                else:\n                    func_dict[func_name] = [[timestamp, retval]]\n\n        # print(func_dict)\n        return func_dict\n\n    def check_deviant(self):\n        print(\"[API checker] Checking deviant API behavior\")\n        target_trace_map = dict()\n\n        for i, target in enumerate(self.targets):\n            outfile = f\"out-{i}\"\n            tracefile = f\"trace-{i}\"\n            ret = self.get_timestamp(outfile)\n            func_dict = self.parse_trace(tracefile)\n            target_trace_map[target] = func_dict\n\n        # 1. check if each lang calls the same API\n        functions_list = list()\n        target_list = target_trace_map.keys()\n        for target in target_list:\n            func_dict = target_trace_map[target]\n            functions = list(func_dict.keys())\n            functions.sort()\n            functions_list.append(functions)\n\n        if not functions_list.count(functions_list[0]) == len(functions_list):\n            err = \"RCL API discrepancy - called APIs do not match\"\n            for f in functions_list:\n                print(f)\n            return err\n\n        # 2. check retval\n        function_retvals_map = dict()\n        for target in target_list:\n            func_dict = target_trace_map[target]\n            functions = list(func_dict.keys())\n\n            for function in functions:\n                ret_list = [x[1] for x in func_dict[function]]\n                if function in function_retvals_map:\n                    function_retvals_map[function].append(ret_list)\n                else:\n                    function_retvals_map[function] = [ret_list]\n\n        for function in function_retvals_map:\n            retvals_list = function_retvals_map[function]\n            if not retvals_list.count(retvals_list[0]) == len(retvals_list):\n                err = \"RCL API discrepancy - return values do not match\"\n                print(function_retvals_map)\n                return err\n\n\nclass CollisionChecker:\n    topic_proc_map = dict()\n    # topic_stdout_map = dict()\n    collision_events = dict()\n    topic_monitor_map = dict()\n\n    def __init__(self):\n        pass\n\n    def listen(self, topics):\n        print(\"[collision checker] start listening\")\n        self.collision_events = dict()\n        for topic in topics:\n            # print(\"[collision checker] start listening to \", topic)\n\n            cmd = [\"gz\", \"topic\", \"-u\", \"-e\", topic]\n            proc = sp.Popen(cmd, shell=False, stdout=sp.PIPE, stderr=sp.PIPE)\n\n            t = threading.Thread(\n                target=self.monitor,\n                args=(\n                    proc,\n                    topic,\n                ),\n            )\n            t.start()\n\n            self.topic_proc_map[topic] = proc\n            self.topic_monitor_map[topic] = t\n\n    def stop(self):\n        print(\"[collision checker] stop listening\")\n        for topic in self.topic_proc_map:\n            # print(\"[collision checker] stop listening to\", topic)\n\n            proc = self.topic_proc_map[topic]\n            proc.kill()\n\n            thread = self.topic_monitor_map[topic]\n            thread.join()\n            assert thread.is_alive() is False\n\n            # self.topic_stdout_map[topic] = outs\n\n    def monitor(self, proc, topic):\n        for line in iter(proc.stdout.readline, b\"\"):\n            if b\"contact\" in line:\n                line_str = line.decode(\"utf-8\")\n                # print(\"collision: {0}\".format(line_str), end=\"\")\n\n                try:\n                    self.collision_events[topic].append(line_str)\n                except KeyError:\n                    self.collision_events[topic] = [line_str]\n\n    def found_collision(self):\n\n        if len(self.collision_events) > 0:\n            return True\n\n        # for topic in self.topic_stdout_map:\n        # outs = self.topic_stdout_map[topic]\n        # if b'contact' in outs:\n        # self.collision_topic.append(topic)\n        # collision = True\n\n        # return collision\n\n    def print_collision_topics(self) -> None:\n\n        print(list(self.collision_events.keys()))\n"}\n{"instruction": "Write a ROS2 Python node named demo.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "#!/usr/bin/env python3\nfrom reach import load, runReachStudy\nfrom reach_ros import init_ros, set_parameter, parse_yaml, set_logger_level, update_search_libraries_env\n\nfrom ament_index_python.packages import get_package_share_directory\nimport os\nfrom rclpy.parameter import Parameter\nfrom rclpy.logging import LoggingSeverity\nimport sys\nimport xacro\nimport yaml\n\n\ndef main():\n    # initialize ROS with any parameters provided as arguments\n    init_ros(sys.argv)\n\n    # Set logger level to reduce MoveIt message spam\n    moveit_loggers = [\"moveit_ros\",\n                      \"moveit_kinematics_base\",\n                      \"moveit_rdf_loader\",\n                      \"moveit_robot_model\"]\n    for logger_name in moveit_loggers:\n        try:\n            set_logger_level(logger_name, LoggingSeverity.WARN)\n        except:\n            pass\n\n    # Manually load the parameters necessary for running MoveIt.\n    reach_ros_dir = get_package_share_directory('reach_ros')\n    model_dir = os.path.join(reach_ros_dir, 'demo', 'model')\n\n    # Generate the URDF string from the xacro file\n    urdf = xacro.process(os.path.join(model_dir, 'reach_study.xacro'))\n\n    # Load the SRDF\n    with open(os.path.join(model_dir, 'reach_study.srdf'), 'r') as f:\n        srdf = f.read()\n\n    moveit_parameters = [\n        *parse_yaml(os.path.join(model_dir, 'kinematics.yaml'), 'robot_description_kinematics.'),\n        *parse_yaml(os.path.join(model_dir, 'joint_limits.yaml'), 'robot_description_joint_limits.'),\n        Parameter(name=\"robot_description\", value=urdf),\n        Parameter(name=\"robot_description_semantic\", value=srdf),\n    ]\n\n    for parameter in moveit_parameters:\n        # We don't need to declare the parameters as the node allows undeclared parameters\n        set_parameter(parameter.name, parameter.value)\n\n    with open(os.path.join(reach_ros_dir, 'demo', 'config', 'reach_study.yaml'), 'r') as f:\n        config = yaml.safe_load(f)\n\n    # Update the search libraries environment variable to include the plugin library provided by this package\n    update_search_libraries_env()\n\n    # Disable the optimization steps to make this demo faster and highlight the performance difference\n    config['optimization']['max_steps'] = 0\n\n    print(\"Starting first study with default kinematic parameters\")\n    save_dir = \"/tmp\"\n    study_name = \"study1\"\n    runReachStudy(config, study_name, save_dir, False)\n\n    # Loading the study results\n    results_1 = load(os.path.join(save_dir, study_name, 'reach.db.xml')).calculateResults()\n\n    # Decrease the IK solver time and see if we still find equally good solutions\n    set_parameter(\n        \"robot_description_kinematics.manipulator.kinematics_solver_timeout\", 0.00005)\n\n    print(\"Starting second study with decreased solver resolution.\")\n    study_name = 'study2'\n    runReachStudy(config, study_name, save_dir, False)\n\n    # Loading the study results\n    results_2 = load(os.path.join(save_dir, study_name, 'reach.db.xml')).calculateResults()\n\n    print('Both REACH studies finished')\n    print(f'\\tOriginal parameters: Score {results_1.total_pose_score:.2f}, Reached {results_1.reach_percentage:.2f}%')\n    print(f'\\tModified parameters: Score {results_2.total_pose_score:.2f}, Reached {results_2.reach_percentage:.2f}%')\n\n\nif __name__ == '__main__':\n    main()\n"}\n{"instruction": "Write a ROS2 Python node named reset.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "import rclpy\nfrom rclpy.node import Node\nfrom pymoveit2 import MoveIt2\nfrom rcl_interfaces.srv import GetParameters\nimport xml.etree.ElementTree as ET\nimport time\nimport numpy as np\n\nARM_GROUP_NAME = 'arm34'\nGRIPPER_GROUP_NAME = 'gripper34'\nPOSE_NAME = 'rest'\nVELOCITY_FACTOR = 0.1\nACCELERATION_FACTOR = 0.1\nPLANNING_TIME = 5.0\nPLANNING_ATTEMPTS = 10\n\n\nclass Moveit:\n    def __init__(self):\n        self.moveit_node = Node('reset_moveit_node')\n        self.get_param_cli = None\n\n    def setup_get_move_group_params(self, get_parameters='/move_group/get_parameters'):\n        self.get_param_cli = self.moveit_node.create_client(GetParameters, get_parameters)\n        while not self.get_param_cli.wait_for_service(timeout_sec=1.0):\n            self.moveit_node.get_logger().info('[Env] [Moveit] service not available, waiting again...')\n        self.req = GetParameters.Request()\n        return\n\n    def get_move_group_params(self, param):\n        if self.get_param_cli is None: self.setup_get_move_group_params()\n        self.req.names = [param]\n        itreation = 0\n        while True:\n            itreation += 1\n            self.future = self.get_param_cli.call_async(self.req)\n            rclpy.spin_until_future_complete(self.moveit_node, self.future, timeout_sec=1.0)\n            if self.future.result() is not None:\n                return self.future.result().values[0]\n            elif itreation > 10:\n                return False\n            else:\n                print(\"Service call failed %r\" % (self.future.exception(),))\n                time.sleep(1)\n                continue\n\n    def moveit_extract_joint_info(self):\n        semantic_description = self.get_move_group_params('robot_description_semantic')\n        self.moveit_info = ET.fromstring(semantic_description.string_value)\n        self.moveit_group_poses, self.moveit_arms_joint_names, self.moveit_hand_joint_names = {}, [], []\n        for child in self.moveit_info:\n            if child.tag == 'group_state' and child.attrib['group'] == ARM_GROUP_NAME:\n                if ARM_GROUP_NAME not in self.moveit_group_poses:\n                    self.moveit_group_poses[ARM_GROUP_NAME] = {}\n                self.moveit_group_poses[ARM_GROUP_NAME][child.attrib['name']] = []\n                for joint in child:\n                    self.moveit_group_poses[ARM_GROUP_NAME][child.attrib['name']].append(\n                        float(joint.attrib['value']))\n                if len(self.moveit_arms_joint_names) == 0:\n                    self.moveit_arms_joint_names = [joint.attrib['name'] for joint in child]\n            elif child.tag == 'group_state' and child.attrib['group'] == GRIPPER_GROUP_NAME:\n                if GRIPPER_GROUP_NAME not in self.moveit_group_poses:\n                    self.moveit_group_poses[GRIPPER_GROUP_NAME] = {}\n                self.moveit_group_poses[GRIPPER_GROUP_NAME][child.attrib['name']] = []\n                for joint in child:\n                    self.moveit_group_poses[GRIPPER_GROUP_NAME][child.attrib['name']].append(\n                        float(joint.attrib['value']))\n                if len(self.moveit_hand_joint_names) == 0:\n                    self.moveit_hand_joint_names = [joint.attrib['name'] for joint in child]\n        return\n\n    def setup_moveit(self):\n        self.moveit_extract_joint_info()\n        self.arms_group = MoveIt2(node=self.moveit_node, joint_names=self.moveit_arms_joint_names,\n                                  base_link_name='', end_effector_name='',\n                                  group_name=ARM_GROUP_NAME,\n                                  use_move_group_action=True)\n        self.arms_group.num_planning_attempts = PLANNING_ATTEMPTS\n        self.arms_group.allowed_planning_time = PLANNING_TIME\n        self.arms_group.max_velocity = VELOCITY_FACTOR\n        self.arms_group.max_acceleration = ACCELERATION_FACTOR\n\n        self.arms_group.move_to_configuration(self.moveit_group_poses[ARM_GROUP_NAME][POSE_NAME])\n        self.arms_group.wait_until_executed()\n\n        if self.moveit_hand_joint_names:\n            self.hand_group = MoveIt2(node=self.moveit_node, joint_names=self.moveit_hand_joint_names,\n                                      base_link_name='', end_effector_name='',\n                                      group_name=GRIPPER_GROUP_NAME, use_move_group_action=True)\n            self.hand_group.num_planning_attempts = PLANNING_ATTEMPTS\n            self.hand_group.allowed_planning_time = PLANNING_TIME\n            self.hand_group.max_velocity = VELOCITY_FACTOR\n            self.hand_group.max_acceleration = ACCELERATION_FACTOR\n            if POSE_NAME in self.moveit_group_poses[GRIPPER_GROUP_NAME]:\n                self.hand_group.move_to_configuration(\n                    self.moveit_group_poses[GRIPPER_GROUP_NAME][POSE_NAME])\n            else:\n                self.hand_group.move_to_configuration(self.moveit_group_poses[GRIPPER_GROUP_NAME]['init'])\n            self.hand_group.wait_until_executed()\n        return\n\nif __name__ == '__main__':\n    rclpy.init()\n    moveit = Moveit()\n    moveit.setup_moveit()\n    print(\"MoveIt setup complete.\")\n    rclpy.shutdown()\n\n"}\n{"instruction": "Write a ROS2 Python node named moveit_ik.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "import rclpy\nfrom rclpy.node import Node\n\nfrom sensor_msgs.msg import JointState\nfrom tf2_ros import TransformException\nfrom tf2_ros.buffer import Buffer\nfrom tf2_ros.transform_listener import TransformListener\nfrom moveit_msgs.srv import GetPositionIK\n\nimport numpy as np\n\ntarget_angles = None\nglobal_joint_states = None\ntf_base_link_P = None\n\n\nclass MinimalClientAsync:\n    def __init__(self, node):\n        self.logger = node.get_logger()\n        self.clock = node.get_clock()\n        self.node = node\n\n        self.tf_buffer = Buffer()\n        self.tf_listener = TransformListener(self.tf_buffer, node)\n        self.timer = node.create_timer(1.0, self.on_timer)\n        node.create_subscription(JointState, \"/joint_states\", self.joint_states_cb, 1)\n\n        self.cli = node.create_client(GetPositionIK, \"/compute_ik\")\n        while not self.cli.wait_for_service(timeout_sec=1.0):\n            self.logger.info(\"service not available, waiting again...\")\n\n    def on_timer(self):\n        global tf_base_link_P\n        # Look up for the transformation between target_frame and turtle2 frames\n        # and send velocity commands for turtle2 to reach target_frame\n        try:\n            t = self.tf_buffer.lookup_transform(\n                \"base_link\", \"P\", rclpy.time.Time(), rclpy.duration.Duration(seconds=1)\n            )\n\n            tf_base_link_P = [\n                t.transform.translation.x,\n                t.transform.translation.y,\n                t.transform.translation.z,\n                t.transform.rotation.x,\n                t.transform.rotation.y,\n                t.transform.rotation.z,\n                t.transform.rotation.w,\n            ]\n            self.tf_base_link_P = tf_base_link_P\n        except TransformException as ex:\n            self.logger.info(f\"Could not transform base_link to P: {ex}\")\n            return\n\n    def joint_states_cb(self, joint_state):\n        global global_joint_states\n        global_joint_states = joint_state\n        self.joint_state = joint_state\n\n    def moveit_ik(self):\n        group_name = \"spot_arm\"\n        self.req.ik_request.group_name = group_name\n        self.req.ik_request.robot_state.joint_state = self.joint_state\n        self.req.ik_request.avoid_collisions = True\n\n        self.req.ik_request.pose_stamped.header.stamp = self.clock.now().to_msg()\n        self.req.ik_request.pose_stamped.header.frame_id = \"base_link\"\n\n        self.req.ik_request.pose_stamped.pose.position.x = self.tf_base_link_P[0]\n        self.req.ik_request.pose_stamped.pose.position.y = self.tf_base_link_P[1]\n        self.req.ik_request.pose_stamped.pose.position.z = self.tf_base_link_P[2] + 0.05\n\n        self.req.ik_request.pose_stamped.pose.orientation.x = self.tf_base_link_P[3]\n        self.req.ik_request.pose_stamped.pose.orientation.y = self.tf_base_link_P[4]\n        self.req.ik_request.pose_stamped.pose.orientation.z = self.tf_base_link_P[5]\n        self.req.ik_request.pose_stamped.pose.orientation.w = self.tf_base_link_P[6]\n\n        self.req.ik_request.timeout.sec = 5\n\n        return self.req.ik_request\n\n    def send_request(self):\n        self.req = GetPositionIK.Request()\n        self.req.ik_request = self.moveit_ik()\n\n        self.future = self.cli.call_async(self.req)\n        rclpy.spin_until_future_complete(self.node, self.future)\n        return self.future.result()\n\n\ndef main():\n    rclpy.init()\n    node = Node(\"moveit_ik_python\")\n\n    minimal_client = MinimalClientAsync(node)\n    while global_joint_states is None or tf_base_link_P is None:\n        rclpy.spin_once(node)\n    response = minimal_client.send_request()\n    print(response.solution.joint_state.name[:7])\n    target_angles = list(response.solution.joint_state.position)[:7]\n\n    if not len(target_angles):\n        print(\"No IK solution found\")\n        node.destroy_node()\n        rclpy.shutdown()\n        return\n    print([round(np.rad2deg(ta)) for ta in target_angles])\n\n\nif __name__ == \"__main__\":\n    main()\n"}\n{"instruction": "Write a ROS2 Python node named moveit_servo.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "# Copyright 2024 The HuggingFace Inc. team. All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport logging\n\nfrom geometry_msgs.msg import TwistStamped\nfrom moveit_msgs.srv import ServoCommandType\nfrom rclpy import qos\nfrom rclpy.callback_groups import CallbackGroup\nfrom rclpy.node import Node\nfrom std_srvs.srv import SetBool\n\nlogger = logging.getLogger(__name__)\n\n\nclass MoveIt2Servo:\n    \"\"\"\n    Python interface for MoveIt2 Servo.\n    \"\"\"\n\n    def __init__(\n        self,\n        node: \"Node\",\n        frame_id: str,\n        callback_group: \"CallbackGroup\",\n    ):\n        self._node = node\n        self._frame_id = frame_id\n        self._enabled = False\n\n        self._twist_pub = node.create_publisher(\n            TwistStamped,\n            \"/servo_node/delta_twist_cmds\",\n            qos.QoSProfile(\n                durability=qos.QoSDurabilityPolicy.VOLATILE,\n                reliability=qos.QoSReliabilityPolicy.RELIABLE,\n                history=qos.QoSHistoryPolicy.KEEP_ALL,\n            ),\n            callback_group=callback_group,\n        )\n        self._pause_srv = node.create_client(\n            SetBool, \"/servo_node/pause_servo\", callback_group=callback_group\n        )\n        self._cmd_type_srv = node.create_client(\n            ServoCommandType, \"/servo_node/switch_command_type\", callback_group=callback_group\n        )\n        self._twist_msg = TwistStamped()\n        self._enable_req = SetBool.Request(data=False)\n        self._disable_req = SetBool.Request(data=True)\n        self._twist_type_req = ServoCommandType.Request(command_type=ServoCommandType.Request.TWIST)\n\n    def enable(self, wait_for_server_timeout_sec=1.0) -> bool:\n        if not self._pause_srv.wait_for_service(timeout_sec=wait_for_server_timeout_sec):\n            logger.warning(\"Pause service not available.\")\n            return False\n        if not self._cmd_type_srv.wait_for_service(timeout_sec=wait_for_server_timeout_sec):\n            logger.warning(\"Command type service not available.\")\n            return False\n        result = self._pause_srv.call(self._enable_req)\n        if not result or not result.success:\n            logger.error(f\"Enable failed: {getattr(result, 'message', '')}\")\n            self._enabled = False\n            return False\n        cmd_result = self._cmd_type_srv.call(self._twist_type_req)\n        if not cmd_result or not cmd_result.success:\n            logger.error(\"Switch to TWIST command type failed.\")\n            self._enabled = False\n            return False\n        logger.info(\"MoveIt Servo enabled.\")\n        self._enabled = True\n        return True\n\n    def disable(self, wait_for_server_timeout_sec=1.0) -> bool:\n        if not self._pause_srv.wait_for_service(timeout_sec=wait_for_server_timeout_sec):\n            logger.warning(\"Pause service not available.\")\n            return False\n        result = self._pause_srv.call(self._disable_req)\n        self._enabled = not (result and result.success)\n        return bool(result and result.success)\n\n    def servo(self, linear=(0.0, 0.0, 0.0), angular=(0.0, 0.0, 0.0), enable_if_disabled=True):\n        if not self._enabled and enable_if_disabled and not self.enable():\n            logger.warning(\"Dropping servo command because MoveIt2 Servo is not enabled.\")\n            return\n\n        self._twist_msg.header.frame_id = self._frame_id\n        self._twist_msg.header.stamp = self._node.get_clock().now().to_msg()\n        self._twist_msg.twist.linear.x = float(linear[0])\n        self._twist_msg.twist.linear.y = float(linear[1])\n        self._twist_msg.twist.linear.z = float(linear[2])\n        self._twist_msg.twist.angular.x = float(angular[0])\n        self._twist_msg.twist.angular.y = float(angular[1])\n        self._twist_msg.twist.angular.z = float(angular[2])\n        self._twist_pub.publish(self._twist_msg)\n"}\n{"instruction": "Write a ROS2 Python node named moveit_py.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "\nimport rclpy\nimport time\nfrom rclpy.node import Node\nfrom rclpy.logging import get_logger\nfrom moveit.planning import (MoveItPy,MultiPipelinePlanRequestParameters)\nfrom moveit.core.planning_scene import PlanningScene\nfrom geometry_msgs.msg import Pose\n\ndef plan_and_execute(\n    robot,\n    planning_component,\n    logger,\n    single_plan_parameters=None,\n    multi_plan_parameters=None,\n    sleep_time=0.0,\n):\n    \"\"\"Helper function to plan and execute a motion.\"\"\"\n    # plan to goal\n    logger.info(\"Planning trajectory\")\n    if multi_plan_parameters is not None:\n        plan_result = planning_component.plan(\n            multi_plan_parameters=multi_plan_parameters\n        )\n    elif single_plan_parameters is not None:\n        plan_result = planning_component.plan(\n            single_plan_parameters=single_plan_parameters\n        )\n    else:\n        plan_result = planning_component.plan()\n\n    # execute the plan\n    if plan_result:\n        logger.info(\"Executing plan\")\n        robot_trajectory = plan_result.trajectory\n        robot.execute(robot_trajectory, controllers=[])\n    else:\n        logger.error(\"Planning failed\")\n\n    time.sleep(sleep_time)\n\n\ndef main():\n    rclpy.init()\n    logger = get_logger(\"moveit_example\")\n    node = rclpy.create_node('moveit_example')\n\n    # Initialize MoveItPy\n    panda = MoveItPy(node_name=\"moveit_py\")\n    panda_arm = panda.get_planning_component(\"panda_arm\")\n    logger.info(\"MoveItPy instance created\")\n\n    # set plan start state to current state\n    panda_arm.set_start_state_to_current_state()\n\n    # set pose goal with PoseStamped message\n    from geometry_msgs.msg import PoseStamped\n\n    pose_goal = PoseStamped()\n    pose_goal.header.frame_id = \"panda_link0\"\n    pose_goal.pose.orientation.w = 1.0\n    pose_goal.pose.position.x = 0.28\n    pose_goal.pose.position.y = -0.2\n    pose_goal.pose.position.z = 1.0\n    panda_arm.set_goal_state(pose_stamped_msg=pose_goal, pose_link=\"panda_link8\")\n\n    time.sleep(5.0)\n\n    # plan to goal\n    plan_and_execute(panda, panda_arm, logger, sleep_time=3.0)\n\nif __name__ == '__main__':\n    main()\n"}\n{"instruction": "Write a ROS2 Python node named moveit2.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "\"\"\"\nA simple python interface with MoveIt2 services (and actions). This is an alternative to\nmoveit_commander, which is not yet ported to ROS 2 (as of Oct 2020).\nNote: This module is currently configured for Franka Emika Panda robot.\nNote: There is no Ignition-specific code in this module (this repo is just a convinient place).\n\nthe code is from https://github.com/AndrejOrsula/ign_moveit2 ,and is modified.\n\"\"\"\n\nimport threading\n\nimport rclpy\nfrom rclpy.node import Node\nfrom rclpy.action import ActionClient\n\nfrom std_msgs.msg import Float32\nfrom builtin_interfaces.msg import Duration\nfrom geometry_msgs.msg import Pose, Quaternion\nfrom shape_msgs.msg import SolidPrimitive\nfrom sensor_msgs.msg import JointState\nfrom trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint\nfrom moveit_msgs.msg import Constraints, JointConstraint, PositionConstraint, OrientationConstraint\nfrom moveit_msgs.msg import PositionIKRequest, RobotTrajectory\nfrom moveit_msgs.srv import GetPositionIK, GetPositionFK, GetMotionPlan, GetCartesianPath\nfrom moveit_msgs.action import MoveGroup\nfrom action_msgs.msg import GoalStatus\n\n\nclass MoveIt2Interface(Node):\n\n    def __init__(self):\n        super().__init__(\"ign_moveit2_py\")\n        self.init_robot()\n        self.init_compute_fk()\n        self.init_compute_ik()\n        self.init_plan_kinematic_path()\n        self.init_plan_cartesian_path()\n        self.get_logger().info(\"ign_moveit2_py initialised successfuly\")\n\n    def init_robot(self):\n        \"\"\"\n        Initialise robot groups, links and joints. This would normally get loaded from URDF via\n        `moveit_commander`.\n        This also initialises subscriber to joint states and publisher to joint trajectories.\n        \"\"\"\n        self.robot_group_name = \"ur10\"\n        # Arm\n        self.arm_group_name = \"manipulator\"\n        self.arm_joints = [\"shoulder_pan_joint\",\n                           \"shoulder_lift_joint\",\n                           \"elbow_joint\",\n                           \"wrist_1_joint\",\n                           \"wrist_2_joint\",\n                           \"wrist_3_joint\"]\n        self.arm_links = [\"base_link\",\n                          \"shoulder_link\",\n                          \"upper_arm_link\",\n                          \"forearm_link\",\n                          \"wrist_1_link\",\n                          \"wrist_2_link\",\n                          \"wrist_3_link\",\n                          \"ee_link\"]\n        self.arm_base_link = self.arm_links[0]\n        self.arm_end_effector = self.arm_links[-1]\n\n        # Publisher of trajectories\n        self.joint_trajectory_pub = self.create_publisher(JointTrajectory,\n                                                          \"set_joint_trajectory\", 1)\n\n        # Subscriber of current joint states\n        self.joint_state = JointState()\n        self.joint_state_mutex = threading.Lock()\n        self.joint_state_sub = self.create_subscription(JointState,\n                                                        \"joint_states\",\n                                                        self.joint_state_callback, 1)\n\n        # Subscriber of joint trajectory progress\n        self.joint_progress = 1.0\n        self.joint_progress_cond = threading.Condition()\n        self.joint_progress_sub = self.create_subscription(Float32,\n                                                           \"joint_trajectory_progress\",\n                                                           self.joint_progress_callback, 1)\n\n    def joint_state_callback(self, msg):\n        \"\"\"\n        Callback for getting current joint states.\n        \"\"\"\n        self.joint_state_mutex.acquire()\n        self.joint_state = msg\n        self.joint_state_mutex.release()\n\n    def get_joint_state(self) -> JointState:\n        \"\"\"\n        Get current joint states.\n        \"\"\"\n        self.joint_state_mutex.acquire()\n        joint_state = self.joint_state\n        self.joint_state_mutex.release()\n        return joint_state\n\n    def joint_progress_callback(self, msg):\n        \"\"\"\n        Callback for getting joint trajectory progress.\n        \"\"\"\n        with self.joint_progress_cond:\n            self.joint_progress = msg.data\n            self.joint_progress_cond.notify_all()\n\n    def wait_until_executed(self):\n        \"\"\"\n        Function that halts execution on the current thread until trajectory is executed.\n        \"\"\"\n        with self.joint_progress_cond:\n            while not self.joint_progress == 1.0:\n                self.joint_progress_cond.wait(timeout=0.5)\n\n    def pub_trajectory(self, trajectory):\n        \"\"\"\n        Publish trajectory such that it can be executed, e.g. by `JointTrajectoryController`\n        Ignition plugin.\n        \"\"\"\n        if isinstance(trajectory, JointTrajectory):\n            self.joint_trajectory_pub.publish(trajectory)\n            self.get_logger().info(\"pub trajectory msg!\")\n        elif isinstance(trajectory, RobotTrajectory):\n            self.joint_trajectory_pub.publish(trajectory.joint_trajectory)\n        else:\n            raise Exception(\"Invalid type passed into pub_trajectory()\")\n\n    def execute(self, joint_trajectory=None) -> bool:\n        \"\"\"\n        Execute last planned motion plan, or the `joint_trajectory` specified as argument.\n        \"\"\"\n\n        if joint_trajectory == None:\n            plan = self.motion_plan_.joint_trajectory\n        else:\n            plan = joint_trajectory\n\n        # Make sure there is a plan to follow\n        if not plan.points:\n            self.get_logger().warn(\n                \"Cannot execute motion plan because it does not contain any trajectory points\")\n            return False\n\n        # Reset joint progress\n        self.joint_progress = 0.0\n\n        self.pub_trajectory(plan)\n        return True\n\n    def move_to_joint_state(self, joint_state,\n                            set_position=True,\n                            set_velocity=True,\n                            set_effort=True):\n        \"\"\"\n        Set joint target on all joints defined in `joint_state`. This function does NOT plan a\n        smooth trajectory and only publishes joint_state as the next goal that should be reached\n        immediately.\n        \"\"\"\n        joint_trajectory = JointTrajectory()\n        joint_trajectory.joint_names = joint_state.name\n\n        point = JointTrajectoryPoint()\n        if set_position:\n            point.positions = joint_state.position\n        if set_velocity:\n            point.velocities = joint_state.velocity\n        if set_effort:\n            point.effort = joint_state.effort\n        joint_trajectory.points.append(point)\n\n        self.pub_trajectory(joint_trajectory)\n\n    # compute_fk\n    def init_compute_fk(self):\n        \"\"\"\n        Initialise `compute_fk` service.\n        \"\"\"\n        self.compute_fk_client = self.create_client(GetPositionFK,\n                                                    \"compute_fk\")\n        while not self.compute_fk_client.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info(\n                \"Service [compute_fk] not currently available, waiting...\")\n\n        self.fk_request = GetPositionFK.Request()\n        self.fk_request.header.frame_id = self.arm_base_link\n        # self.fk_request.header.stamp = \"Set during request\"\n        # self.fk_request.fk_link_names = \"Set during request\"\n        # self.fk_request.robot_state.joint_state = \"Set during request\"\n        # self.fk_request.robot_state.multi_dof_joint_state = \"Ignored\"\n        # self.fk_request.robot_state.attached_collision_objects = \"Ignored\"\n        self.fk_request.robot_state.is_diff = False\n\n    def compute_fk(self, fk_link_names=None, joint_state=None) -> GetPositionFK.Response:\n        \"\"\"\n        Call `compute_fk` service.\n        \"\"\"\n        if fk_link_names == None:\n            self.fk_request.fk_link_names = [self.arm_end_effector]\n        else:\n            self.fk_request.fk_link_names = fk_link_names\n\n        if joint_state == None:\n            self.fk_request.robot_state.joint_state = self.get_joint_state()\n        else:\n            self.fk_request.robot_state.joint_state = joint_state\n\n        self.fk_request.header.stamp = self._clock.now().to_msg()\n\n        self.compute_fk_client.wait_for_service()\n        return self.compute_fk_client.call(self.fk_request)\n\n    # compute_ik\n    def init_compute_ik(self):\n        \"\"\"\n        Initialise `compute_ik` service.\n        \"\"\"\n        # Service client for IK\n        self.compute_ik_client = self.create_client(GetPositionIK,\n                                                    \"compute_ik\")\n        while not self.compute_ik_client.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info(\n                \"Service [compute_ik] not currently available, waiting...\")\n\n        self.ik_request = GetPositionIK.Request()\n        self.ik_request.ik_request.group_name = self.arm_group_name\n        # self.ik_request.ik_request.robot_state.joint_state = \"Set during request\"\n        # self.ik_request.ik_request.robot_state.multi_dof_joint_state = \"Ignored\"\n        # self.ik_request.ik_request.robot_state.attached_collision_objects = \"Ignored\"\n        self.ik_request.ik_request.robot_state.is_diff = False\n        # self.ik_request.ik_request.constraints = \"Set during request OR Ignored\"\n        self.ik_request.ik_request.avoid_collisions = True\n        # self.ik_request.ik_request.ik_link_name = \"Ignored\"\n        self.ik_request.ik_request.pose_stamped.header.frame_id = self.arm_base_link\n        # self.ik_request.ik_request.pose_stamped.header.stamp = \"Set during request\"\n        # self.ik_request.ik_request.pose_stamped.pose = \"Set during request\"\n        # self.ik_request.ik_request.ik_link_names = \"Ignored\"\n        # self.ik_request.ik_request.pose_stamped_vector = \"Ignored\"\n        # self.ik_request.ik_request.timeout.sec = \"Ignored\"\n        # self.ik_request.ik_request.timeout.nanosec = \"Ignored\"\n\n    def compute_ik(self, pose, start_joint_state=None, constrains=None) -> GetPositionIK.Response:\n        \"\"\"\n        Call `compute_ik` service.\n        \"\"\"\n        if start_joint_state == None:\n            self.ik_request.ik_request.robot_state.joint_state = self.get_joint_state()\n        else:\n            self.ik_request.ik_request.robot_state.joint_state = start_joint_state\n\n        if constrains != None:\n            self.ik_request.ik_request.constraints = constrains\n\n        self.ik_request.ik_request.pose_stamped.pose = pose\n\n        self.ik_request.ik_request.pose_stamped.header.stamp = self._clock.now().to_msg()\n\n        self.compute_ik_client.wait_for_service()\n        return self.compute_ik_client.call(self.ik_request)\n\n    # plan_kinematic_path\n    def init_plan_kinematic_path(self):\n        \"\"\"\n        Initialise `plan_kinematic_path` service.\n        \"\"\"\n        # Service client for IK\n        self.plan_kinematic_path_client = self.create_client(GetMotionPlan,\n                                                             \"plan_kinematic_path\")\n        while not self.plan_kinematic_path_client.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info(\n                \"Service [plan_kinematic_path] not currently available, waiting...\")\n\n        self.kinematic_path_request = GetMotionPlan.Request()\n        self.kinematic_path_request.motion_plan_request.workspace_parameters.header.frame_id = \\\n            self.arm_base_link\n        # self.kinematic_path_request.motion_plan_request.workspace_parameters.header.stamp = \\\n        # \"Set during request\"\n        self.kinematic_path_request.motion_plan_request.workspace_parameters.min_corner.x = -0.855\n        self.kinematic_path_request.motion_plan_request.workspace_parameters.min_corner.y = -0.855\n        self.kinematic_path_request.motion_plan_request.workspace_parameters.min_corner.z = -0.36\n        self.kinematic_path_request.motion_plan_request.workspace_parameters.max_corner.x = 0.855\n        self.kinematic_path_request.motion_plan_request.workspace_parameters.max_corner.y = 0.855\n        self.kinematic_path_request.motion_plan_request.workspace_parameters.max_corner.z = 1.19\n        # self.kinematic_path_request.motion_plan_request.start_state = \"Ignored\"\n        self.kinematic_path_request.motion_plan_request.goal_constraints = \\\n            [Constraints()]\n        # self.kinematic_path_request.motion_plan_request.path_constraints = \"Ignored\"\n        # self.kinematic_path_request.motion_plan_request.trajectory_constraints = \"Ignored\"\n        # self.kinematic_path_request.motion_plan_request.reference_trajectories = \"Ignored\"\n        # self.kinematic_path_request.motion_plan_request.planner_id = \"Ignored\"\n        self.kinematic_path_request.motion_plan_request.group_name = self.arm_group_name\n        # self.kinematic_path_request.motion_plan_request.num_planning_attempts = \\\n        # \"Set during request\"\n        # self.kinematic_path_request.motion_plan_request.allowed_planning_time = \\\n        # \"Set during request\"\n        self.kinematic_path_request.motion_plan_request.max_velocity_scaling_factor = 0.0\n        self.kinematic_path_request.motion_plan_request.max_acceleration_scaling_factor = 0.0\n        self.kinematic_path_request.motion_plan_request.cartesian_speed_end_effector_link = \\\n            self.arm_end_effector\n        self.kinematic_path_request.motion_plan_request.max_cartesian_speed = 0.0\n\n    def set_max_velocity(self, scaling_factor):\n        \"\"\"\n        Set maximum velocity of joints as a factor of joint limits.\n        \"\"\"\n        self.kinematic_path_request.motion_plan_request.max_velocity_scaling_factor = scaling_factor\n\n    def set_max_acceleration(self, scaling_factor):\n        \"\"\"\n        Set maximum acceleration of joints as a factor of joint limits.\n        \"\"\"\n        self.kinematic_path_request.motion_plan_request.max_acceleration_scaling_factor = \\\n            scaling_factor\n\n    def set_max_cartesian_speed(self, speed):\n        \"\"\"\n        Set maximum cartesian speed of end effector.\n        \"\"\"\n        self.kinematic_path_request.motion_plan_request.max_cartesian_speed = speed\n\n    def plan_kinematic_path(self,\n                            allowed_planning_time=5.0,\n                            num_planning_attempts=10) -> GetMotionPlan.Response:\n        \"\"\"\n        Call `plan_kinematic_path` service, with goal set using either `set_joint_goal()`,\n        `set_position_goal()`, `set_orientation_goal()` or `set_pose_goal()`.\n        \"\"\"\n\n        self.kinematic_path_request.motion_plan_request.num_planning_attempts = \\\n            num_planning_attempts\n        self.kinematic_path_request.motion_plan_request.allowed_planning_time = \\\n            allowed_planning_time\n\n        self.kinematic_path_request.motion_plan_request.workspace_parameters.header.stamp = \\\n            self._clock.now().to_msg()\n\n        # Stamp message with current time\n        clock_time_now_msg = self._clock.now().to_msg()\n        self.kinematic_path_request.motion_plan_request.workspace_parameters.header.stamp = \\\n            clock_time_now_msg\n        for contraints in self.kinematic_path_request.motion_plan_request.goal_constraints:\n            for position_constraint in contraints.position_constraints:\n                position_constraint.header.stamp = clock_time_now_msg\n            for orientation_constraint in contraints.orientation_constraints:\n                orientation_constraint.header.stamp = clock_time_now_msg\n\n        self.plan_kinematic_path_client.wait_for_service()\n        response = self.plan_kinematic_path_client.call(\n            self.kinematic_path_request)\n\n        self.clear_goal_constraints()\n        self.motion_plan_ = response.motion_plan_response.trajectory\n\n        return response\n\n    def clear_goal_constraints(self):\n        \"\"\"\n        Clear all goal constraints that were previously set.\n        Note that this function is called automatically after each `plan_kinematic_path()`.\n        \"\"\"\n        self.kinematic_path_request.motion_plan_request.goal_constraints = \\\n            [Constraints()]\n\n    def create_new_goal_constraint(self):\n        \"\"\"\n        Create a new set of goal contraints that will be set together with the request. Each\n        subsequent setting of goals with `set_joint_goal()`, `set_pose_goal()` and others will be\n        added under this newly created set of contraints.\n        \"\"\"\n        (self.kinematic_path_request.motion_plan_request.goal_constraints\n         .append(Constraints()))\n\n    def set_joint_goal(self, joint_positions, tolerance=0.001, weight=1.0, joint_names=None):\n        \"\"\"\n        Set goal position in joint space. With `joint_names` specified, `joint_positions` can be\n        defined for specific joints. Otherwise, first `n` joints defined in `init_robot()` will be\n        used, where `n` is the length of `joint_positions`.\n        \"\"\"\n        if joint_names == None:\n            joint_names = self.arm_joints\n\n        for i in range(len(joint_positions)):\n            joint_constraint = JointConstraint()\n            joint_constraint.joint_name = joint_names[i]\n            joint_constraint.position = joint_positions[i]\n            joint_constraint.tolerance_above = tolerance\n            joint_constraint.tolerance_below = tolerance\n            joint_constraint.weight = weight\n\n            (self.kinematic_path_request.motion_plan_request.goal_constraints[-1].\n             joint_constraints.append(joint_constraint))\n\n    def set_position_goal(self, position, tolerance=0.001, weight=1.0, frame=None):\n        \"\"\"\n        Set goal position of `frame` in Cartesian space. Defaults to the end-effector `frame`.\n        \"\"\"\n        if frame == None:\n            frame = self.arm_base_link\n\n        position_constraint = PositionConstraint()\n        position_constraint.header.frame_id = frame\n        position_constraint.link_name = self.arm_end_effector\n        position_constraint.constraint_region.primitive_poses.append(Pose())\n        position_constraint.constraint_region.primitive_poses[0].position.x = position[0]\n        position_constraint.constraint_region.primitive_poses[0].position.y = position[1]\n        position_constraint.constraint_region.primitive_poses[0].position.z = position[2]\n\n        # Goal is defined as a sphere with radius equal to tolerance\n        position_constraint.constraint_region.primitives.append(\n            SolidPrimitive())\n        position_constraint.constraint_region.primitives[0].type = 2\n        position_constraint.constraint_region.primitives[0].dimensions = [\n            tolerance]\n        position_constraint.weight = weight\n\n        (self.kinematic_path_request.motion_plan_request.goal_constraints[-1].position_constraints\n         .append(position_constraint))\n\n    def set_orientation_goal(self, quaternion, tolerance=0.001, weight=1.0, frame=None):\n        \"\"\"\n        Set goal orientation of `frame`. Defaults to the end-effector `frame`.\n        \"\"\"\n        if frame == None:\n            frame = self.arm_end_effector\n\n        orientation_constraint = OrientationConstraint()\n        orientation_constraint.header.frame_id = self.arm_base_link\n        orientation_constraint.link_name = frame\n        orientation_constraint.orientation = quaternion\n        orientation_constraint.absolute_x_axis_tolerance = tolerance\n        orientation_constraint.absolute_y_axis_tolerance = tolerance\n        orientation_constraint.absolute_z_axis_tolerance = tolerance\n        orientation_constraint.weight = weight\n\n        (self.kinematic_path_request.motion_plan_request.goal_constraints[-1]\n         .orientation_constraints.append(orientation_constraint))\n\n    def set_pose_goal(self, position, quaternion,\n                      tolerance_position=0.001, tolerance_orientation=0.001,\n                      weight_position=1.0, weight_orientation=1.0,\n                      frame=None):\n        \"\"\"\n        Set goal pose. This is direct combination of `set_position_goal()` and\n        `set_orientation_goal()`.\n        \"\"\"\n        self.set_position_goal(\n            position, tolerance_position, weight_position, frame)\n        self.set_orientation_goal(\n            quaternion, tolerance_orientation, weight_orientation, frame)\n\n    # plan_cartesian_path\n    def init_plan_cartesian_path(self):\n        \"\"\"\n        Initialise `compute_cartesian_path` service.\n        \"\"\"\n        # TODO\n        pass\n\n    def plan_cartesian_path(self, pose,\n                            start_joint_state=None,\n                            constrains=None) -> GetCartesianPath.Response:\n        \"\"\"\n        Call `compute_cartesian_path` service.\n        \"\"\"\n        # TODO\n        pass\n"}\n{"instruction": "Write a ROS2 Python node named checker.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "import subprocess as sp\nimport threading\nimport os\nimport pickle\nimport time\nimport math\nimport json\nimport statistics\n\nimport numpy as np\n\nimport constants as c\n\nimport rclpy\nfrom rclpy.node import Node\n\nimport ros_utils\n\n# import checkers\nimport oracles.turtlesim\nimport oracles.turtlebot\nimport oracles.px4\nimport oracles.moveit\nimport oracles.rosidl\n\n\nclass StateMonitorNode(Node):\n    subs = dict()\n    msg_queue = list()\n    rosbag_proc = None\n\n    def __init__(self, fuzzer):\n        super().__init__(\"_checker\")\n\n        self.fuzzer = fuzzer\n\n    def retrieve_states(self, exec_cnt):\n        \"\"\"\n        Retrieve recorded states by re-playing a rosbag file\n        \"\"\"\n        print(\"[checker] retrieving states\")\n\n        watchlist_file = self.fuzzer.config.watchlist\n\n        with open(watchlist_file, \"r\") as fp:\n            data = fp.read()\n\n        self.watchlist = json.loads(data)\n\n        for target_topic in self.watchlist:\n            topic_msg_type = self.watchlist[target_topic]\n            pkg_name = \".\".join(topic_msg_type.split(\"/\")[:-1])\n            module_name = topic_msg_type.split(\"/\")[-1]\n\n            msg_type_class = ros_utils.get_msg_class_from_name(\n                pkg_name.split(\".\")[0], module_name\n            )\n\n            self.subs[target_topic] = self.create_subscription(\n                msg_type_class, target_topic, self.msg_callback, 500\n            )\n\n            print(f\"[state monitor] subscribed to {target_topic}\")\n            time.sleep(1)\n\n        # self.play_rosbag(exec_cnt)\n\n    def msg_callback(self, msg):\n        \"\"\"\n        Generic callback for storing re-played messages of any topic\n        \"\"\"\n\n        self.msg_queue.append(msg)\n\n    def play_rosbag(self, exec_cnt):\n        rosbag_cmd = f\"ros2 bag play states-{exec_cnt}.bag\"\n\n        self.rosbag_proc = sp.Popen(\n            rosbag_cmd, shell=True, stdout=sp.PIPE, stderr=sp.PIPE\n        )\n        print(\"[checker] started ros2 bag play:\", rosbag_cmd)\n\n    def check_rosbag(self):\n        # check if ros2 bag play is still running\n        pass\n\n\ndef group_msgs_by_topic(states):\n    \"\"\"\n    input: queue of messages of various topics\n    output: dictionary mapping each topic to corresponding messages\n    \"\"\"\n\n    topic_to_msg_dict = {}\n    for msg in states:\n        msg_type_name = f\"{msg.__class__.__module__}.{msg.__class__.__name__}\"\n        try:\n            topic_to_msg_dict[msg_type_name].append(msg)\n        except KeyError:\n            topic_to_msg_dict[msg_type_name] = [msg]\n\n    return topic_to_msg_dict\n\n\ndef retrieve_states():\n    state_msgs = pickle.load(open(\"states.pkl\", \"rb\"))\n    print(\"recorded:\", len(state_msgs))\n\n    try:\n        os.remove(\"states.pkl\")\n    except:\n        print(\"[-] cannot remove states file\")\n    # print(\"[monitor] retrieved states\")\n\n    return state_msgs\n\n\ndef run_checks(config, msg_list, state_dict, feedback_list=[]):\n    \"\"\"invoke checks of the oracles defined for each target package\n\n    Parameters\n    ----------\n    config : RuntimeConfig object\n    msg_list : list of messages published\n    state_dict : dict of messages captured by pre-defined state topics\n    feedback_list : list of Feedback objects\n    \"\"\"\n\n    errs = []\n    if config.rospkg == \"turtlesim\":\n        try:\n            pose_list = state_dict[\"/turtle1/pose\"]\n        except KeyError:\n            print(\"[checker] no Pose available\")\n            return errs\n\n        errs = oracles.turtlesim.check(config, msg_list, pose_list, feedback_list)\n\n    elif config.tb3_sitl or config.tb3_hitl:\n        if (\n            \"/imu\" not in state_dict\n            and \"/odom\" not in state_dict\n            and \"/scan_list\" not in state_dict\n        ):\n            print(\"[checker] no state available\")\n            return errs\n\n        errs = oracles.turtlebot.check(config, msg_list, state_dict, feedback_list)\n\n    elif config.px4_sitl:\n        if (\n            \"/ActuatorArmed_PubSubTopic\" not in state_dict\n            and \"/ActuatorOutputs_PubSubTopic\" not in state_dict\n            and \"/BatteryStatus_PubSubTopic\" not in state_dict\n            and \"/SensorAccel_PubSubTopic\" not in state_dict\n            and \"/SensorBaro_PubSubTopic\" not in state_dict\n            and \"/SensorGps_PubSubTopic\" not in state_dict\n            and \"/SensorGyro_PubSubTopic\" not in state_dict\n            and \"/SensorsStatusImu_PubSubTopic\" not in state_dict\n            and \"/SensorCombined_PubSubTopic\" not in state_dict\n            and \"/VehicleOdometry_PubSubTopic\" not in state_dict\n            and \"/VehicleImu_PubSubTopic\" not in state_dict\n            and \"/VehicleGpsPosition_PubSubTopic\" not in state_dict\n            and \"/VehicleLocalPosition_PubSubTopic\" not in state_dict\n            and \"/VehicleGlobalPosition_PubSubTopic\" not in state_dict\n            and \"/VehicleAttitude_PubSubTopic\" not in state_dict\n            and \"/VehicleAcceleration_PubSubTopic\" not in state_dict\n            and \"/VehicleAngularAcceleration_PubSubTopic\" not in state_dict\n            and \"/VehicleAngularVelocity_PubSubTopic\" not in state_dict\n        ):\n            print(\"[checker] no state available\")\n            return errs\n\n        errs = oracles.px4.check(config, msg_list, state_dict, feedback_list)\n\n    elif config.test_moveit:\n        if (\n            \"/joint_states\" not in state_dict\n            and \"/panda_arm_controller/state\" not in state_dict\n            and \"/move_action/_action/status\" not in state_dict\n            and \"/motion_plan_request\" not in state_dict\n        ):\n            print(\"[checker] no state available\")\n            return errs\n\n        errs = oracles.moveit.check(config, msg_list, state_dict, feedback_list)\n\n    elif config.test_rosidl:\n        if len(msg_list) != 1:\n            print(\"[-] msg_list contains more than one message\")\n            exit(1)\n\n        errs = oracles.rosidl.check(config, msg_list, state_dict, feedback_list)\n\n    elif config.test_cli:\n        try:\n            with open(\"out-0\", \"r\") as f:\n                out0 = \"\\n\".join(f.readlines())\n        except:\n            print(\"[checker] out-0 does not exist\")\n            exit(1)\n\n        try:\n            with open(\"out-1\", \"r\") as f:\n                out1 = \"\\n\".join(f.readlines())\n        except:\n            print(\"[checker] out-1 does not exist\")\n            exit(1)\n\n        if out0 != out1:\n            errs = [f\"CLI outputs do not match: {out0} vs {out1}\"]\n\n    # Print result\n    if len(errs) > 0:\n        if len(errs) > 10:\n            print(f\"{c.RED}ERROR DETECTED: {len(errs)}\")\n            for err in list(set(errs))[:10]:\n                print(\"-\", err)\n            print(\"- ...\")\n            print(c.END)\n        else:\n            print(f\"{c.RED}ERROR DETECTED: {len(errs)}\")\n            for err in list(set(errs)):\n                print(\"-\", err)\n            print(c.END)\n\n    return errs\n\n\ndef run_rpt_checks(config, state_dict_list):\n    \"\"\"check if repeated executions over the same messages result in the identical states\"\"\"\n\n    print(\n        f\"[checker] cross-checking states from {len(state_dict_list)} executions\"\n    )\n\n    last_states = dict()\n\n    for state_dict in state_dict_list:\n        for topic in state_dict:\n            last_state = state_dict[topic][-1]\n            if topic not in last_states:\n                last_states[topic] = [last_state]\n            else:\n                last_states[topic].append(last_state)\n\n    errs = []\n\n    for topic in last_states:\n        last_msgs = last_states[topic]\n        num_last_states = len(last_msgs)\n        if num_last_states != len(state_dict_list):\n            errs.append(f\"number of topics do not match: {topic}\")\n\n        # TODO: cross-check messages in last_msgs\n\n    return errs\n\n\nclass APIChecker:\n    def __init__(self, feature, targets, job):\n        self.tracer = \"ltrace\"\n        self.feature = feature\n        self.targets = targets\n        self.job = job\n\n    def config_trace(self):\n        pass\n\n    def get_timestamp(self, filename=\"out\"):\n        if not os.path.isfile(filename):\n            print(f\"[tracer] Cannot find trace file {filename}\")\n            return -1\n\n        with open(filename, \"r\") as fp:\n            out_raw = fp.readlines()\n\n        t0 = -1\n        t1 = 2147483647.0\n        for line in out_raw:\n            if \"time1\" in line:\n                t0 = line.strip().split(\" \")[-1]\n                if \".\" not in t0:\n                    t0 = (\n                        int(t0) / 1000000.0\n                    )  # c++/rust prints us w/o decimal point\n                else:\n                    t0 = float(t0)\n            elif \"time2\" in line:\n                t1 = line.strip().split(\" \")[-1]\n                if \".\" not in t1:\n                    t1 = (\n                        int(t1) / 1000000.0\n                    )  # c++/rust prints us w/o decimal point\n                else:\n                    t1 = float(t1)\n                break\n\n        self.t0 = t0\n        self.t1 = t1\n\n    def parse_trace(self, filename=\"trace\"):\n        if not os.path.isfile(filename):\n            print(f\"[tracer] Cannot find trace file {filename}\")\n            return -1\n\n        func_dict = dict()\n\n        with open(filename, \"r\") as fp:\n            trace_raw = fp.readlines()\n\n        for line in trace_raw:\n            line = line.strip()\n            timestamp = float(line.split(\" \")[0])\n\n            if timestamp < self.t0 or timestamp > self.t1:\n                continue\n\n            if \"<unfinished ...>\" in line:\n                func_name = line.split(\" \")[1].split(\"@\")[0]\n                retval = None\n                if func_name in func_dict:\n                    func_dict[func_name].append([timestamp, retval])\n                else:\n                    func_dict[func_name] = [[timestamp, retval]]\n\n            elif \"<...\" in line and \"resumed>\" in line:\n                func_name = line.split(\" \")[2]\n                retval = line.split(\"= \")[-1]\n\n                if func_name not in func_dict:\n                    print(f\"[tracer] fatal error: {func_name} not seen yet\")\n                    return -1\n\n                # update retval\n                func_dict[func_name][-1][1] = retval\n\n            elif \".so\" in line:\n                func_name = line.split(\" \")[1].split(\"@\")[0]\n                retval = line.split(\"= \")[-1]\n\n                if func_name in func_dict:\n                    func_dict[func_name].append([timestamp, retval])\n                else:\n                    func_dict[func_name] = [[timestamp, retval]]\n\n        # print(func_dict)\n        return func_dict\n\n    def check_deviant(self):\n        print(\"[API checker] Checking deviant API behavior\")\n        target_trace_map = dict()\n\n        for i, target in enumerate(self.targets):\n            outfile = f\"out-{i}\"\n            tracefile = f\"trace-{i}\"\n            ret = self.get_timestamp(outfile)\n            func_dict = self.parse_trace(tracefile)\n            target_trace_map[target] = func_dict\n\n        # 1. check if each lang calls the same API\n        functions_list = list()\n        target_list = target_trace_map.keys()\n        for target in target_list:\n            func_dict = target_trace_map[target]\n            functions = list(func_dict.keys())\n            functions.sort()\n            functions_list.append(functions)\n\n        if not functions_list.count(functions_list[0]) == len(functions_list):\n            err = \"RCL API discrepancy - called APIs do not match\"\n            for f in functions_list:\n                print(f)\n            return err\n\n        # 2. check retval\n        function_retvals_map = dict()\n        for target in target_list:\n            func_dict = target_trace_map[target]\n            functions = list(func_dict.keys())\n\n            for function in functions:\n                ret_list = [x[1] for x in func_dict[function]]\n                if function in function_retvals_map:\n                    function_retvals_map[function].append(ret_list)\n                else:\n                    function_retvals_map[function] = [ret_list]\n\n        for function in function_retvals_map:\n            retvals_list = function_retvals_map[function]\n            if not retvals_list.count(retvals_list[0]) == len(retvals_list):\n                err = \"RCL API discrepancy - return values do not match\"\n                print(function_retvals_map)\n                return err\n\n\nclass CollisionChecker:\n    topic_proc_map = dict()\n    # topic_stdout_map = dict()\n    collision_events = dict()\n    topic_monitor_map = dict()\n\n    def __init__(self):\n        pass\n\n    def listen(self, topics):\n        print(\"[collision checker] start listening\")\n        self.collision_events = dict()\n        for topic in topics:\n            # print(\"[collision checker] start listening to \", topic)\n\n            cmd = [\"gz\", \"topic\", \"-u\", \"-e\", topic]\n            proc = sp.Popen(cmd, shell=False, stdout=sp.PIPE, stderr=sp.PIPE)\n\n            t = threading.Thread(\n                target=self.monitor,\n                args=(\n                    proc,\n                    topic,\n                ),\n            )\n            t.start()\n\n            self.topic_proc_map[topic] = proc\n            self.topic_monitor_map[topic] = t\n\n    def stop(self):\n        print(\"[collision checker] stop listening\")\n        for topic in self.topic_proc_map:\n            # print(\"[collision checker] stop listening to\", topic)\n\n            proc = self.topic_proc_map[topic]\n            proc.kill()\n\n            thread = self.topic_monitor_map[topic]\n            thread.join()\n            assert thread.is_alive() is False\n\n            # self.topic_stdout_map[topic] = outs\n\n    def monitor(self, proc, topic):\n        for line in iter(proc.stdout.readline, b\"\"):\n            if b\"contact\" in line:\n                line_str = line.decode(\"utf-8\")\n                # print(\"collision: {0}\".format(line_str), end=\"\")\n\n                try:\n                    self.collision_events[topic].append(line_str)\n                except KeyError:\n                    self.collision_events[topic] = [line_str]\n\n    def found_collision(self):\n\n        if len(self.collision_events) > 0:\n            return True\n\n        # for topic in self.topic_stdout_map:\n        # outs = self.topic_stdout_map[topic]\n        # if b'contact' in outs:\n        # self.collision_topic.append(topic)\n        # collision = True\n\n        # return collision\n\n    def print_collision_topics(self) -> None:\n\n        print(list(self.collision_events.keys()))\n"}\n{"instruction": "Write a ROS2 Python node named demo.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "#!/usr/bin/env python3\nfrom reach import load, runReachStudy\nfrom reach_ros import init_ros, set_parameter, parse_yaml, set_logger_level, update_search_libraries_env\n\nfrom ament_index_python.packages import get_package_share_directory\nimport os\nfrom rclpy.parameter import Parameter\nfrom rclpy.logging import LoggingSeverity\nimport sys\nimport xacro\nimport yaml\n\n\ndef main():\n    # initialize ROS with any parameters provided as arguments\n    init_ros(sys.argv)\n\n    # Set logger level to reduce MoveIt message spam\n    moveit_loggers = [\"moveit_ros\",\n                      \"moveit_kinematics_base\",\n                      \"moveit_rdf_loader\",\n                      \"moveit_robot_model\"]\n    for logger_name in moveit_loggers:\n        try:\n            set_logger_level(logger_name, LoggingSeverity.WARN)\n        except:\n            pass\n\n    # Manually load the parameters necessary for running MoveIt.\n    reach_ros_dir = get_package_share_directory('reach_ros')\n    model_dir = os.path.join(reach_ros_dir, 'demo', 'model')\n\n    # Generate the URDF string from the xacro file\n    urdf = xacro.process(os.path.join(model_dir, 'reach_study.xacro'))\n\n    # Load the SRDF\n    with open(os.path.join(model_dir, 'reach_study.srdf'), 'r') as f:\n        srdf = f.read()\n\n    moveit_parameters = [\n        *parse_yaml(os.path.join(model_dir, 'kinematics.yaml'), 'robot_description_kinematics.'),\n        *parse_yaml(os.path.join(model_dir, 'joint_limits.yaml'), 'robot_description_joint_limits.'),\n        Parameter(name=\"robot_description\", value=urdf),\n        Parameter(name=\"robot_description_semantic\", value=srdf),\n    ]\n\n    for parameter in moveit_parameters:\n        # We don't need to declare the parameters as the node allows undeclared parameters\n        set_parameter(parameter.name, parameter.value)\n\n    with open(os.path.join(reach_ros_dir, 'demo', 'config', 'reach_study.yaml'), 'r') as f:\n        config = yaml.safe_load(f)\n\n    # Update the search libraries environment variable to include the plugin library provided by this package\n    update_search_libraries_env()\n\n    # Disable the optimization steps to make this demo faster and highlight the performance difference\n    config['optimization']['max_steps'] = 0\n\n    print(\"Starting first study with default kinematic parameters\")\n    save_dir = \"/tmp\"\n    study_name = \"study1\"\n    runReachStudy(config, study_name, save_dir, False)\n\n    # Loading the study results\n    results_1 = load(os.path.join(save_dir, study_name, 'reach.db.xml')).calculateResults()\n\n    # Decrease the IK solver time and see if we still find equally good solutions\n    set_parameter(\n        \"robot_description_kinematics.manipulator.kinematics_solver_timeout\", 0.00005)\n\n    print(\"Starting second study with decreased solver resolution.\")\n    study_name = 'study2'\n    runReachStudy(config, study_name, save_dir, False)\n\n    # Loading the study results\n    results_2 = load(os.path.join(save_dir, study_name, 'reach.db.xml')).calculateResults()\n\n    print('Both REACH studies finished')\n    print(f'\\tOriginal parameters: Score {results_1.total_pose_score:.2f}, Reached {results_1.reach_percentage:.2f}%')\n    print(f'\\tModified parameters: Score {results_2.total_pose_score:.2f}, Reached {results_2.reach_percentage:.2f}%')\n\n\nif __name__ == '__main__':\n    main()\n"}\n{"instruction": "Write a ROS2 Python node named start_blocking.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "#!/usr/bin/env python3\n\n# Copyright 2023 Picknik Inc.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#\n#    * Redistributions of source code must retain the above copyright\n#      notice, this list of conditions and the following disclaimer.\n#\n#    * Redistributions in binary form must reproduce the above copyright\n#      notice, this list of conditions and the following disclaimer in the\n#      documentation and/or other materials provided with the distribution.\n#\n#    * Neither the name of the Picknik Inc. nor the names of its\n#      contributors may be used to endorse or promote products derived from\n#      this software without specific prior written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n# POSSIBILITY OF SUCH DAMAGE.\n\n# Start an Objective and block until the Objective has completed execution.\n\nimport argparse\nimport rclpy\n\nfrom moveit_studio_py.objective_manager import ObjectiveManager\n\n\ndef main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        \"objective_name\", type=str, help=\"Name of the Objective to start.\"\n    )\n    args = parser.parse_args()\n\n    rclpy.init()\n\n    objective_manager = ObjectiveManager()\n\n    print(f\"Starting {args.objective_name}.\")\n    success, error_message = objective_manager.start_objective(\n        args.objective_name, blocking=True\n    )\n    if success:\n        print(\"Objective executed successfully!\")\n    else:\n        print(error_message)\n\n    rclpy.shutdown()\n\n\nif __name__ == \"__main__\":\n    main()\n"}\n{"instruction": "Write a ROS2 Python node named moveit2_agent.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "# Copyright (C) 2025 Advanced Micro Devices, Inc.\n# Developed by Robotec.ai sp. z o.o.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport argparse\nimport logging\nfrom pathlib import Path\n\nimport rclpy\nfrom ament_index_python import get_package_share_directory\nfrom control_msgs.action import GripperCommand\nfrom geometry_msgs.msg import Point, Pose, PoseStamped, Quaternion\nfrom langchain_core.language_models.chat_models import BaseChatModel\n\n# generic ros libraries\nfrom langchain_core.language_models.fake_chat_models import FakeChatModel\nfrom launch_param_builder import load_yaml\nfrom moveit.core.kinematic_constraints import construct_joint_constraint\nfrom moveit.core.planning_interface import MotionPlanResponse\nfrom moveit.core.robot_state import RobotState\nfrom moveit.planning import MoveItPy\nfrom moveit.utils import create_params_file_from_dict\nfrom moveit_configs_utils import MoveItConfigsBuilder\nfrom rai.agents import wait_for_shutdown\nfrom rai.agents.base import BaseAgent\nfrom rai.communication.ros2 import (\n    ROS2Connector,\n    ROS2Context,\n)\nfrom rai_interfaces.srv import MoveArm, SetArmJoints\nfrom rclpy.action.client import ActionClient\nfrom rclpy.node import Node\nfrom tf2_geometry_msgs import do_transform_pose\n\nfrom rai_app.control.moveit_utils import decode_error_code\nfrom rai_app.initialization.llms import get_llm_model\n\nGRIPPER_HEIGHT = 0.07\n\n\nclass MoveitToolkit:\n    quaternion = Quaternion(x=0.9238795325112867, y=-0.3826834323650898, z=0.0, w=0.0)\n\n    def __init__(self, namespace: str, ros_package_name) -> None:\n        self.namespace = namespace\n        self.ros_package_name = ros_package_name\n        self.pose_link = f\"{self.namespace}egoarm_wrist_3_link\"\n        self.manipulator_frame = f\"{self.namespace}egoarm_base_link\"\n        self.moveitpy = self.setup_moveitpy()\n\n        self.planning_component = self.moveitpy.get_planning_component(\"base\")\n\n    def setup_moveitpy(self) -> MoveItPy:\n        package_config_dir = (\n            Path(get_package_share_directory(self.ros_package_name)) / \"config\"\n        )\n        joint_limits_yaml_path = package_config_dir / \"joint_limits.yaml\"\n        moveit_controllers_yaml_path = package_config_dir / \"moveit_controllers.yaml\"\n        moveit_cpp_conf = package_config_dir / \"moveit_cpp.yaml\"\n        trajectory_execution_conf = package_config_dir / \"moveit_controllers.yaml\"\n\n        for path in [\n            joint_limits_yaml_path,\n            moveit_controllers_yaml_path,\n            moveit_cpp_conf,\n            trajectory_execution_conf,\n        ]:\n            if not path.exists():\n                raise FileNotFoundError(f\"File {path} doesn't exist\")\n\n        moveit_config = (\n            MoveItConfigsBuilder(\"rbkairos\", package_name=self.ros_package_name)\n            .moveit_cpp(file_path=str(moveit_cpp_conf))\n            .robot_description(\n                mappings={\n                    \"namespace\": f\"{self.namespace}ego\",\n                    \"prefix\": f\"{self.namespace}ego\",\n                    \"ur_type\": \"ur10\",\n                    \"gazebo_classic\": \"false\",\n                    \"gazebo_ignition\": \"false\",\n                }\n            )\n            .trajectory_execution(\n                file_path=str(trajectory_execution_conf),\n                moveit_manage_controllers=False,\n            )\n            .robot_description_semantic(\n                mappings={\n                    \"namespace\": f\"{self.namespace}ego\",\n                    \"prefix\": f\"{self.namespace}ego\",\n                }\n            )\n            .to_moveit_configs()\n        )\n\n        joint_limits_params = self._get_joint_limit_params(joint_limits_yaml_path)\n        moveit_controllers_params = self._get_moveit_controller_params(\n            moveit_controllers_yaml_path\n        )\n\n        moveit_config.joint_limits = {\"robot_description_planning\": joint_limits_params}\n        moveit_config = moveit_config.to_dict()\n        moveit_config.update({\"use_sim_time\": True})\n\n        file = create_params_file_from_dict(\n            moveit_config | moveit_controllers_params, \"/**\"\n        )\n\n        moveitpy = MoveItPy(\n            node_name=\"moveit_py\",\n            launch_params_filepaths=[file],\n            remappings={\"/joint_states\": f\"/{self.namespace}joint_states\"},\n        )\n\n        return moveitpy\n\n    def plan_and_execute(self, pose: Pose):\n        pose_stamped = PoseStamped()\n        pose_stamped.header.frame_id = self.manipulator_frame\n        pose_stamped.pose = pose\n\n        self.planning_component.set_start_state_to_current_state()\n        self.planning_component.set_goal_state(\n            pose_stamped_msg=pose_stamped, pose_link=self.pose_link\n        )\n\n        plan: MotionPlanResponse = self.planning_component.plan()\n        if plan:\n            self.moveitpy.execute(plan.trajectory, controllers=[])\n        else:\n            error_code = plan.error_code\n            error_msg = decode_error_code(error_code)\n            raise RuntimeError(f\"Failed to plan the trajectory: {error_msg}\")\n\n    def set_joint_values(self, joint_values):\n        robot_model = self.moveitpy.get_robot_model()\n        robot_state = RobotState(robot_model)\n        robot_state.joint_positions = joint_values\n        joint_constraint = construct_joint_constraint(\n            robot_state=robot_state,\n            joint_model_group=robot_model.get_joint_model_group(\n                self.planning_component.planning_group_name\n            ),\n        )\n\n        self.planning_component.set_start_state_to_current_state()\n        self.planning_component.set_goal_state(\n            motion_plan_constraints=[joint_constraint]\n        )\n\n        plan = self.planning_component.plan()\n\n        if plan:\n            self.moveitpy.execute(plan.trajectory, controllers=[])\n        else:\n            error_code = plan.error_code\n            error_msg = decode_error_code(error_code)\n            raise RuntimeError(f\"Failed to plan the trajectory: {error_msg}\")\n\n    def _get_joint_limit_params(self, joint_limits_yaml_path: Path) -> dict:\n        joint_limits_params = load_yaml(joint_limits_yaml_path)\n\n        for joint in list(joint_limits_params[\"joint_limits\"]):\n            joint_limits_params[\"joint_limits\"][f\"{self.namespace}{joint}\"] = (\n                joint_limits_params[\"joint_limits\"].pop(joint)\n            )\n        return joint_limits_params\n\n    def _get_moveit_controller_params(self, moveit_controllers_yaml_path: Path) -> dict:\n        moveit_controllers_params = load_yaml(Path(moveit_controllers_yaml_path))\n        controller_names = list(\n            moveit_controllers_params[\"moveit_simple_controller_manager\"][\n                \"controller_names\"\n            ]\n        )\n        for controller in controller_names:\n            params = moveit_controllers_params[\"moveit_simple_controller_manager\"].pop(\n                controller\n            )\n            params[\"joints\"] = [\n                f\"{self.namespace}{joint}\" for joint in params[\"joints\"]\n            ]\n            moveit_controllers_params[\"moveit_simple_controller_manager\"][\n                f\"{self.namespace}{controller}\"\n            ] = params\n        moveit_controllers_params[\"moveit_simple_controller_manager\"][\n            \"controller_names\"\n        ] = [f\"{self.namespace}{controller}\" for controller in controller_names]\n        return moveit_controllers_params\n\n\nclass GripperController(Node):\n    def __init__(self, namespace: str) -> None:\n        super().__init__(\"gripper_controller\")\n        self.gripper_action_client = ActionClient(\n            self, GripperCommand, f\"{namespace}gripper_server\"\n        )\n        pass\n\n    def gripper_command(self, position):\n        \"\"\"Send a command to open or close the gripper.\n\n        Parameters\n        ----------\n        position : float\n            Target gripper position where ``0.0`` closes the gripper and ``1.0``\n            opens it.\n\n        Raises\n        ------\n        RuntimeError\n            If the action server fails to execute the goal.\n        \"\"\"\n        goal = GripperCommand.Goal()\n        goal.command.position = position\n        goal.command.max_effort = 0.0\n        future = self.gripper_action_client.send_goal_async(goal)\n\n        # TODO(boczekbartek): fix this\n        rclpy.spin_until_future_complete(self, future)\n        if future.result() is None:\n            raise RuntimeError(\"Gripper command failed\")\n\n    def close_gripper(self):\n        self.gripper_command(0.0)\n\n    def open_gripper(self):\n        self.gripper_command(1.0)\n\n\nclass ArmController:\n    ARM_STAGING_POSE_DISTANCE = 0.1\n    BASE_JOINT_VALUES = {\n        \"egoarm_wrist_1_joint\": -1.5223139524459839,\n        \"egoarm_wrist_2_joint\": -1.5707021951675415,\n        \"egoarm_wrist_3_joint\": -0.841789960861206,\n        \"egoarm_shoulder_lift_joint\": -2.226045608520508,\n        \"egoarm_elbow_joint\": 2.1977827548980713,\n        \"egoarm_shoulder_pan_joint\": 0.018245616927742958,\n    }\n\n    LOW_BASE_JOINT_VALUES = {\n        \"egoarm_wrist_1_joint\": -2.150108575820923,\n        \"egoarm_wrist_2_joint\": -1.5708777904510498,\n        \"egoarm_wrist_3_joint\": -0.84187912940979,\n        \"egoarm_shoulder_lift_joint\": -0.06665489822626114,\n        \"egoarm_elbow_joint\": 0.6900210380554199,\n        \"egoarm_shoulder_pan_joint\": 0.018179576843976974,\n    }\n\n    def __init__(\n        self, connector: ROS2Connector, namespace: str, ros_package_name: str\n    ) -> None:\n        self.connector = connector\n        self.namespace = namespace\n        self.ros_package_name = ros_package_name\n\n        self.logger = logging.getLogger(__name__)\n\n        self.moveit_toolkit = MoveitToolkit(namespace, ros_package_name)\n\n    def move_arm(self, pose: Pose, frame: str | None = None, retries: int = 3):\n        if frame is None:\n            frame = f\"{self.namespace}egoarm_base_link\"\n        ros2_pose = do_transform_pose(\n            pose,\n            self.connector.get_transform(\n                f\"{self.namespace}egoarm_base_link\", frame, timeout_sec=60\n            ),\n        )\n\n        self.logger.info(\n            f\"Moving arm to {ros2_pose.position.x}, {ros2_pose.position.y}, {ros2_pose.position.z}\"\n        )\n        for _ in range(retries):\n            try:\n                self.moveit_toolkit.plan_and_execute(ros2_pose)\n                return True\n            except RuntimeError as e:\n                self.logger.error(e)\n                continue\n        raise RuntimeError(\"Failed to move arm\")\n\n    def move_arm_to_base_pose(self):\n        self.moveit_toolkit.set_joint_values(self.BASE_JOINT_VALUES)\n\n    def move_arm_to_low_base_pose(self):\n        self.moveit_toolkit.set_joint_values(self.LOW_BASE_JOINT_VALUES)\n\n    def move_arm_to_staging_pose(self, target_pose: Pose, object_height: float):\n        self.move_arm(\n            Pose(\n                position=Point(\n                    x=target_pose.position.x,\n                    y=target_pose.position.y,\n                    z=target_pose.position.z\n                    + object_height\n                    + self.ARM_STAGING_POSE_DISTANCE,\n                )\n            ),\n            \"odom\",\n        )\n\n    def move_arm_to_gripping_pose(self, target_pose: Pose, object_height: float):\n        self.move_arm(\n            Pose(\n                position=Point(\n                    x=target_pose.position.x,\n                    y=target_pose.position.y,\n                    z=target_pose.position.z + object_height,\n                )\n            ),\n            \"odom\",\n        )\n\n\nclass ManipulatorController:\n    def __init__(\n        self,\n        connector: ROS2Connector,\n        namespace: str = \"\",\n        ros_package_name: str = \"robotec_kairos_ur10\",\n    ) -> None:\n        self.ros_package_name = ros_package_name\n        self.connector = connector\n        self.node = self.connector.node\n        self.namespace = namespace\n\n        self.logger = self.node.get_logger()\n\n        self.gripper_controller = GripperController(self.namespace)\n        self.arm_controller = ArmController(\n            self.connector, self.namespace, self.ros_package_name\n        )\n\n    def open_gripper(self):\n        self.gripper_controller.open_gripper()\n\n    def close_gripper(self):\n        self.gripper_controller.close_gripper()\n\n    def move_arm(self, pose, frame: str | None = None):\n        self.arm_controller.move_arm(pose, frame)\n\n    def move_arm_to_base_pose(self):\n        self.arm_controller.move_arm_to_base_pose()\n\n    def move_arm_to_low_base_pose(self):\n        self.arm_controller.move_arm_to_low_base_pose()\n\n    def move_arm_to_staging_pose(self, target_pose: Pose, object_height: float):\n        self.arm_controller.move_arm_to_staging_pose(target_pose, object_height)\n\n    def move_arm_to_gripping_pose(self, target_pose: Pose, object_height: float):\n        self.arm_controller.move_arm_to_gripping_pose(target_pose, object_height)\n\n\ndef logging_wrapper(func):\n    def wrapper(self, *args, **kwargs):\n        RED = \"\\033[91m\"\n        GREEN = \"\\033[92m\"\n        RESET = \"\\033[0m\"\n        self.connector.node.get_logger().info(\n            f\"{GREEN}Calling {func.__name__} with args: {args} and kwargs: {kwargs}{RESET}\"\n        )\n        result = func(self, *args, **kwargs)\n        color = GREEN if result.success else RED\n        msg = f\"{color}Result of {func.__name__}: success={result.success}{RESET}\"\n        msg += f\" {result.report}\" if not result.success else \"\"\n        self.connector.node.get_logger().info(msg)\n        return result\n\n    return wrapper\n\n\nclass MoveIt2Agent(BaseAgent):\n    SYSTEM_PROMPT: str = \"\"\"\n    You are an agent responsible for moving the robotic arm to a specified position and gripper state.\n    You work alongside other agents and specialists to accomplish the task.\n    You work within the MoveIt2, ROS 2 framework.\n    When asked to debug, check the logs and provide short and actionable summary for the other agents.\n    \"\"\"\n\n    def __init__(self, llm: BaseChatModel | None = None):\n        super().__init__()\n        self.connector = ROS2Connector(executor_type=\"single_threaded\")\n        self.manipulator_controller = ManipulatorController(\n            connector=self.connector,\n            namespace=\"\",\n            ros_package_name=\"robotec_kairos_ur10\",\n        )\n\n        if llm is None:\n            self.llm = FakeChatModel()\n        else:\n            self.llm = llm\n\n        self.connector.create_service(\n            service_name=\"/rai/moveit2/move_arm\",\n            service_type=\"rai_interfaces/srv/MoveArm\",\n            on_request=self.move_arm,\n        )\n        self.connector.create_service(\n            service_name=\"/rai/moveit2/set_arm_joints\",\n            service_type=\"rai_interfaces/srv/SetArmJoints\",\n            on_request=self.set_arm_joints,\n        )\n\n        self.logger.info(\"MoveIt2Agent initialized\")\n\n    def formulate_prompt(self, prompt: str, logs: str) -> str:\n        return self.SYSTEM_PROMPT + \"\\n\\n Task:\\n\" + prompt + \"\\n\\n Logs:\\n\" + logs\n\n    @logging_wrapper\n    def set_arm_joints(\n        self, request: SetArmJoints.Request, response: SetArmJoints.Response\n    ):\n        self.logger.info(\n            f\"Setting arm joints: {request.joints_names} to {request.joints}\"\n        )\n        try:\n            joints = {k: v for k, v in zip(request.joints_names, request.joints)}\n            self.manipulator_controller.arm_controller.moveit_toolkit.set_joint_values(\n                joints\n            )\n            response.success = True\n            response.report = \"Moved arm to position.\"\n            return response\n        except Exception as e:\n            self.logger.error(f\"Failed to set arm joints: {e}\")\n            response.success = False\n            response.report = str(e)\n        return response\n\n    def _is_neutral_pose(self, pose: PoseStamped) -> bool:\n        neutral_pose = PoseStamped().pose\n        test_pose = pose.pose\n        return (\n            test_pose.position.x == neutral_pose.position.x\n            and test_pose.position.y == neutral_pose.position.y\n            and test_pose.position.z == neutral_pose.position.z\n            and test_pose.orientation.x == neutral_pose.orientation.x\n            and test_pose.orientation.y == neutral_pose.orientation.y\n            and test_pose.orientation.z == neutral_pose.orientation.z\n            and test_pose.orientation.w == neutral_pose.orientation.w\n        )\n\n    @logging_wrapper\n    def move_arm(self, request: MoveArm.Request, response: MoveArm.Response):\n        if not self._is_neutral_pose(\n            request.target_pose\n        ):  # empty pose, gripper state only\n            try:\n                self.manipulator_controller.move_arm(\n                    pose=request.target_pose.pose,\n                    frame=request.target_pose.header.frame_id,\n                )\n            except Exception as e:\n                response.success = False\n                llm_response = self.llm.invoke(\n                    \"The arm failed to move to the position. Check the logs and provide a short summary.\"\n                    + str(e)\n                )\n                response.report = llm_response.content\n                return response\n\n        if request.gripper_state == 0:\n            response.success = True\n            response.report = \"Moved arm to position.\"\n        elif request.gripper_state == 1:\n            try:\n                self.manipulator_controller.open_gripper()\n                response.success = True\n                response.report = \"Moved arm to position and opened gripper.\"\n            except Exception as e:\n                self.logger.error(f\"Failed to open gripper: {e}\")\n                response.success = False\n                llm_response = self.llm.invoke(\n                    self.formulate_prompt(\"The arm failed to open the gripper.\", str(e))\n                )\n                response.report = llm_response.content\n                return response\n        elif request.gripper_state == 2:\n            try:\n                self.manipulator_controller.close_gripper()\n                response.success = True\n                response.report = \"Moved arm to position and closed gripper.\"\n            except Exception as e:\n                self.logger.error(f\"Failed to close gripper: {e}\")\n                response.success = False\n                llm_response = self.llm.invoke(\n                    self.formulate_prompt(\n                        \"The arm failed to close the gripper.\", str(e)\n                    )\n                )\n                response.report = llm_response.content\n                return response\n        else:\n            response.success = False\n            response.report = \"Invalid gripper state.\"\n        return response\n\n    def run(self):\n        pass\n\n    def stop(self):\n        self.connector.shutdown()\n\n\n@ROS2Context()\ndef main():\n    parser = argparse.ArgumentParser(description=\"Run MoveIt2 agent\")\n    parser.add_argument(\"--test-mode\", action=\"store_true\", help=\"Run in test mode\")\n    args = parser.parse_args()\n    if args.test_mode:\n        llm = FakeChatModel()\n    else:\n        llm = get_llm_model(config_name=\"general\")\n    agent = MoveIt2Agent(llm=llm)\n    agent.run()\n\n    wait_for_shutdown([agent])\n\n\nif __name__ == \"__main__\":\n    main()\n"}\n{"instruction": "Write a ROS2 Python node named gpp_stacker.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "import rclpy\nfrom rclpy.node import Node\nfrom rclpy.action import ActionServer\nfrom rclpy.action import ActionClient\nfrom rclpy.executors import MultiThreadedExecutor\n\nfrom webots_spot_msgs.action import Stack\n\nfrom sensor_msgs.msg import JointState\nfrom tf2_ros import TransformException\nfrom tf2_ros.buffer import Buffer\nfrom tf2_ros.transform_listener import TransformListener\nfrom moveit_msgs.srv import GetPositionIK\n\nfrom trajectory_msgs.msg import JointTrajectoryPoint\nfrom control_msgs.action import FollowJointTrajectory\nfrom moveit_msgs.msg import MotionPlanRequest\nfrom moveit_msgs.msg import JointConstraint\nfrom moveit_msgs.msg import Constraints\nfrom moveit_msgs.msg import PlanningOptions\nfrom moveit_msgs.action import MoveGroup\n\nimport numpy as np\nfrom copy import deepcopy\n\ntarget_angles = None\nglobal_joint_states = None\ntf_base_link_block = None\ntf_base_link_location = None\n\n\nclass GripperActionClient(Node):\n    def __init__(self):\n        super().__init__(\"GripperAC\")\n        self.action_client = ActionClient(\n            self,\n            FollowJointTrajectory,\n            \"/tiago_gripper_joint_trajectory_controller/follow_joint_trajectory\",\n        )\n\n    def send_goal(self, gripper_action):\n        self.goal_done = False\n\n        goal_msg = FollowJointTrajectory.Goal()\n\n        # Set your joint trajectory goal here\n        goal_msg.trajectory.joint_names = [\n            \"gripper_left_finger_joint\",\n            \"gripper_right_finger_joint\",\n        ]\n        point = JointTrajectoryPoint()\n        if gripper_action == \"close\":\n            point.positions = [0.02, 0.02]\n        elif gripper_action == \"open\":\n            point.positions = [0.045, 0.045]  # Replace with desired joint positions\n        point.time_from_start.sec = 1  # Duration in seconds\n\n        goal_msg.trajectory.points.append(point)\n\n        self.action_client.wait_for_server()\n        self._send_goal_future = self.action_client.send_goal_async(\n            goal_msg, feedback_callback=self.feedback_callback\n        )\n        self._send_goal_future.add_done_callback(self.goal_response_callback)\n\n    def goal_response_callback(self, future):\n        goal_handle = future.result()\n        if not goal_handle.accepted:\n            self.get_logger().info(\"Goal rejected :(\")\n            self.goal_done = True\n            return\n\n        self.get_logger().info(\"Goal accepted :)\")\n\n        self._get_result_future = goal_handle.get_result_async()\n        self._get_result_future.add_done_callback(self.get_result_callback)\n\n    def get_result_callback(self, future):\n        # self.get_logger().info(str(future))\n        self.goal_done = True\n\n    def feedback_callback(self, feedback_msg):\n        # self.get_logger().info(str(feedback_msg))\n        pass\n\n\nclass MoveGroupActionClient(Node):\n    def __init__(self):\n        super().__init__(\"MoveGroupAC\")\n        self.action_client = ActionClient(self, MoveGroup, \"/move_action\")\n\n    def send_goal(self, target_angles):\n        self.goal_done = False\n        j = target_angles\n\n        self.motion_plan_request = MotionPlanRequest()\n        self.motion_plan_request.workspace_parameters.header.frame_id = \"base_link\"\n        self.motion_plan_request.workspace_parameters.min_corner.x = -1.0\n        self.motion_plan_request.workspace_parameters.min_corner.y = -1.0\n        self.motion_plan_request.workspace_parameters.min_corner.z = -1.0\n        self.motion_plan_request.workspace_parameters.max_corner.x = 1.0\n        self.motion_plan_request.workspace_parameters.max_corner.y = 1.0\n        self.motion_plan_request.workspace_parameters.max_corner.z = 1.0\n        self.motion_plan_request.start_state.is_diff = True\n\n        joints = {}\n        joints[\"spotarm_1_joint\"] = j[0]\n        joints[\"spotarm_2_joint\"] = j[1]\n        joints[\"spotarm_3_joint\"] = j[2]\n        joints[\"spotarm_4_joint\"] = j[3]\n        joints[\"Slider11\"] = j[4]\n        joints[\"spotarm_5_joint\"] = j[5]\n        joints[\"spotarm_6_joint\"] = j[6]\n\n        jc = JointConstraint()\n        jc.tolerance_above = 0.001\n        jc.tolerance_below = 0.001\n        jc.weight = 1.0\n\n        constraints = Constraints()\n        for joint, angle in joints.items():\n            jc.joint_name = joint\n            jc.position = angle\n            constraints.joint_constraints.append(deepcopy(jc))\n\n        self.motion_plan_request.goal_constraints.append(constraints)\n\n        self.motion_plan_request.pipeline_id = \"move_group\"\n        self.motion_plan_request.group_name = \"spot_arm\"\n        self.motion_plan_request.num_planning_attempts = 4\n        self.motion_plan_request.allowed_planning_time = 4.0\n        self.motion_plan_request.max_velocity_scaling_factor = 0.6\n        self.motion_plan_request.max_acceleration_scaling_factor = 0.6\n        self.motion_plan_request.max_cartesian_speed = 0.0\n\n        self.planning_options = PlanningOptions()\n        self.planning_options.plan_only = False\n        self.planning_options.look_around = True\n        self.planning_options.look_around_attempts = 5\n        self.planning_options.max_safe_execution_cost = 0.0\n        self.planning_options.replan = True\n        self.planning_options.replan_attempts = 4\n        self.planning_options.replan_delay = 0.1\n\n        goal_msg = MoveGroup.Goal()\n        goal_msg.request = self.motion_plan_request\n        goal_msg.planning_options = self.planning_options\n\n        self.action_client.wait_for_server()\n        self._send_goal_future = self.action_client.send_goal_async(\n            goal_msg, feedback_callback=self.feedback_callback\n        )\n        self._send_goal_future.add_done_callback(self.goal_response_callback)\n\n    def goal_response_callback(self, future):\n        goal_handle = future.result()\n        if not goal_handle.accepted:\n            self.get_logger().info(\"Goal rejected :(\")\n            self.goal_done = True\n            return\n\n        self.get_logger().info(\"Goal accepted :)\")\n\n        self._get_result_future = goal_handle.get_result_async()\n        self._get_result_future.add_done_callback(self.get_result_callback)\n\n    def get_result_callback(self, future):\n        # self.get_logger().info(str(future))\n        self.goal_done = True\n\n    def feedback_callback(self, feedback_msg):\n        # self.get_logger().info(str(feedback_msg))\n        pass\n\n\nclass MinimalClientAsync(Node):\n    def __init__(self):\n        super().__init__(\"IKAC\")\n\n        self.tf_buffer = Buffer()\n        self.tf_listener = TransformListener(self.tf_buffer, self)\n        self.create_subscription(JointState, \"/joint_states\", self.joint_states_cb, 1)\n\n        self.cli = self.create_client(GetPositionIK, \"/compute_ik\")\n        while not self.cli.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info(\"service not available, waiting again...\")\n\n    def on_timer(self, block, location):\n        global tf_base_link_block, tf_base_link_location\n        try:\n            t = self.tf_buffer.lookup_transform(\"base_link\", block, rclpy.time.Time())\n            tf_base_link_block = [\n                t.transform.translation.x,\n                t.transform.translation.y,\n                t.transform.translation.z,\n                t.transform.rotation.x,\n                t.transform.rotation.y,\n                t.transform.rotation.z,\n                t.transform.rotation.w,\n            ]\n            self.tf_base_link_block = tf_base_link_block\n            t = self.tf_buffer.lookup_transform(\n                \"base_link\", location, rclpy.time.Time()\n            )\n            tf_base_link_location = [\n                t.transform.translation.x,\n                t.transform.translation.y,\n                t.transform.translation.z,\n                t.transform.rotation.x,\n                t.transform.rotation.y,\n                t.transform.rotation.z,\n                t.transform.rotation.w,\n            ]\n            self.tf_base_link_location = tf_base_link_location\n        except TransformException as ex:\n            self.get_logger().info(f\"Could not transform base_link to can: {ex}\")\n            return\n\n    def joint_states_cb(self, joint_state):\n        global global_joint_states\n        global_joint_states = joint_state\n        self.joint_state = joint_state\n\n    def moveit_ik(self):\n        group_name = \"spot_arm\"\n        self.req.ik_request.group_name = group_name\n        self.req.ik_request.robot_state.joint_state = self.joint_state\n        self.req.ik_request.avoid_collisions = True\n\n        self.req.ik_request.pose_stamped.header.frame_id = \"base_link\"\n\n        if self.is_block:\n            if self.is_above:\n                xyz = [\n                    self.tf_base_link_block[0],\n                    self.tf_base_link_block[1],\n                    self.tf_base_link_block[2],\n                ]\n                self.req.ik_request.pose_stamped.pose.position.x = xyz[0]\n                self.req.ik_request.pose_stamped.pose.position.y = xyz[1]\n                self.req.ik_request.pose_stamped.pose.position.z = xyz[2] + 0.1\n            else:\n                xyz = [\n                    self.tf_base_link_block[0],\n                    self.tf_base_link_block[1],\n                    self.tf_base_link_block[2],\n                ]\n                self.req.ik_request.pose_stamped.pose.position.x = xyz[0]\n                self.req.ik_request.pose_stamped.pose.position.y = xyz[1]\n                self.req.ik_request.pose_stamped.pose.position.z = xyz[2] + 0.05\n        else:\n            if self.is_above:\n                xyz = [\n                    self.tf_base_link_location[0],\n                    self.tf_base_link_location[1],\n                    self.tf_base_link_location[2],\n                ]\n                self.req.ik_request.pose_stamped.pose.position.x = xyz[0]\n                self.req.ik_request.pose_stamped.pose.position.y = xyz[1]\n                self.req.ik_request.pose_stamped.pose.position.z = xyz[2] + 0.16\n            else:\n                xyz = [\n                    self.tf_base_link_location[0],\n                    self.tf_base_link_location[1],\n                    self.tf_base_link_location[2],\n                ]\n                self.req.ik_request.pose_stamped.pose.position.x = xyz[0]\n                self.req.ik_request.pose_stamped.pose.position.y = xyz[1]\n                self.req.ik_request.pose_stamped.pose.position.z = xyz[2] + 0.09\n\n        self.req.ik_request.timeout.sec = 5\n\n        return self.req.ik_request\n\n    def send_request(self, is_block, is_above):\n        self.is_block = is_block\n        self.is_above = is_above\n        self.req = GetPositionIK.Request()\n        self.req.ik_request = self.moveit_ik()\n\n        self.future = self.cli.call_async(self.req)\n        rclpy.spin_until_future_complete(self, self.future)\n        return self.future.result()\n\n\ndef reset_variables():\n    global global_joint_states, tf_base_link_block, tf_base_link_location, target_angles\n    target_angles = None\n    global_joint_states = None\n    tf_base_link_block = None\n    tf_base_link_location = None\n\n\ndef begin_stacking(stack_gh):\n    global global_joint_states, tf_base_link_block, tf_base_link_location, target_angles\n\n    service_client = MinimalClientAsync()\n    moveitaction_client = MoveGroupActionClient()\n    gripperaction_client = GripperActionClient()\n\n    reset_variables()\n\n    block = stack_gh.request.block.upper()\n    location = stack_gh.request.location.upper()\n    service_client.get_logger().info(block + \":\" + location)\n\n    # Open gripper\n    gripperaction_client.send_goal(\"open\")\n    while not gripperaction_client.goal_done:\n        rclpy.spin_once(gripperaction_client)\n\n    while (\n        global_joint_states is None\n        or tf_base_link_block is None\n        or tf_base_link_location is None\n    ) and rclpy.ok():\n        service_client.on_timer(block, location)\n        rclpy.spin_once(service_client)\n\n    # Move above block\n    response = service_client.send_request(is_block=True, is_above=True)\n    target_angles = list(response.solution.joint_state.position)[:7]\n    if not len(target_angles):\n        service_client._logger.info(\"No IK solution found\")\n        return\n    service_client._logger.info(str([round(np.rad2deg(ta)) for ta in target_angles]))\n    moveitaction_client.send_goal(target_angles)\n    while not moveitaction_client.goal_done:\n        rclpy.spin_once(moveitaction_client)\n\n    # Move to block\n    response = service_client.send_request(is_block=True, is_above=False)\n    target_angles = list(response.solution.joint_state.position)[:7]\n    if not len(target_angles):\n        service_client._logger.info(\"No IK solution found\")\n        return\n    service_client._logger.info(str([round(np.rad2deg(ta)) for ta in target_angles]))\n    moveitaction_client.send_goal(target_angles)\n    while not moveitaction_client.goal_done:\n        rclpy.spin_once(moveitaction_client)\n\n    # Close gripper\n    gripperaction_client.send_goal(\"close\")\n    while not gripperaction_client.goal_done:\n        rclpy.spin_once(gripperaction_client)\n\n    reset_variables()\n\n    # Move above location\n    target_angles = None\n    response = service_client.send_request(is_block=False, is_above=True)\n    target_angles = list(response.solution.joint_state.position)[:7]\n    if not len(target_angles):\n        service_client._logger.info(\"No IK solution found\")\n        return\n    service_client._logger.info(str([round(np.rad2deg(ta)) for ta in target_angles]))\n    moveitaction_client.send_goal(target_angles)\n    while not moveitaction_client.goal_done:\n        rclpy.spin_once(moveitaction_client)\n\n    # Move to location\n    target_angles = None\n    response = service_client.send_request(is_block=False, is_above=False)\n    target_angles = list(response.solution.joint_state.position)[:7]\n    if not len(target_angles):\n        service_client._logger.info(\"No IK solution found\")\n        return\n    service_client._logger.info(str([round(np.rad2deg(ta)) for ta in target_angles]))\n    moveitaction_client.send_goal(target_angles)\n    while not moveitaction_client.goal_done:\n        rclpy.spin_once(moveitaction_client)\n\n    # Open gripper\n    gripperaction_client.send_goal(\"open\")\n    while not gripperaction_client.goal_done:\n        rclpy.spin_once(gripperaction_client)\n\n    # Move above location\n    target_angles = None\n    response = service_client.send_request(is_block=False, is_above=True)\n    target_angles = list(response.solution.joint_state.position)[:7]\n    if not len(target_angles):\n        service_client._logger.info(\"No IK solution found\")\n        return\n    service_client._logger.info(str([round(np.rad2deg(ta)) for ta in target_angles]))\n    moveitaction_client.send_goal(target_angles)\n    while not moveitaction_client.goal_done:\n        rclpy.spin_once(moveitaction_client)\n\n    stack_gh.succeed()\n    result = Stack.Result()\n    result.stacked = True\n    return result\n\n\ndef main():\n    rclpy.init()\n\n    stacker_node = Node(\"stacker_python\")\n\n    executor = MultiThreadedExecutor(num_threads=2)\n    executor.add_node(stacker_node)\n\n    ActionServer(stacker_node, Stack, \"stack\", begin_stacking)\n\n    executor.spin()\n    rclpy.shutdown()\n\n\nif __name__ == \"__main__\":\n    main()\n"}\n{"instruction": "Write a ROS2 Python node named inference_real.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "from typing import Tuple, Sequence, Dict, Union, Optional, Callable\nimport numpy as np\nimport math\nimport torch\nimport torch.nn as nn\nimport torchvision\nimport collections\nimport zarr\nfrom diffusers.schedulers.scheduling_ddpm import DDPMScheduler\nfrom diffusers.training_utils import EMAModel\nfrom diffusers.optimization import get_scheduler\nfrom tqdm.auto import tqdm\nimport gdown\nimport os\nfrom skvideo.io import vwrite\nfrom real_robot_network import DiffusionPolicy_Real\nfrom data_util import data_utils\nimport cv2\nfrom train_utils import train_utils\nimport pyrealsense2 as rs\nimport os\nfrom scipy.spatial.transform import Rotation as R\nimport time\nimport rclpy\nfrom rclpy.node import Node\nfrom rclpy.action import ActionClient\nfrom sensor_msgs.msg import JointState\nfrom moveit_msgs.srv import GetPositionFK, GetPositionIK\nfrom moveit_msgs.msg import RobotState, MoveItErrorCodes, JointConstraint, Constraints\nfrom geometry_msgs.msg import Pose, WrenchStamped\nfrom trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint\nfrom control_msgs.action import FollowJointTrajectory\n# from data_collection.submodules.wait_for_message import wait_for_message\nimport matplotlib.pyplot as plt\n#@markdown ### **Loading Pretrained Checkpoint**\n#@markdown Set `load_pretrained = True` to load pretrained weights.\nfrom typing import Union\nimport json\nfrom rclpy.impl.implementation_singleton import rclpy_implementation as _rclpy\nfrom rclpy.qos import QoSProfile\nfrom rclpy.signals import SignalHandlerGuardCondition\nfrom rclpy.utilities import timeout_sec_to_nsec\nfrom kuka_execute import KukaMotionPlanning\nimport cv2\nfrom rotation_utils import quat_from_rot_m, rot6d_to_mat, mat_to_rot6d, quat_to_rot_m, normalize\nimport hydra\nfrom omegaconf import DictConfig\nfrom data_util import center_crop\nimport csv\nfrom datetime import datetime\nfrom copy import deepcopy\n\ndef wait_for_message(\n    msg_type,\n    node: 'Node',\n    topic: str,\n    *,\n    qos_profile: Union[QoSProfile, int] = 1,\n    time_to_wait=-1\n):\n    \"\"\"\n    Wait for the next incoming message.\n\n    :param msg_type: message type\n    :param node: node to initialize the subscription on\n    :param topic: topic name to wait for message\n    :param qos_profile: QoS profile to use for the subscription\n    :param time_to_wait: seconds to wait before returning\n    :returns: (True, msg) if a message was successfully received, (False, None) if message\n        could not be obtained or shutdown was triggered asynchronously on the context.\n    \"\"\"\n    context = node.context\n    wait_set = _rclpy.WaitSet(1, 1, 0, 0, 0, 0, context.handle)\n    wait_set.clear_entities()\n\n    sub = node.create_subscription(msg_type, topic, lambda _: None, qos_profile=qos_profile)\n    try:\n        wait_set.add_subscription(sub.handle)\n        sigint_gc = SignalHandlerGuardCondition(context=context)\n        wait_set.add_guard_condition(sigint_gc.handle)\n\n        timeout_nsec = timeout_sec_to_nsec(time_to_wait)\n        wait_set.wait(timeout_nsec)\n\n        subs_ready = wait_set.get_ready_entities('subscription')\n        guards_ready = wait_set.get_ready_entities('guard_condition')\n\n        if guards_ready:\n            if sigint_gc.handle.pointer in guards_ready:\n                return False, None\n\n        if subs_ready:\n            if sub.handle.pointer in subs_ready:\n                msg_info = sub.handle.take_message(sub.msg_type, sub.raw)\n                if msg_info is not None:\n                    return True, msg_info[0]\n    finally:\n        node.destroy_subscription(sub)\n\n    return False, None\n\n#@markdown ### **Network Demo**\nclass EndEffectorPoseNode(Node):\n    timeout_sec_ = 5.0\n    joint_state_topic_ = \"lbr/joint_states\"\n    fk_srv_name_ = \"lbr/compute_fk\"\n    ik_srv_name_ = \"lbr/compute_ik\"\n    base_ = \"lbr/link_0\"\n    end_effector_ = \"link_ee\"\n\n\n    def __init__(self, node_id: str) -> None:\n        super().__init__(f\"end_effector_pose_node_{node_id}\")\n        self.force_torque_topic_ = \"/lbr/force_torque_broadcaster/wrench\"\n\n        # Subscribe to the force/torque sensor topic\n        self.force_torque_subscriber = self.create_subscription(WrenchStamped, self.force_torque_topic_, self.force_torque_callback, 10)\n        \n        self.fk_client_ = self.create_client(GetPositionFK, self.fk_srv_name_)\n        if not self.fk_client_.wait_for_service(timeout_sec=self.timeout_sec_):\n            self.get_logger().error(\"FK service not available.\")\n            exit(1)\n        self.ik_client_ = self.create_client(GetPositionIK, self.ik_srv_name_)\n        if not self.ik_client_.wait_for_service(timeout_sec=self.timeout_sec_):\n            self.get_logger().error(\"IK service not available.\")\n            exit(1)\n\n    def force_torque_callback(self, msg):\n        self.force_torque_data = msg.wrench\n\n    def get_fk(self) -> Pose | None:\n        current_joint_state_set, current_joint_state = wait_for_message(\n            JointState, self, self.joint_state_topic_, time_to_wait=1.0\n        )\n        if not current_joint_state_set:\n            self.get_logger().warn(\"Failed to get current joint state\")\n        else:\n            current_robot_state = RobotState()\n            current_robot_state.joint_state = current_joint_state\n\n            request = GetPositionFK.Request()\n\n            request.header.frame_id = self.base_\n            request.header.stamp = self.get_clock().now().to_msg()\n\n            request.fk_link_names.append(self.end_effector_)\n            request.robot_state = current_robot_state\n\n            future = self.fk_client_.call_async(request)\n\n            rclpy.spin_until_future_complete(self, future)\n            if future.result() is None:\n                self.get_logger().error(\"Failed to get FK solution\")\n                return None\n            \n            response = future.result()\n            if response.error_code.val != MoveItErrorCodes.SUCCESS:\n                self.get_logger().error(\n                    f\"Failed to get FK solution: {response.error_code.val}\"\n                )\n                return None\n            \n            pose = response.pose_stamped[0].pose\n            position = [pose.position.x, pose.position.y, pose.position.z]\n            quaternion = [pose.orientation.x, pose.orientation.y, pose.orientation.z, pose.orientation.w]\n            if quaternion[3] < 0:\n                quaternion = [-x for x in quaternion]\n            # # Convert quaternion to roll, pitch, yaw\n            # rotation = R.from_quat(quaternion)\n            # rpy = rotation.as_euler('xyz', degrees=False).tolist()\n            return position + quaternion\n    \n    def get_ik(self, target_pose: Pose) -> JointState | None:\n        request = GetPositionIK.Request()\n    \n        request.ik_request.group_name = \"arm\"\n        # tf_prefix = self.get_namespace()[1:]\n        request.ik_request.pose_stamped.header.frame_id = f\"{self.base_}\"\n        request.ik_request.pose_stamped.header.stamp = self.get_clock().now().to_msg()\n        request.ik_request.pose_stamped.pose = target_pose\n        request.ik_request.avoid_collisions = True\n        constraints = Constraints()\n        current_positions = []\n        current_joint_state_set, current_joint_state = wait_for_message(\n            JointState, self, self.joint_state_topic_, time_to_wait=1.0\n        )\n        for joint_name,current_position in zip(current_joint_state.name, np.array(current_joint_state.position)):\n            if joint_name == \"A1\":\n                joint_constraint = JointConstraint()\n                joint_constraint.joint_name = joint_name\n                joint_constraint.position = current_position\n                joint_constraint.tolerance_below = np.pi/4\n                joint_constraint.tolerance_above = np.pi/4\n                joint_constraint.weight = 1.0\n                constraints.joint_constraints.append(joint_constraint)\n            elif joint_name == \"A2\":\n                joint_constraint = JointConstraint()\n                joint_constraint.joint_name = joint_name\n                joint_constraint.position = current_position\n                joint_constraint.tolerance_below = np.pi/4\n                joint_constraint.tolerance_above = np.pi/4\n                joint_constraint.weight = 1.0\n                constraints.joint_constraints.append(joint_constraint)\n            elif joint_name == \"A3\":\n                joint_constraint = JointConstraint()\n                joint_constraint.joint_name = joint_name\n                joint_constraint.position = current_position\n                joint_constraint.tolerance_below = np.pi/2\n                joint_constraint.tolerance_above = np.pi/2\n                joint_constraint.weight = 0.5\n                constraints.joint_constraints.append(joint_constraint)\n            elif joint_name == \"A4\":\n                joint_constraint = JointConstraint()\n                joint_constraint.joint_name = joint_name\n                joint_constraint.position = current_position\n                joint_constraint.tolerance_below = np.pi/2\n                joint_constraint.tolerance_above = np.pi/2\n                joint_constraint.weight = 0.5\n                constraints.joint_constraints.append(joint_constraint)\n            elif joint_name == \"A5\":\n                joint_constraint = JointConstraint()\n                joint_constraint.joint_name = joint_name\n                joint_constraint.position = current_position\n                joint_constraint.tolerance_below = np.pi/3\n                joint_constraint.tolerance_above = np.pi/3\n                joint_constraint.weight = 0.5\n                constraints.joint_constraints.append(joint_constraint)\n\n        request.ik_request.constraints = constraints\n        future = self.ik_client_.call_async(request)\n\n        rclpy.spin_until_future_complete(self, future)\n        if future.result() is None:\n            self.get_logger().error(\"Failed to get IK solution\")\n            return None\n\n        response = future.result()\n        if response.error_code.val != MoveItErrorCodes.SUCCESS:\n            return None\n\n        return response.solution.joint_state\n    \nclass EvaluateRealRobot:\n    # construct ResNet18 encoder\n    # if you have multiple camera views, use seperate encoder weights for each view.\n    def __init__(self, max_steps, \n                 encoder = \"resnet\",\n                  action_def = \"delta\", \n                  force_mod= False, single_view = False,\n                  force_encoder = \"CNN\",\n                  force_encode = False,\n                  cross_attn = False, \n                  hybrid = False,\n                  crop = 1000):\n        \n        self.csv_file_path = self.create_unique_csv_path()\n        self.setup_csv_file()\n        print(f\"force_encoder: {force_encoder}\")\n        diffusion = DiffusionPolicy_Real(train=False, \n                                        encoder = encoder, \n                                        action_def = action_def, \n                                        force_mod=force_mod,\n                                        single_view= single_view, \n                                        force_encoder = force_encoder, \n                                        force_encode = force_encode, \n                                        cross_attn = cross_attn,\n                                        hybrid = hybrid,\n                                        crop = crop)\n        # num_epochs = 100\n        ema_nets = self.load_pretrained(diffusion)\n        # agent_pos is 2 dimensional\n        # lowdim_obs_dim = 2\n        # # observation feature has 514 dims in total per step\n        # obs_dim = vision_feature_dim + lowdim_obs_dim\n        # action_dim = 2\n        #@markdown ### **Inference**\n        ############# Reference for environment #######\n        # limit enviornment interaction to 200 steps before termination\n        ###TODO: Swap this environment with the real data\n        #     env = PushTImageEnv()\n        #     # use a seed >200 to avoid initial states seen in the training dataset\n        #     env.seed(100000)\n\n        #     # get first observation\n        #     obs, info = env.reset()\n\n        # save visualization and rewards\n        # imgs = [env.render(mode='rgb_array')]\n\n        # rewards = list()\n        step_idx = 0\n        # device transfer\n        device = torch.device('cuda')\n        _ = diffusion.nets.to(device)\n        # Initialize realsense camera\n        pipeline_A = rs.pipeline()\n        pipeline_B = rs.pipeline()\n        camera_context = rs.context()\n        camera_devices = camera_context.query_devices()\n        self.diffusion = diffusion\n        self.force_encode = force_encode\n        self.cross_attn = cross_attn\n        if not single_view:\n            if len(camera_devices) < 2:\n                raise RuntimeError(\"Two cameras are required, but fewer were detected.\")\n        else:\n            if len(camera_devices) < 1:\n                raise RuntimeError(\"One camera required, but fewer were detected.\")\n        # Initialize Camera A\n        serial_A = camera_devices[1].get_info(rs.camera_info.serial_number)\n        # Configure Camera A\n        config_A = rs.config()\n        config_A.enable_device(serial_A)\n        config_A.enable_stream(rs.stream.color, 640, 480, rs.format.bgr8, 30)\n        align_A = rs.align(rs.stream.color)\n\n        # Initialize Camera B\n        serial_B = camera_devices[0].get_info(rs.camera_info.serial_number)\n        # Configure Camera B\n        config_B = rs.config()\n        config_B.enable_device(serial_B)\n        config_B.enable_stream(rs.stream.color, 640, 480, rs.format.bgr8, 30)\n\n        # Start pipelines\n        align_B = rs.align(rs.stream.color)\n\n\n        # self.env = env\n        # self.obs = obs\n        # self.info = info\n        # self.rewards = rewards\n        self.device = device\n        # self.imgs = imgs\n        self.max_steps = max_steps\n        self.ema_nets = ema_nets\n        self.step_idx = step_idx\n        self.crop = crop\n        if single_view:\n            self.pipeline_B = pipeline_B\n            self.camera_device = camera_devices\n            self.align_B = align_B\n            self.pipeline_B.start(config_B)\n\n        else:\n            self.pipeline_B = pipeline_B\n            self.camera_device = camera_devices\n            self.align_B = align_B\n            self.pipeline_B.start(config_B)\n            self.pipeline_A = pipeline_A\n            self.align_A = align_A\n            self.pipeline_A.start(config_A)\n\n        self.encoder = encoder\n        self.action_def = action_def\n        time.sleep(4)\n        self.force_mod = force_mod\n        self.single_view = single_view\n        self.hybrid = hybrid\n        obs = self.get_observation()\n         # keep a queue of last 2 steps of observations\n        obs_deque = collections.deque(\n            [obs] * diffusion.obs_horizon, maxlen=diffusion.obs_horizon)\n\n        self.obs_deque = obs_deque\n        \n    def create_unique_csv_path(self):\n        \"\"\"Generate a unique CSV file path with a timestamp.\"\"\"\n        timestamp = datetime.now().strftime(\"%Y-%m-%d_%H-%M-%S\")\n        filename = f\"inference_{timestamp}.csv\"\n        directory = \"/home/lm-2023/jeon_team_ws/playback_pose/src/data_collection/data_collection\"\n        return os.path.join(directory, filename)\n    \n    def setup_csv_file(self):\n        \"\"\"Set up the CSV file with headers if it does not already exist.\"\"\"\n        if not os.path.isfile(self.csv_file_path):\n            with open(self.csv_file_path, mode='w', newline='') as csv_file:\n                writer = csv.writer(csv_file)\n                writer.writerow(['fx', 'fy', 'fz'])  # Write header if new file\n\n    def save_agent_pos_to_csv(self, force_torque_data):\n        \"\"\"\n        Save agent position data to a CSV file.\n\n        :param agent_pos: List or array containing the agent's position and rotation (e.g., [x, y, z, qx, qy, qz, qw])\n        \"\"\"\n        with open(self.csv_file_path, mode='a', newline='') as csv_file:\n            writer = csv.writer(csv_file)\n            writer.writerow(force_torque_data)\n\n    def get_observation(self):\n        ### Get initial observation for the\n        EE_Pose_Node = EndEffectorPoseNode(\"obs\")\n        obs = {}\n        single_view = self.single_view\n        #TODO: Image data from two realsense camera\n        if single_view:\n            pipeline_B = self.pipeline_B\n            align_B = self.align_B\n        else:\n            pipeline_A = self.pipeline_A\n            align_A = self.align_A\n            pipeline_B = self.pipeline_B\n            align_B = self.align_B\n\n        # Camera intrinsics (dummy values, replace with your actual intrinsics)\n        camera_intrinsics = {\n            'K': np.array([[640, 0, 320], [0, 640, 240], [0, 0, 1]], dtype=np.float32),\n            'dist': np.zeros((5, 1))  # No distortion\n        }\n        \n        # Camera A pose relative to robot base\n        # camera_pose_robot_base = [0.47202, 0.150503, 1.24777, 0.00156901, 0.999158, -0.0183132, -0.036689]\n        # camera_translation = np.array(camera_pose_robot_base[:3])\n        # camera_rotation = R.from_quat(camera_pose_robot_base[3])\n        image_A = None\n        image_B = None\n\n        #TODO: Get IIWA pose as [x,y,z, roll, pitch, yaw]\n        agent_pos = EE_Pose_Node.get_fk()\n        agent_pos = np.array(agent_pos)\n        agent_pos.astype(np.float64)\n        force_torque_data = None\n        force_torque_data = [EE_Pose_Node.force_torque_data.force.x, EE_Pose_Node.force_torque_data.force.y, EE_Pose_Node.force_torque_data.force.z]\n        force_torque_data = np.asanyarray(force_torque_data)\n        force_torque_data.astype(np.float32)\n\n        if agent_pos is None:\n            EE_Pose_Node.get_logger().error(\"Failed to get end effector pose\")\n        #####\n        if single_view:\n            frames_B = pipeline_B.wait_for_frames()\n            aligned_frames_B = align_B.process(frames_B)\n            color_frame_B = aligned_frames_B.get_color_frame()\n            color_image_B = np.asanyarray(color_frame_B.get_data())\n            color_image_B.astype(np.float32)\n        else:    \n            frames_A = pipeline_A.wait_for_frames()\n            aligned_frames_A = align_A.process(frames_A)\n            color_frame_A = aligned_frames_A.get_color_frame()\n            color_image_A = np.asanyarray(color_frame_A.get_data())\n            color_image_A.astype(np.float32)\n\n            frames_B = pipeline_B.wait_for_frames()\n            aligned_frames_B = align_B.process(frames_B)\n            color_frame_B = aligned_frames_B.get_color_frame()\n            color_image_B = np.asanyarray(color_frame_B.get_data())\n            color_image_B.astype(np.float32)\n        \n            image_A = cv2.resize(color_image_A, (320, 240), interpolation=cv2.INTER_AREA)\n            image_A_rgb = cv2.cvtColor(image_A, cv2.COLOR_BGR2RGB)\n\n        # Get the image dimensions\n        height_B, width_B, _ = color_image_B.shape\n\n        # Define the center point\n        center_x, center_y = width_B // 2, height_B // 2\n        if self.encoder == \"Transformer\":\n            print(\"crop to 224 by 224\")\n            crop_width, crop_height = 224, 224\n        else:\n            # Define the crop size\n            crop_width, crop_height = 224, 224\n        # Calculate the top-left corner of the crop box\n        x1 = max(center_x - crop_width // 2, 0)\n        y1 = max(center_y - crop_height // 2, 0)\n\n        # Calculate the bottom-right corner of the crop box\n        x2 = min(center_x + crop_width // 2, width_B)\n        y2 = min(center_y + crop_height // 2, height_B)\n\n        cropped_image_B = color_image_B[y1:y2, x1:x2]\n\n\n        if self.crop == 98:\n            crop_width, crop_height = self.crop, self.crop\n            cropped_image_B = np.transpose(cropped_image_B, (2,0,1))\n            C,H,W = cropped_image_B.shape\n            # Calculate the center + 20 only when using 98 and 124 is -20 for start_x only\n            start_y = (H - crop_height + 20) // 2\n            start_x = (W - crop_width - 20) // 2\n            # start_y = (H - crop_height) // 2\n            # start_x = (W - crop_width - 20) // 2  \n            # Perform cropping\n            cropped_image_B = cropped_image_B[:, start_y:start_y + crop_height, start_x:start_x + crop_width]\n            cropped_image_B = np.transpose(cropped_image_B, (1,2,0))\n\n        # Convert BGR to RGB for Matplotlib visualization\n        image_B_rgb = cv2.cvtColor(cropped_image_B, cv2.COLOR_BGR2RGB)\n         ### Visualizing purposes\n        import matplotlib.pyplot as plt\n        # plt.imshow(image_A_rgb)\n        # plt.show()\n        # plt.imshow(image_B_rgb)\n        # plt.show()\n        print(f'current agent position, {agent_pos}')\n        self.save_agent_pos_to_csv(force_torque_data)\n        agent_position = agent_pos[:3]\n        agent_rotation = agent_pos[3:]\n        rot_m_agent = quat_to_rot_m(agent_rotation)\n        rot_6d = mat_to_rot6d(rot_m_agent)\n        agent_pos_10d = np.hstack((agent_position, rot_6d))\n\n        # Reshape to (C, H, W)\n        image_B = np.transpose(image_B_rgb, (2, 0, 1))\n        if not single_view:\n            image_A = np.transpose(image_A_rgb, (2, 0, 1))\n            obs['image_A'] = image_A\n        obs['image_B'] = image_B\n\n        if self.force_mod:\n            obs['force'] = force_torque_data\n        obs['agent_pos'] = agent_pos_10d\n        EE_Pose_Node.destroy_node()\n\n        return obs\n\n    # def hard_code(self, end_effector_pos):\n    #             ### Stepping function to execute action with robot\n    #     #TODO: Execute Motion\n    #     EE_Pose_Node = EndEffectorPoseNode(\"exec\")\n    #     end_effector_pos = [float(value) for value in end_effector_pos]\n    #     position = end_effector_pos[:3]\n    #     quaternion = end_effector_pos[3:]\n    #     print(f'action command {end_effector_pos}')\n    #     # Create Pose message for IK\n    #     target_pose = Pose()\n    #     target_pose.position.x = position[0]\n    #     target_pose.position.y = position[1]\n    #     target_pose.position.z = position[2]\n    #     target_pose.orientation.x = quaternion[0]\n    #     target_pose.orientation.y = quaternion[1]\n    #     target_pose.orientation.z = quaternion[2]\n    #     target_pose.orientation.w = quaternion[3]\n\n    #     # Get IK solution\n    #     joint_state = EE_Pose_Node.get_ik(target_pose)\n    #     if joint_state is None:\n    #         EE_Pose_Node.get_logger().error(\"Failed to get IK solution\")\n    #         return\n    #     steps = 1000000\n    #     # # Create a JointTrajectory message\n    #     # goal_msg = FollowJointTrajectory.Goal()\n    #     # trajectory_msg = JointTrajectory()\n    #     kuka_execution = KukaMotionPlanning(steps)\n    #     kuka_execution.send_goal(joint_state)\n\n    #     # # trajectory_msg.joint_names = kuka_execution.joint_names\n    #     # point = JointTrajectoryPoint()\n    #     # point.positions = joint_state.position\n    #     # point.time_from_start.sec = 1  # Set the duration for the motion\n    #     # trajectory_msg.points.append(point)\n        \n    #     # goal_msg.trajectory = trajectory_msg\n    #     # kuka_execution.send_goal(trajectory_msg)\n\n    #     # # Send the trajectory to the action server\n    #     # kuka_execution._action_client.wait_for_server()\n    #     # kuka_execution._send_goal_future = kuka_execution._action_client.send_goal_async(goal_msg, feedback_callback=kuka_execution.feedback_callback)\n    #     # kuka_execution._send_goal_future.add_done_callback(kuka_execution.goal_response_callback)\n    #     EE_Pose_Node.destroy_node()\n    #     kuka_execution.destroy_node()\n    \n    def execute_action(self, end_effector_pos, steps):\n        def quaternion_multiply(q1, q2):\n            x1, y1, z1, w1 = q1  # Note: [qx, qy, qz, qw]\n            x2, y2, z2, w2 = q2\n            \n            return np.array([\n                w1*x2 + x1*w2 + y1*z2 - z1*y2,\n                w1*y2 - x1*z2 + y1*w2 + z1*x2,\n                w1*z2 + x1*y2 - y1*x2 + z1*w2,\n                w1*w2 - x1*x2 - y1*y2 - z1*z2\n            ])\n        def compute_next_quaternion(q_current, q_delta):\n            # Changed order: delta * current instead of current * delta\n            q_next = quaternion_multiply(q_delta, q_current)\n            # Normalize the resulting quaternion\n            return q_next / np.linalg.norm(q_next)\n        \n        ### Stepping function to execute action with robot\n        #TODO: Execute Motion\n        EE_Pose_Node = EndEffectorPoseNode(\"exec\")\n        end_effector_pos = [float(value) for value in end_effector_pos]\n        position = end_effector_pos[:3]\n        rot6d = end_effector_pos[3:]\n        rot_m = rot6d_to_mat(np.array(rot6d))\n        quaternion = quat_from_rot_m(rot_m)\n        if self.action_def == \"delta\":\n            current_pos = EE_Pose_Node.get_fk()\n            np.array(quaternion)\n            print(current_pos)\n            print(f'action command {end_effector_pos} delta')\n            next_rot = compute_next_quaternion(current_pos[3:], quaternion)\n            # Create Pose message for IK\n            target_pose = Pose()\n            target_pose.position.x = current_pos[0] + position[0]\n            target_pose.position.y = current_pos[1] +  position[1]\n            target_pose.position.z = current_pos[2] +  position[2]\n            target_pose.orientation.x = next_rot[0]\n            target_pose.orientation.y = next_rot[1]\n            target_pose.orientation.z = next_rot[2]\n            target_pose.orientation.w = next_rot[3]\n        else:\n            print(f'action command {end_effector_pos} absolute')\n            # Create Pose message for IK\n            target_pose = Pose()\n            target_pose.position.x = position[0]\n            target_pose.position.y = position[1]\n            target_pose.position.z = position[2]\n            target_pose.orientation.x = quaternion[0]\n            target_pose.orientation.y = quaternion[1]\n            target_pose.orientation.z = quaternion[2]\n            target_pose.orientation.w = quaternion[3]\n\n        # Get IK solution\n        joint_state = EE_Pose_Node.get_ik(target_pose)\n        if joint_state is None:\n            EE_Pose_Node.get_logger().warn(\"Failed to get IK solution\")\n        else: \n            # # Create a JointTrajectory message\n            # goal_msg = FollowJointTrajectory.Goal()\n            # trajectory_msg = JointTrajectory()\n            kuka_execution = KukaMotionPlanning(steps)\n            kuka_execution.send_goal(joint_state)\n\n            # # trajectory_msg.joint_names = kuka_execution.joint_names\n            # point = JointTrajectoryPoint()\n            # point.positions = joint_state.position\n            # point.time_from_start.sec = 1  # Set the duration for the motion\n            # trajectory_msg.points.append(point)\n            \n            # goal_msg.trajectory = trajectory_msg\n            # kuka_execution.send_goal(trajectory_msg)\n\n            # # Send the trajectory to the action server\n            # kuka_execution._action_client.wait_for_server()\n            # kuka_execution._send_goal_future = kuka_execution._action_client.send_goal_async(goal_msg, feedback_callback=kuka_execution.feedback_callback)\n            # kuka_execution._send_goal_future.add_done_callback(kuka_execution.goal_response_callback)\n            EE_Pose_Node.destroy_node()\n            kuka_execution.destroy_node()\n            # construct new observationqq\n            obs = self.get_observation()\n            return obs\n    \n        # the final arch has 2 partsqqq\n    ###### Load Pretrained 1\n    def load_pretrained(self, diffusion):\n\n        load_pretrained = True\n        if load_pretrained:\n            ckpt_path = \"/home/lm-2023/jeon_team_ws/playback_pose/src/Diffusion_Policy_ICRA/checkpoints/Diffusion_PF_2000.pth\"\n            #   if not os.path.isfile(ckpt_path):qq\n            #       id = \"1XKpfNSlwYMGqaF5CncoFaLKCDTWoLAHf1&confirm=tn\"q\n            #       gdown.download(id=id, output=ckpt_path, quiet=False)    \n\n            state_dict = torch.load(ckpt_path, map_location='cuda')\n            #   noise_pred_net.load_state_dict(checkpoint['model_state_dict'])\n            #   start_epoch = checkpoint['epoch'] + 1\n            #   optimizer.load_state_dict(checkpoint['optimizer_state_dict'])\n            #   lr_scheduler.load_state_dict(checkpoint['lr_scheduler_state_diccput'])\n            #   start_epoch = checkpoint['epoch'] + 1\n            ema_nets = diffusion.nets\n            ema_nets.load_state_dict(state_dict)\n            print('Pretrained weights loaded.')\n        else:\n            print(\"Skipped pretrained weight loading.\")\n        return ema_nets\n    \n    def inference(self):\n        diffusion = self.diffusion\n        max_steps = self.max_steps\n        device = self.device\n        obs_deque = self.obs_deque\n        ema_nets = self.ema_nets\n        # rewards = self.rewards\n        step_idx = self.step_idx\n        done = False\n        steps = 0\n        force_obs = None\n        single_view = self.single_view\n        force_mod = self.force_mod\n        force_encode = self.force_encode\n        cross_attn = self.cross_attn\n        with open('/home/lm-2023/jeon_team_ws/playback_pose/src/Diffusion_Policy_ICRA/stats_RAL_AAA+D_419.z_resnet_delta_with_force.json', 'r') as f:\n            stats = json.load(f)\n            if force_mod:\n                stats['agent_pos']['min'] = np.array(stats['agent_pos']['min'], dtype=np.float32)\n                stats['agent_pos']['max'] = np.array(stats['agent_pos']['max'], dtype=np.float32)\n                stats['force_mag']['min'] = np.array(stats['force_mag']['min'], dtype=np.float32)\n                stats['force_mag']['max'] = np.array(stats['force_mag']['max'], dtype=np.float32)\n\n                # Convert stats['action']['min'] and ['max'] to numpy arrays with float32 type\n                stats['action']['min'] = np.array(stats['action']['min'], dtype=np.float32)\n                stats['action']['max'] = np.array(stats['action']['max'], dtype=np.float32)\n            else:\n                # Convert stats['agent_pos']['min'] and q['max'] to numpy arrays with float32 type\n                stats['agent_pos']['min'] = np.array(stats['agent_pos']['min'], dtype=np.float32)\n                stats['agent_pos']['max'] = np.array(stats['agent_pos']['max'], dtype=np.float32)\n\n                # Convert stats['action']['min'] and ['max'] to numpy arrays with float32 type\n                stats['action']['min'] = np.array(stats['action']['min'], dtype=np.float32)\n                stats['action']['max'] = np.array(stats['action']['max'], dtype=np.float32)\n        force_status = list()\n\n        with tqdm(total=max_steps, desc=\"Eval Real Robot\") as pbar:\n            while not done:\n                B = 1\n                # stack the last obs_horizon number of observations\n                if not self.single_view:\n                    images_A = np.stack([x['image_A'] for x in obs_deque])\n\n                images_B = np.stack([x['image_B'] for x in obs_deque])\n\n                if force_mod:\n                    force_obs = np.stack([x['force'] for x in obs_deque])\n\n                agent_poses = np.stack([x['agent_pos'] for x in obs_deque])\n                # print(agent_poses)\n                nagent_poses = data_utils.normalize_data(agent_poses[:,:3], stats=stats['agent_pos'])\n                if force_mod:\n                    nforce_mag, nforce_vec = data_utils.normalize_force_vector(force_obs)\n                    normalized_force_mag = data_utils.normalize_force_magnitude(nforce_mag, stats['force_mag'])\n                    normalized_force_data = np.hstack((normalized_force_mag, nforce_vec))\n                # images are already normalized to [0,1]qqq\n                if not self.single_view:\n                    nimages = images_A\n                    nimages = torch.from_numpy(nimages).to(device, dtype=torch.float32)\n\n                nimages_second_view = images_B\n                # device transfer\n                nimages_second_view = torch.from_numpy(nimages_second_view).to(device, dtype=torch.float32)\n\n                force_feature = None\n                if force_mod:\n                    nforce_observation = torch.from_numpy(normalized_force_data).to(device, dtype=torch.float32)\n                    force_feature = nforce_observation\n\n\n                processed_agent_poses = np.hstack((nagent_poses, agent_poses[:,3:]))\n                nagent_poses = torch.from_numpy(processed_agent_poses).to(device, dtype=torch.float32)\n                # infer action\n                with torch.no_grad():\n                    # get image features\n                    if not self.single_view:\n                        image_features_second_view = ema_nets['vision_encoder2'](nimages) # previously trained one vision_encoder 1\n                    # (2,512)\n\n                    if not cross_attn:\n                        image_features = ema_nets['vision_encoder'](nimages_second_view)\n                    if force_encode and not cross_attn:\n                        force_feature = ema_nets['force_encoder'](nforce_observation)\n                    elif not force_encode and cross_attn:\n                        joint_features = ema_nets['cross_attn_encoder'](nimages_second_view, nforce_observation)\n                    # concat with low-dim observations\n                    if force_mod and single_view and not cross_attn:\n                        obs_features = torch.cat([image_features, force_feature, nagent_poses], dim=-1)\n                    elif force_mod and not single_view and not cross_attn:\n                        obs_features = torch.cat([image_features_second_view, image_features, force_feature, nagent_poses], dim=-1)\n                    elif not force_mod and single_view:\n                        obs_features = torch.cat([image_features, nagent_poses], dim=-1)\n                    elif not force_mod and not single_view:\n                        obs_features = torch.cat([image_features_second_view, image_features, nagent_poses], dim=-1)\n                    else:\n                        print(\"Check your configuration for training\")\n\n                    # reshape observation to (B,obs_horizon*obs_dim)\n                    obs_cond = obs_features.unsqueeze(0).flatten(start_dim=1)\n\n                    # initialize action from Guassian noise\n                    noisy_action = torch.randn(\n                        (B, diffusion.pred_horizon, diffusion.action_dim), device=device)\n                    naction = noisy_action\n                    diffusion_inference_iteration = 100\n                    # init scheduler\n                    diffusion.noise_scheduler.set_timesteps(diffusion_inference_iteration)\n\n                    for k in diffusion.noise_scheduler.timesteps:\n                        # predict noise\n                        noise_pred = ema_nets['noise_pred_net'](\n                            sample=naction,\n                            timestep=k,\n                            global_cond=obs_cond\n                        )\n\n                        # inverse diffusion step (remove noise)\n                        naction = diffusion.noise_scheduler.step(\n                            model_output=noise_pred,\n                            timestep=k,\n                            sample=naction\n                        ).prev_sample\n\n                # unnormalize action\n                naction = naction.detach().to('cpu').numpy()\n                # (B, pred_horizon, action_dim)q\n                naction = naction[0]\n                action_pred = data_utils.unnormalize_data(naction[:,:3], stats=stats['action'])\n                action_pred = np.hstack((action_pred, naction[:,3:]))\n      \n                # only take action_horizon number of actions5\n                start = diffusion.obs_horizon - 1\n                \n                end = start + diffusion.action_horizon\n                action = action_pred[start:end,:] \n            # (action_horizon, action_dim)  \n    \n                # execute action_horizon number of steps\n                # without replanning\n                for i in range(len(action)):\n                    # stepping env\n                    obs = self.execute_action(action[i], steps)\n                    steps+=1\n\n\n                    # save observations\n                    obs_deque.append(obs)\n                    if self.force_mod:\n                        force_status.append(obs['force'])\n                    # and reward/vis\n                    # rewards.append(reward)\n                    # imgs.append(env.render(mode='rgb_array'))\n\n                    # update progress bar\n                    step_idx += 1\n                    pbar.update(1)\n                    # pbar.set_postfix(reward=reward)\n                    if step_idx > max_steps:\n                        done = True\n                    if done:\n                        break\n        # print out the maximum target coverage\n\n        # print('Score: ', max(rewards))\n        # return imgs\n\n        force = np.array(force_status)\n        Fx = force[:, 0]\n        Fy = force[:, 1]\n        Fz = force[:, 2]\n\n        # Create a time vector or use index for x-axis\n        time = np.arange(len(Fx))\n\n        # Plotting the force components\n        plt.figure(figsize=(10, 6))\n        plt.plot(time, Fx, label='Fx', color='r', linestyle='-', linewidth=2)\n        plt.plot(time, Fy, label='Fy', color='g', linestyle='--', linewidth=2)\n        plt.plot(time, Fz, label='Fz', color='b', linestyle='-.', linewidth=2)\n\n        # Add titles and labels\n        plt.title('Force Components Over Time', fontsize=16)\n        plt.xlabel('Time', fontsize=14)\n        plt.ylabel('Force (N)', fontsize=14)\n\n        # Add a grid\n        plt.grid(True, which='both', linestyle='--', linewidth=0.5)\n\n        # Add a legend\n        plt.legend(loc='best', fontsize=12)\n\n        # Show the plot\n        plt.tight_layout()\n        plt.show()\n\n@hydra.main(version_base=None, config_path=\"config\", config_name=\"resnet_delta_force_mod_single_view_force_Linear_encode\")\ndef main(cfg: DictConfig):\n    # Max steps will dicate how long the inference duration is going to be so it is very important\n    # Initialize RealSense pipelines for both cameras\n    rclpy.init()\n    try:  \n        max_steps = 100\n        # Evaluate Real Robot Environment\n        print(f\"inference on {cfg.name}\")\n        eval_real_robot = EvaluateRealRobot(max_steps= max_steps,\n                                            action_def = cfg.model_config.action_def, \n                                            encoder = cfg.model_config.encoder, \n                                            force_encoder = cfg.model_config.force_encoder, \n                                            force_mod=cfg.model_config.force_mod, \n                                            single_view= cfg.model_config.single_view, \n                                            force_encode = cfg.model_config.force_encode, \n                                            cross_attn = cfg.model_config.cross_attn, \n                                            hybrid = cfg.model_config.cross_attn,\n                                            crop = cfg.model_config.crop)\n        eval_real_robot.inference()\n        ######## This block is for Visualizing if in virtual environment ###### \n        # height, width, layers = imgs[0].shape\n        # video = cv2.VideoWriter('/home/jeon/jeon_ws/diffusion_policy/src/diffusion_cam/vis_real_robot.mp4', cv2.VideoWriter_fourcc(*'mp4v'), 15, (width, height))\n\n        # for img in imgs:\n        #     video.write(np.uint8(img))\n\n        # video.release()\n        ###########\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n    finally:\n        # Ensure shutdown is called even if an error occurs\n        rclpy.shutdown()\nif __name__ == \"__main__\":\n    main()"}\n{"instruction": "Write a ROS2 Python node named grid_map_window.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "#!/usr/bin/env python3\nimport sys\nimport math\nimport rclpy\nimport os\nfrom rclpy.node import Node\nfrom rclpy.qos import QoSProfile, ReliabilityPolicy\nfrom nav_msgs.msg import OccupancyGrid, Path\nfrom geometry_msgs.msg import PoseStamped, Point\n\nimport numpy as np\nfrom PyQt6.QtWidgets import (\n    QApplication, QMainWindow, QWidget,\n    QVBoxLayout, QHBoxLayout, QComboBox, QPushButton\n)\nfrom PyQt6.QtCore import QTimer, QRectF\nfrom PyQt6.QtGui import QFont, QIcon\n\nimport pyqtgraph as pg\nfrom pyqtgraph import ScatterPlotItem, TextItem, PlotDataItem\n\nfrom ament_index_python.packages import get_package_share_directory\n\nfrom astroviz.utils.window_style import DarkStyle\n\nfrom astroviz.common._find import _find_pkg, _find_src_config\n\n_src_config = _find_src_config()\nif _src_config:\n    _CONFIG_DIR = _src_config\nelse:\n    _CONFIG_DIR = os.path.join(\n        get_package_share_directory('astroviz'), 'config'\n    )\n\n\n_pkg = _find_pkg()\nif _pkg:\n    _PKG_DIR = _pkg\nelse:\n    _PKG_DIR = get_package_share_directory('astroviz')\n\nos.makedirs(_CONFIG_DIR, exist_ok=True)\n\nCONFIG_PATH = os.path.join(_CONFIG_DIR, 'dashboard_config.json')\nICONS_DIR  = os.path.join(_PKG_DIR, 'icons')\n\n\nclass GridMapViewer(QMainWindow):\n    def __init__(self, node: Node):\n        super().__init__()\n        self.node = node\n        self.setWindowTitle(\"GridMap Viewer\")\n        self.setWindowIcon(QIcon(os.path.join(ICONS_DIR, 'astroviz_icon.png')))\n        self.resize(800, 600)\n\n        pub_qos = QoSProfile(depth=10, reliability=ReliabilityPolicy.RELIABLE)\n        self.wp_pub = self.node.create_publisher(\n            Path, '/gridmap/waypoints', pub_qos)\n\n        self.combo = QComboBox()\n        self.combo.setFixedWidth(200)\n        self.combo.currentTextChanged.connect(self.change_topic)\n\n        self.btn_waypoints = QPushButton(\"Add/Remove Waypoints\")\n        self.btn_waypoints.setCheckable(True)\n        self.btn_waypoints.clicked.connect(self.toggle_waypoint_mode)\n\n        self.btn_publish = QPushButton(\"Publish Waypoints\")\n        self.btn_publish.clicked.connect(self.publish_waypoints)\n\n        top_bar = QWidget()\n        hlay = QHBoxLayout(top_bar)\n        hlay.setContentsMargins(5,5,5,5)\n        hlay.addWidget(self.combo)\n        hlay.addWidget(self.btn_waypoints)\n        hlay.addWidget(self.btn_publish)\n        hlay.addStretch()\n\n        self.graph_widget = pg.GraphicsLayoutWidget()\n        self.view_box = self.graph_widget.addViewBox()\n        self.view_box.setAspectLocked(True)\n\n        self.img_item = pg.ImageItem()\n        self.view_box.addItem(self.img_item)\n\n        self.wp_scatter = ScatterPlotItem(\n            size=10, pen=pg.mkPen('r'), brush=pg.mkBrush('r')\n        )\n        self.view_box.addItem(self.wp_scatter)\n\n        self.wp_line = PlotDataItem(pen=pg.mkPen('b', width=2))\n        self.view_box.addItem(self.wp_line)\n\n        self.wp_labels = []\n\n        central = QWidget()\n        self.setCentralWidget(central)\n        main_v = QVBoxLayout(central)\n        main_v.setContentsMargins(0,0,0,0)\n        main_v.addWidget(top_bar)\n        main_v.addWidget(self.graph_widget)\n\n        self.sub = None\n        self.map_info = None\n        self.waypoints = []\n        self._first_map = True\n\n        self.ros_timer = QTimer(self)\n        self.ros_timer.timeout.connect(lambda: rclpy.spin_once(self.node, timeout_sec=0))\n        self.ros_timer.start(10)\n\n        self.topic_timer = QTimer(self)\n        self.topic_timer.timeout.connect(self._populate_topics)\n        self.topic_timer.start(1000)\n\n        self._populate_topics()\n\n    def _populate_topics(self):\n        topics = self.node.get_topic_names_and_types()\n        grids = [n for n, t in topics if 'nav_msgs/msg/OccupancyGrid' in t]\n        items = ['---'] + sorted(grids)\n        current = [self.combo.itemText(i) for i in range(self.combo.count())]\n        if items != current:\n            self.combo.blockSignals(True)\n            self.combo.clear()\n            self.combo.addItems(items)\n            self.combo.blockSignals(False)\n\n    def change_topic(self, topic_name: str):\n        if self.sub:\n            self.node.destroy_subscription(self.sub)\n            self.sub = None\n        self.img_item.clear()\n        for lbl in self.wp_labels:\n            self.view_box.removeItem(lbl)\n        self.wp_labels.clear()\n        self.waypoints.clear()\n        self.wp_scatter.setData([])\n        self.wp_line.setData([], [])\n        self._first_map = True\n\n        if topic_name != '---':\n            qos = QoSProfile(depth=1, reliability=ReliabilityPolicy.BEST_EFFORT)\n            self.sub = self.node.create_subscription(\n                OccupancyGrid, topic_name, self.og_callback, qos)\n\n    def og_callback(self, msg: OccupancyGrid):\n        self.map_info = msg.info\n        h, w = self.map_info.height, self.map_info.width\n        data = np.array(msg.data, dtype=np.int8).reshape((h, w))\n\n        img = np.empty((h, w), dtype=np.uint8)\n        img[data == -1] = 127\n        img[data ==  0] = 255\n        img[data ==100] =   0\n\n        self.img_item.setImage(img.T, autoLevels=False)\n        orig = self.map_info.origin.position\n        res = self.map_info.resolution\n        rect = QRectF(orig.x, orig.y, w * res, h * res)\n        self.img_item.setRect(rect)\n\n        if self._first_map:\n            self.view_box.autoRange()\n            self._first_map = False\n\n    def toggle_waypoint_mode(self, checked: bool):\n        if checked:\n            self.btn_waypoints.setStyleSheet(\"background-color: green; color: white;\")\n            self.view_box.scene().sigMouseClicked.connect(self.on_click)\n        else:\n            self.btn_waypoints.setStyleSheet(\"\")\n            self.view_box.scene().sigMouseClicked.disconnect(self.on_click)\n\n    def _refresh_waypoints(self):\n        pts = [{'x': wp[0], 'y': wp[1]} for wp in self.waypoints]\n        self.wp_scatter.setData(pts)\n        if len(self.waypoints) >= 2:\n            xs, ys = zip(*self.waypoints)\n            self.wp_line.setData(xs, ys)\n        else:\n            self.wp_line.setData([], [])\n        for lbl in self.wp_labels:\n            self.view_box.removeItem(lbl)\n        self.wp_labels.clear()\n        for idx, (wx, wy) in enumerate(self.waypoints, start=1):\n            label = TextItem(str(idx), anchor=(0.5, 1.0), fill=pg.mkBrush(50,50,50,200))\n            label.setColor('w')\n            font = QFont(); font.setPointSize(16)\n            label.setFont(font)\n            label.setPos(wx, wy + self.map_info.resolution * 0.1)\n            self.view_box.addItem(label)\n            self.wp_labels.append(label)\n\n    def publish_waypoints(self):\n        if not self.waypoints or self.map_info is None:\n            return\n        path_msg = Path()\n        path_msg.header.stamp = self.node.get_clock().now().to_msg()\n        path_msg.header.frame_id = 'map'\n        path_msg.poses = []\n        for x, y in self.waypoints:\n            ps = PoseStamped(header=path_msg.header)\n            ps.pose.position = Point(x=x, y=y, z=0.0)\n            ps.pose.orientation.w = 1.0\n            path_msg.poses.append(ps)\n        self.wp_pub.publish(path_msg)\n\n    def on_click(self, event):\n        if not self.btn_waypoints.isChecked() or self.map_info is None:\n            return\n        pos = event.scenePos()\n        mp = self.view_box.mapSceneToView(pos)\n        orig = self.map_info.origin.position\n        res = self.map_info.resolution\n        thr = res * 0.5\n        for i, (wx, wy) in enumerate(self.waypoints):\n            if math.hypot(mp.x() - wx, mp.y() - wy) < thr:\n                del self.waypoints[i]\n                self._refresh_waypoints()\n                return\n        ci = int((mp.x() - orig.x) / res)\n        cj = int((mp.y() - orig.y) / res)\n        if 0 <= ci < self.map_info.width and 0 <= cj < self.map_info.height:\n            wx = orig.x + ci * res + res / 2\n            wy = orig.y + cj * res + res / 2\n            self.waypoints.append((wx, wy))\n            self._refresh_waypoints()\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = rclpy.create_node('gridmap_waypoint_viewer_ids')\n    app = QApplication(sys.argv)\n    DarkStyle(app)\n    viewer = GridMapViewer(node)\n    viewer.show()\n    app.exec()\n    node.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()"}\n{"instruction": "Write a ROS2 Python node named setup.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "from setuptools import find_packages, setup\n\npackage_name = 'moveit_path_planning'\n\nsetup(\n    name=package_name,\n    version='0.0.0',\n    packages=find_packages(exclude=['test']),\n    data_files=[\n        ('share/ament_index/resource_index/packages',\n            ['resource/' + package_name]),\n        ('share/' + package_name, ['package.xml']),\n    ],\n    install_requires=['setuptools', 'rclpy'],\n    zip_safe=True,\n    maintainer='sanjay',\n    maintainer_email='sanjay.ramnauth@mail.utoronto.ca',\n    description='TODO: Package description',\n    license='TODO: License declaration',\n    tests_require=['pytest'],\n    entry_points={\n        'console_scripts': [\n            # Replace with your Python node entry point\n            'example_action_client = moveit_path_planning.plan_execute_client_example:main',\n        ],\n    },\n)\n"}\n{"instruction": "Write a ROS2 Python node named moveit_arm_controller.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "\"\"\"MoveIt2 机械臂控制模块：支持关节角度约束（稳健同步版）\"\"\"\n\nimport time\nfrom typing import List, Optional, Dict\n\nimport rclpy\nfrom rclpy.node import Node\nfrom rclpy.action import ActionClient\n\n# 必须导入 JointConstraint\nfrom moveit_msgs.srv import GetCartesianPath\nfrom moveit_msgs.action import MoveGroup, ExecuteTrajectory\nfrom moveit_msgs.msg import (\n    MotionPlanRequest, Constraints, PositionConstraint,\n    OrientationConstraint, JointConstraint, BoundingVolume, RobotTrajectory\n)\nfrom geometry_msgs.msg import Pose\nfrom shape_msgs.msg import SolidPrimitive\nfrom builtin_interfaces.msg import Duration\n\n\nclass MoveItArmController:\n    \"\"\"使用 MoveIt2 的机械臂控制器\"\"\"\n\n    def __init__(self, node: Node, config: dict):\n        self.node = node\n        self.config = config\n        self.logger = node.get_logger()\n\n        # 配置参数\n        moveit_cfg = config.get('moveit', {})\n        self.planning_group = moveit_cfg.get('planning_group', 'ur_manipulator')\n        self.base_frame = config.get('frames', {}).get('robot_base', 'base_link')\n        self.ee_frame = moveit_cfg.get('end_effector_frame', 'tool0')\n        self.planning_time = moveit_cfg.get('planning_time', 5.0)\n        self.velocity_scaling = moveit_cfg.get('velocity_scaling', 0.1)\n        self.acceleration_scaling = moveit_cfg.get('acceleration_scaling', 0.1)\n\n        # Action 客户端\n        # 注意：使用默认回调组 (MutuallyExclusive)，依靠 MultiThreadedExecutor 处理响应\n        self.action_client = ActionClient(node, MoveGroup, '/move_action')\n        \n        # 笛卡尔路径服务\n        self.cartesian_client = node.create_client(\n            GetCartesianPath, '/compute_cartesian_path'\n        )\n\n        self.logger.info(f'MoveIt 控制器初始化完成，规划组: {self.planning_group}')\n\n    def wait_for_server(self, timeout_sec: float = 10.0) -> bool:\n        self.logger.info('等待 MoveIt2 服务器...')\n        if not self.action_client.wait_for_server(timeout_sec=timeout_sec):\n            self.logger.error('MoveAction 连接超时')\n            return False\n        if not self.cartesian_client.wait_for_service(timeout_sec=timeout_sec):\n            self.logger.error('CartesianPath 服务连接超时')\n            return False\n        self.logger.info('MoveIt2 服务器已就绪')\n        return True\n\n    def _wait_for_future(self, future, timeout_sec: float = 10.0):\n        \"\"\"[新增] 稳健的等待函数，替代 spin_once\"\"\"\n        start_time = time.time()\n        while not future.done():\n            if time.time() - start_time > timeout_sec:\n                return None\n            time.sleep(0.01) # 释放 CPU，允许 Executor 的其他线程处理回调\n        return future.result()\n\n    def move_cartesian_path(self, waypoints: List[Pose], step: float = 0.01, speed_factor: float = 0.1) -> bool:\n        \"\"\"执行笛卡尔直线运动\"\"\"\n        if not self.cartesian_client.service_is_ready():\n            self.logger.error('无法连接到 compute_cartesian_path 服务')\n            return False\n\n        req = GetCartesianPath.Request()\n        req.header.frame_id = self.base_frame\n        req.header.stamp = self.node.get_clock().now().to_msg()\n        req.group_name = self.planning_group\n        req.waypoints = waypoints\n        req.max_step = step\n        req.jump_threshold = 0.0 \n        req.avoid_collisions = True\n\n        future = self.cartesian_client.call_async(req)\n        response = self._wait_for_future(future, timeout_sec=5.0)\n\n        if response is None:\n            self.logger.error('笛卡尔路径规划超时')\n            return False\n\n        if response.error_code.val != 1:\n            self.logger.error(f'笛卡尔路径计算失败: {response.error_code.val}')\n            return False\n\n        if response.fraction < 0.90:\n             self.logger.warn(f'笛卡尔路径仅计算了 {response.fraction*100:.1f}%，放弃执行')\n             return False\n\n        # 手动降速\n        slow_trajectory = self._scale_trajectory_speed(response.solution, speed_factor)\n        return self._execute_trajectory(slow_trajectory)\n\n    def _scale_trajectory_speed(self, robot_traj: RobotTrajectory, scale: float) -> RobotTrajectory:\n        \"\"\"手动重新计算时间戳以降低速度\"\"\"\n        joint_traj = robot_traj.joint_trajectory\n        if not joint_traj.points: return robot_traj\n\n        base_speed = 1.5 * scale  # 基准速度 (rad/s)\n        \n        new_points = []\n        current_time = 0.0\n        \n        point0 = joint_traj.points[0]\n        point0.time_from_start = Duration(sec=0, nanosec=0)\n        new_points.append(point0)\n\n        for i in range(1, len(joint_traj.points)):\n            prev_p = joint_traj.points[i-1]\n            curr_p = joint_traj.points[i]\n            \n            max_delta = 0.0\n            for j in range(len(curr_p.positions)):\n                delta = abs(curr_p.positions[j] - prev_p.positions[j])\n                max_delta = max(max_delta, delta)\n            \n            dt = max_delta / base_speed\n            dt = max(dt, 0.05) # 最小时间间隔\n\n            current_time += dt\n            \n            sec = int(current_time)\n            nanosec = int((current_time - sec) * 1e9)\n            curr_p.time_from_start = Duration(sec=sec, nanosec=nanosec)\n            curr_p.velocities = []\n            curr_p.accelerations = []\n            curr_p.effort = []\n            new_points.append(curr_p)\n\n        robot_traj.joint_trajectory.points = new_points\n        return robot_traj\n\n    def _execute_trajectory(self, robot_trajectory) -> bool:\n        if not hasattr(self, 'exec_traj_client'):\n            self.exec_traj_client = ActionClient(self.node, ExecuteTrajectory, '/execute_trajectory')\n        \n        if not self.exec_traj_client.wait_for_server(timeout_sec=2.0): return False\n\n        goal = ExecuteTrajectory.Goal()\n        goal.trajectory = robot_trajectory\n        \n        self.logger.info('开始执行轨迹...')\n        future = self.exec_traj_client.send_goal_async(goal)\n        \n        goal_handle = self._wait_for_future(future, timeout_sec=5.0)\n\n        if goal_handle is None:\n            self.logger.error('轨迹执行请求超时或返回 None')\n            return False\n\n        if not goal_handle.accepted:\n            self.logger.error('轨迹目标被拒绝')\n            return False\n            \n        res_future = goal_handle.get_result_async()\n        res = self._wait_for_future(res_future, timeout_sec=15.0)\n        \n        if res is None:\n            self.logger.error('等待轨迹执行结果超时')\n            return False\n\n        return res.result.error_code.val == 1\n\n    def move_to_pose_sync(\n        self, \n        target_pose: Pose, \n        velocity_scaling=None, \n        joint_limits: Optional[Dict[str, tuple]] = None\n    ) -> bool:\n        \"\"\"\n        PTP 移动，支持关节约束 (修复：安全等待，处理 None)\n        \"\"\"\n        if velocity_scaling is None: velocity_scaling = self.velocity_scaling\n\n        goal = MoveGroup.Goal()\n        goal.request = self._create_motion_plan_request(\n            target_pose, velocity_scaling, self.acceleration_scaling, joint_limits\n        )\n        goal.planning_options.plan_only = False\n        goal.planning_options.replan = True\n        \n        self.logger.info('规划路径 (Smart PTP)...')\n        future = self.action_client.send_goal_async(goal)\n        \n        # [关键修复] 增加 None 检查\n        goal_handle = self._wait_for_future(future, timeout_sec=10.0)\n\n        if goal_handle is None:\n            self.logger.error('PTP 规划请求失败：未收到 Goal Handle (超时或连接错误)')\n            return False\n\n        if not goal_handle.accepted:\n            self.logger.error('PTP 规划请求被拒绝 (目标点不可达或违反约束)')\n            return False\n        \n        self.logger.info('规划请求已接受，正在执行...')\n        res_future = goal_handle.get_result_async()\n        res = self._wait_for_future(res_future, timeout_sec=20.0)\n\n        if res is None:\n            self.logger.error('PTP 动作执行超时')\n            return False\n\n        if res.result.error_code.val == 1:\n            return True\n        else:\n            self.logger.error(f'MoveIt 错误码: {res.result.error_code.val}')\n            return False\n\n    def _create_motion_plan_request(\n        self, target_pose, v_scale, a_scale, \n        joint_limits: Optional[Dict[str, tuple]] = None\n    ):\n        req = MotionPlanRequest()\n        req.group_name = self.planning_group\n        req.max_velocity_scaling_factor = v_scale\n        req.max_acceleration_scaling_factor = a_scale\n        req.num_planning_attempts = 5 # 增加尝试次数\n        req.allowed_planning_time = self.planning_time\n        \n        c = Constraints()\n        \n        # 1. 位置约束\n        pc = PositionConstraint()\n        pc.header.frame_id = self.base_frame\n        pc.link_name = self.ee_frame\n        bv = BoundingVolume()\n        sp = SolidPrimitive()\n        sp.type = SolidPrimitive.SPHERE\n        sp.dimensions = [0.005] # 放宽一点点容差，防止太严苛\n        bv.primitives.append(sp)\n        p = Pose(); p.position = target_pose.position; p.orientation.w=1.0\n        bv.primitive_poses.append(p)\n        pc.constraint_region = bv\n        pc.weight = 1.0\n        c.position_constraints.append(pc)\n        \n        # 2. 姿态约束\n        oc = OrientationConstraint()\n        oc.header.frame_id = self.base_frame\n        oc.link_name = self.ee_frame\n        oc.orientation = target_pose.orientation\n        oc.absolute_x_axis_tolerance = 0.05 # 放宽容差\n        oc.absolute_y_axis_tolerance = 0.05\n        oc.absolute_z_axis_tolerance = 0.05\n        oc.weight = 1.0\n        c.orientation_constraints.append(oc)\n\n        # 3. 关节约束\n        if joint_limits:\n            for name, (min_val, max_val) in joint_limits.items():\n                jc = JointConstraint()\n                jc.joint_name = name\n                jc.position = (min_val + max_val) / 2.0\n                jc.tolerance_above = (max_val - min_val) / 2.0\n                jc.tolerance_below = (max_val - min_val) / 2.0\n                jc.weight = 1.0\n                c.joint_constraints.append(jc)\n        \n        req.goal_constraints.append(c)\n        return req\n\n    def is_ready(self) -> bool:\n        return self.action_client.server_is_ready()"}\n{"instruction": "Write a ROS2 Python node named MotionPlanner.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "#!/usr/bin/env python3\nfrom time import sleep\n\nfrom numpy import true_divide\nfrom robot.robot_controllers.robot_boot_manager import robot_launch, robot_close\nfrom robot.tools.errorhandling import handle_error\nfrom robot.robot_controllers.Wafflebot.moveit.create_motion_plan_request import create_motion_plan_request\nfrom robot.robot_controllers.Wafflebot.moveit.create_collisionobjects import CollisionObjectPublisher\nfrom robot.tools.file_manipulation import Jsonreader\n\nimport rclpy\nfrom rclpy.node import Node\nimport rclpy.action\nimport rclpy.subscription\n\nfrom moveit_msgs.srv import GetMotionPlan\nfrom sensor_msgs.msg import JointState\nfrom control_msgs.action import FollowJointTrajectory\nfrom trajectory_msgs.msg import JointTrajectory\n    \n\n\nclass MotionPlanner(Node):\n    def __init__(self, interbotix_moveit_process):\n        #name node:\n        super().__init__('vx300s_motion_planner')\n        # Store Process of interbotix (TODO add this feature to wafflebot)\n        self.interbotix_moveit_process = interbotix_moveit_process\n        self.group_name = \"interbotix_arm\"\n        # Create ros clients\n        self.planning_client = self.create_client(GetMotionPlan, '/plan_kinematic_path')\n        self.exec_action_client = rclpy.action.ActionClient(\n            self, FollowJointTrajectory, '/vx300s/arm_controller/follow_joint_trajectory'\n        )\n        self.joint_state_subscriber = self.create_subscription(\n            JointState, \"/vx300s/joint_states\", self._update_joint_state, 10\n            )\n        # Check if clients have loaded successfully\n        if not self.planning_client.wait_for_service(timeout_sec=10.0):\n            raise RuntimeError (\"Planning service would not load. Please restart. If problem persists, please reboot.\")\n        if not self.exec_action_client.wait_for_server(timeout_sec=10.0):\n            raise RuntimeError (\"Execution service would not load. Please restart. If problem persists, please reboot.\")\n        \n        self.moving = False\n        self.target_pose_matrix = None\n        self.joint_states = None\n        self.gripper_state = None\n        self.update_count = 0\n        self.movement_success =False \n        self.blocking = True\n        \n\n    def update_joint_states(self):\n        update_count = self.update_count\n        while update_count == self.update_count:\n            rclpy.spin_once(self)\n        return self.joint_states\n\n    def _update_joint_state(self, joint_states: JointState):\n        self.update_count +=1\n        # nip overflow errors in the bud\n        if self.update_count > 10_000:\n            self.update_count = 0    \n        self.joint_states = list(joint_states.position)[:6]\n        self.gripper_state = list(joint_states.position)[-1]\n        return\n\n    \n    def move(self, \n             target: list[list[float]],\n             speed_scaling: float = 1.0,\n             blocking: bool = True,\n             ) -> None: \n        if self.moving:\n            print(\"already moving\")\n            self.movement_success = False\n            return\n            \n        self.moving = True\n        if not blocking:\n            self.blocking = False\n        self.update_joint_states()\n        start_state = self.joint_states\n   \n        self.planning_request(start_state, target, speed_scaling)\n        while self.moving:\n            rclpy.spin_once(self)\n\n    def planning_request(self, start_state, goal_state, speed_scaling):\n        mp_request = create_motion_plan_request(start_state, goal_state, speed_scaling) \n        motionplan_future = self.planning_client.call_async(mp_request)\n        motionplan_future.add_done_callback(self.planning_callback)\n\n    def planning_callback(self, future):\n        try:\n            response = future.result()\n            if response.motion_plan_response.error_code.val == 1: # Error code 1 means success. Anything else is a failure\n                target_trajectory = response.motion_plan_response.trajectory.joint_trajectory\n                self.execute_trajectory_request(target_trajectory)\n            else:\n                self.moving = False\n                self.movement_success = False\n                return False\n        except Exception as e:\n            self.moving = False\n            self.movement_success = False\n            print(\"Motion planner broke UwU\")\n            print(e.with_traceback())\n            return \"Motion planner broke UwU\" \n    \n\n    def execute_trajectory_request(self, trajectory: JointTrajectory):\n        # Sends ROS request to execute the planned trajectory\n        goal_msg = FollowJointTrajectory.Goal()\n        goal_msg.trajectory = trajectory\n        send_goal_future = self.exec_action_client.send_goal_async(goal_msg)\n        send_goal_future.add_done_callback(self.execute_trajectory_callback)\n\n    def execute_trajectory_callback(self, future):\n        # if path approved, prepare trajectory finished. Else assume world has burned down.\n        try:\n            goal_handle = future.result()\n            if not goal_handle.accepted:\n                self.moving = False\n                self.movement_success = False\n                return False\n            if not self.blocking:\n                sleep(0.1)\n                self.blocking = True\n                self.moving = False\n                self.movement_success = True\n                return True\n            else:\n                goal_handle.get_result_async().add_done_callback(self.trajectory_finished_callback)\n        except Exception as e:\n            self.moving = False\n            self.movement_success = False\n            print(e.with_traceback())\n            return \"Motion planner broke UwU\" \n            \n    def trajectory_finished_callback(self, future):\n        try:\n            _ = future.result().result\n            self.moving = False\n            self.movement_success = True\n            return True\n        except Exception as e:\n            self.movement_success = False\n            self.moving = False\n            print(f\"Execution result failed: {e}\")\n    \n    def __del__(self):\n        self.shutdown_node()\n\n    def shutdown_node(self):\n        # Terminate the MoveIt interface process if it's still running.\n        if self.interbotix_moveit_process.poll() is None:\n            self.interbotix_moveit_process.terminate()\n        self.destroy_node()\n\n\n\ndef main():\n\n\n    rclpy.init()\n    interbotix_moveit_process = robot_launch(use_real_robot=0)\n    node = MotionPlanner(interbotix_moveit_process)\n    sleep(6)\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        node.get_logger().info(\"Shutting down node due to keyboard interrupt...\")\n    finally:\n        if rclpy.ok():\n            node.shutdown_node()\n            node.destroy_node()\n            rclpy.shutdown()\n\n    return\n\n\n\n\nif __name__ == \"__main__\":\n    try:\n        main()\n    except Exception as e:\n        handle_error(e)\n    finally:\n        if rclpy.ok():\n            robot_close()\n\n\n"}\n{"instruction": "Write a ROS2 Python node named example_move.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "#!/usr/bin/env python3\n# Copyright (c) 2024 FZI Forschungszentrum Informatik\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#\n#    * Redistributions of source code must retain the above copyright\n#      notice, this list of conditions and the following disclaimer.\n#\n#    * Redistributions in binary form must reproduce the above copyright\n#      notice, this list of conditions and the following disclaimer in the\n#      documentation and/or other materials provided with the distribution.\n#\n#    * Neither the name of the {copyright_holder} nor the names of its\n#      contributors may be used to endorse or promote products derived from\n#      this software without specific prior written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n# POSSIBILITY OF SUCH DAMAGE.\n\n#\n# Author: Felix Exner\n\n# This is an example of how to interface the robot without any additional ROS components. For\n# real-life applications, we do recommend to use something like MoveIt!\n\nimport time\n\nimport rclpy\nfrom rclpy.action import ActionClient\n\nfrom builtin_interfaces.msg import Duration\nfrom action_msgs.msg import GoalStatus\nfrom trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint\nfrom control_msgs.action import FollowJointTrajectory\nfrom control_msgs.msg import JointTolerance\n\nTRAJECTORIES = {\n    \"traj0\": [\n        {\n            \"positions\": [0.043128, -1.28824, 1.37179, -1.82208, -1.63632, -0.18],\n            \"velocities\": [0, 0, 0, 0, 0, 0],\n            \"time_from_start\": Duration(sec=4, nanosec=0),\n        },\n        {\n            \"positions\": [-0.195016, -1.70093, 0.902027, -0.944217, -1.52982, -0.195171],\n            \"velocities\": [0, 0, 0, 0, 0, 0],\n            \"time_from_start\": Duration(sec=8, nanosec=0),\n        },\n    ],\n    \"traj1\": [\n        {\n            \"positions\": [-0.195016, -1.70094, 0.902027, -0.944217, -1.52982, -0.195171],\n            \"velocities\": [0, 0, 0, 0, 0, 0],\n            \"time_from_start\": Duration(sec=0, nanosec=0),\n        },\n        {\n            \"positions\": [0.30493, -0.982258, 0.955637, -1.48215, -1.72737, 0.204445],\n            \"velocities\": [0, 0, 0, 0, 0, 0],\n            \"time_from_start\": Duration(sec=8, nanosec=0),\n        },\n    ],\n}\n\n\nclass JTCClient(rclpy.node.Node):\n    \"\"\"Small test client for the jtc.\"\"\"\n\n    def __init__(self):\n        super().__init__(\"jtc_client\")\n        self.declare_parameter(\"controller_name\", \"scaled_joint_trajectory_controller\")\n        self.declare_parameter(\n            \"joints\",\n            [\n                \"shoulder_pan_joint\",\n                \"shoulder_lift_joint\",\n                \"elbow_joint\",\n                \"wrist_1_joint\",\n                \"wrist_2_joint\",\n                \"wrist_3_joint\",\n            ],\n        )\n\n        controller_name = self.get_parameter(\"controller_name\").value + \"/follow_joint_trajectory\"\n        self.joints = self.get_parameter(\"joints\").value\n\n        if self.joints is None or len(self.joints) == 0:\n            raise Exception('\"joints\" parameter is required')\n\n        self._action_client = ActionClient(self, FollowJointTrajectory, controller_name)\n        self.get_logger().info(f\"Waiting for action server on {controller_name}\")\n        self._action_client.wait_for_server()\n\n        self.parse_trajectories()\n        self.i = 0\n        self._send_goal_future = None\n        self._get_result_future = None\n        self.execute_next_trajectory()\n\n    def parse_trajectories(self):\n        self.goals = {}\n\n        for traj_name in TRAJECTORIES:\n            goal = JointTrajectory()\n            goal.joint_names = self.joints\n            for pt in TRAJECTORIES[traj_name]:\n                point = JointTrajectoryPoint()\n                point.positions = pt[\"positions\"]\n                point.velocities = pt[\"velocities\"]\n                point.time_from_start = pt[\"time_from_start\"]\n                goal.points.append(point)\n\n            self.goals[traj_name] = goal\n\n    def execute_next_trajectory(self):\n        if self.i >= len(self.goals):\n            self.get_logger().info(\"Done with all trajectories\")\n            raise SystemExit\n        traj_name = list(self.goals)[self.i]\n        self.i = self.i + 1\n        if traj_name:\n            self.execute_trajectory(traj_name)\n\n    def execute_trajectory(self, traj_name):\n        self.get_logger().info(f\"Executing trajectory {traj_name}\")\n        goal = FollowJointTrajectory.Goal()\n        goal.trajectory = self.goals[traj_name]\n\n        goal.goal_time_tolerance = Duration(sec=0, nanosec=500000000)\n        goal.goal_tolerance = [\n            JointTolerance(position=0.01, velocity=0.01, name=self.joints[i]) for i in range(6)\n        ]\n\n        self._send_goal_future = self._action_client.send_goal_async(goal)\n        self._send_goal_future.add_done_callback(self.goal_response_callback)\n\n    def goal_response_callback(self, future):\n        goal_handle = future.result()\n        if not goal_handle.accepted:\n            self.get_logger().error(\"Goal rejected :(\")\n            raise RuntimeError(\"Goal rejected :(\")\n\n        self.get_logger().debug(\"Goal accepted :)\")\n\n        self._get_result_future = goal_handle.get_result_async()\n        self._get_result_future.add_done_callback(self.get_result_callback)\n\n    def get_result_callback(self, future):\n        result = future.result().result\n        status = future.result().status\n        self.get_logger().info(f\"Done with result: {self.status_to_str(status)}\")\n        if status == GoalStatus.STATUS_SUCCEEDED:\n            time.sleep(2)\n            self.execute_next_trajectory()\n        else:\n            if result.error_code != FollowJointTrajectory.Result.SUCCESSFUL:\n                self.get_logger().error(\n                    f\"Done with result: {self.error_code_to_str(result.error_code)}\"\n                )\n            raise RuntimeError(\"Executing trajectory failed. \" + result.error_string)\n\n    @staticmethod\n    def error_code_to_str(error_code):\n        if error_code == FollowJointTrajectory.Result.SUCCESSFUL:\n            return \"SUCCESSFUL\"\n        if error_code == FollowJointTrajectory.Result.INVALID_GOAL:\n            return \"INVALID_GOAL\"\n        if error_code == FollowJointTrajectory.Result.INVALID_JOINTS:\n            return \"INVALID_JOINTS\"\n        if error_code == FollowJointTrajectory.Result.OLD_HEADER_TIMESTAMP:\n            return \"OLD_HEADER_TIMESTAMP\"\n        if error_code == FollowJointTrajectory.Result.PATH_TOLERANCE_VIOLATED:\n            return \"PATH_TOLERANCE_VIOLATED\"\n        if error_code == FollowJointTrajectory.Result.GOAL_TOLERANCE_VIOLATED:\n            return \"GOAL_TOLERANCE_VIOLATED\"\n\n    @staticmethod\n    def status_to_str(error_code):\n        if error_code == GoalStatus.STATUS_UNKNOWN:\n            return \"UNKNOWN\"\n        if error_code == GoalStatus.STATUS_ACCEPTED:\n            return \"ACCEPTED\"\n        if error_code == GoalStatus.STATUS_EXECUTING:\n            return \"EXECUTING\"\n        if error_code == GoalStatus.STATUS_CANCELING:\n            return \"CANCELING\"\n        if error_code == GoalStatus.STATUS_SUCCEEDED:\n            return \"SUCCEEDED\"\n        if error_code == GoalStatus.STATUS_CANCELED:\n            return \"CANCELED\"\n        if error_code == GoalStatus.STATUS_ABORTED:\n            return \"ABORTED\"\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    jtc_client = JTCClient()\n    try:\n        rclpy.spin(jtc_client)\n    except RuntimeError as err:\n        jtc_client.get_logger().error(str(err))\n    except SystemExit:\n        rclpy.logging.get_logger(\"jtc_client\").info(\"Done\")\n\n    rclpy.shutdown()\n\n\nif __name__ == \"__main__\":\n    main()\n"}\n{"instruction": "Write a ROS2 Python node named template.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "#!/usr/bin/env python3\n\"\"\"\nTemplate for controlling PhantomX Pincher with your Python scripts.\n- ros2 run phantomx_pincher_demos template.py\n\"\"\"\n\nfrom threading import Thread\n\nimport rclpy\nfrom pymoveit2 import GripperInterface, MoveIt2\nfrom pymoveit2.robots import phantomx_pincher\nfrom rclpy.callback_groups import ReentrantCallbackGroup\nfrom rclpy.node import Node\n\n\ndef main():\n    rclpy.init()\n\n    # Create node for this example\n    node = Node(\"phantomx_pincher_template\")\n\n    # Create callback group that allows execution of callbacks in parallel without restrictions\n    callback_group = ReentrantCallbackGroup()\n\n    # Create MoveIt 2 interfaces\n    moveit2 = MoveIt2(\n        node=node,\n        joint_names=phantomx_pincher.joint_names(),\n        base_link_name=phantomx_pincher.base_link_name(),\n        end_effector_name=phantomx_pincher.end_effector_name(),\n        group_name=phantomx_pincher.MOVE_GROUP_ARM,\n        callback_group=callback_group,\n        execute_via_moveit=True,\n    )\n    gripper = GripperInterface(\n        node=node,\n        gripper_joint_names=phantomx_pincher.gripper_joint_names(),\n        open_gripper_joint_positions=phantomx_pincher.OPEN_GRIPPER_JOINT_POSITIONS,\n        closed_gripper_joint_positions=phantomx_pincher.CLOSED_GRIPPER_JOINT_POSITIONS,\n        gripper_group_name=phantomx_pincher.MOVE_GROUP_GRIPPER,\n        callback_group=callback_group,\n        execute_via_moveit=True,\n    )\n\n    # Spin the node in background thread(s) and wait a bit for initialization\n    executor = rclpy.executors.MultiThreadedExecutor(2)\n    executor.add_node(node)\n    executor_thread = Thread(target=executor.spin, daemon=True, args=())\n    executor_thread.start()\n    node.create_rate(1.0).sleep()\n\n    # Scale down velocity and acceleration of joints (percentage of maximum)\n    moveit2.max_velocity = 0.25\n    moveit2.max_acceleration = 0.25\n\n    ##\n    # TODO: Make your changes here\n    ##\n\n    rclpy.shutdown()\n    executor_thread.join()\n    exit(0)\n\n\nif __name__ == \"__main__\":\n    main()\n"}\n{"instruction": "Write a ROS2 Python node named moveit2.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "\"\"\"\nA simple python interface with MoveIt2 services (and actions). This is an alternative to\nmoveit_commander, which is not yet ported to ROS 2 (as of Oct 2020).\nNote: This module is currently configured for Franka Emika Panda robot.\nNote: There is no Ignition-specific code in this module (this repo is just a convinient place).\n\nthe code is from https://github.com/AndrejOrsula/ign_moveit2 ,and is modified.\n\"\"\"\n\nimport threading\n\nimport rclpy\nfrom rclpy.node import Node\nfrom rclpy.action import ActionClient\n\nfrom std_msgs.msg import Float32\nfrom builtin_interfaces.msg import Duration\nfrom geometry_msgs.msg import Pose, Quaternion\nfrom shape_msgs.msg import SolidPrimitive\nfrom sensor_msgs.msg import JointState\nfrom trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint\nfrom moveit_msgs.msg import Constraints, JointConstraint, PositionConstraint, OrientationConstraint\nfrom moveit_msgs.msg import PositionIKRequest, RobotTrajectory\nfrom moveit_msgs.srv import GetPositionIK, GetPositionFK, GetMotionPlan, GetCartesianPath\nfrom moveit_msgs.action import MoveGroup\nfrom action_msgs.msg import GoalStatus\n\n\nclass MoveIt2Interface(Node):\n\n    def __init__(self):\n        super().__init__(\"ign_moveit2_py\")\n        self.init_robot()\n        self.init_compute_fk()\n        self.init_compute_ik()\n        self.init_plan_kinematic_path()\n        self.init_plan_cartesian_path()\n        self.get_logger().info(\"ign_moveit2_py initialised successfuly\")\n\n    def init_robot(self):\n        \"\"\"\n        Initialise robot groups, links and joints. This would normally get loaded from URDF via\n        `moveit_commander`.\n        This also initialises subscriber to joint states and publisher to joint trajectories.\n        \"\"\"\n        self.robot_group_name = \"ur10\"\n        # Arm\n        self.arm_group_name = \"manipulator\"\n        self.arm_joints = [\"shoulder_pan_joint\",\n                           \"shoulder_lift_joint\",\n                           \"elbow_joint\",\n                           \"wrist_1_joint\",\n                           \"wrist_2_joint\",\n                           \"wrist_3_joint\"]\n        self.arm_links = [\n                          \"shoulder_link\",\n                          \"upper_arm_link\",\n                          \"forearm_link\",\n                          \"wrist_1_link\",\n                          \"wrist_2_link\",\n                          \"wrist_3_link\"]\n        self.arm_base_link = self.arm_links[0]\n        self.arm_end_effector = self.arm_links[-1]\n\n        # Publisher of trajectories\n        self.joint_trajectory_pub = self.create_publisher(JointTrajectory,\n                                                          \"set_joint_trajectory\", 1)\n\n        # Subscriber of current joint states\n        self.joint_state = JointState()\n        self.joint_state_mutex = threading.Lock()\n        self.joint_state_sub = self.create_subscription(JointState,\n                                                        \"joint_states\",\n                                                        self.joint_state_callback, 1)\n\n        # Subscriber of joint trajectory progress\n        self.joint_progress = 1.0\n        self.joint_progress_cond = threading.Condition()\n        self.joint_progress_sub = self.create_subscription(Float32,\n                                                           \"joint_trajectory_progress\",\n                                                           self.joint_progress_callback, 1)\n\n    def joint_state_callback(self, msg):\n        \"\"\"\n        Callback for getting current joint states.\n        \"\"\"\n        self.joint_state_mutex.acquire()\n        self.joint_state = msg\n        self.joint_state_mutex.release()\n\n    def get_joint_state(self) -> JointState:\n        \"\"\"\n        Get current joint states.\n        \"\"\"\n        self.joint_state_mutex.acquire()\n        joint_state = self.joint_state\n        self.joint_state_mutex.release()\n        return joint_state\n\n    def joint_progress_callback(self, msg):\n        \"\"\"\n        Callback for getting joint trajectory progress.\n        \"\"\"\n        with self.joint_progress_cond:\n            self.joint_progress = msg.data\n            self.joint_progress_cond.notify_all()\n\n    def wait_until_executed(self):\n        \"\"\"\n        Function that halts execution on the current thread until trajectory is executed.\n        \"\"\"\n        with self.joint_progress_cond:\n            while not self.joint_progress == 1.0:\n                self.joint_progress_cond.wait(timeout=0.5)\n\n    def pub_trajectory(self, trajectory):\n        \"\"\"\n        Publish trajectory such that it can be executed, e.g. by `JointTrajectoryController`\n        Ignition plugin.\n        \"\"\"\n        if isinstance(trajectory, JointTrajectory):\n            self.joint_trajectory_pub.publish(trajectory)\n            self.get_logger().info(\"pub trajectory msg!\")\n        elif isinstance(trajectory, RobotTrajectory):\n            self.joint_trajectory_pub.publish(trajectory.joint_trajectory)\n        else:\n            raise Exception(\"Invalid type passed into pub_trajectory()\")\n\n    def execute(self, joint_trajectory=None) -> bool:\n        \"\"\"\n        Execute last planned motion plan, or the `joint_trajectory` specified as argument.\n        \"\"\"\n\n        if joint_trajectory == None:\n            plan = self.motion_plan_.joint_trajectory\n        else:\n            plan = joint_trajectory\n\n        # Make sure there is a plan to follow\n        if not plan.points:\n            self.get_logger().warn(\n                \"Cannot execute motion plan because it does not contain any trajectory points\")\n            return False\n\n        # Reset joint progress\n        self.joint_progress = 0.0\n\n        self.pub_trajectory(plan)\n        return True\n\n    def move_to_joint_state(self, joint_state,\n                            set_position=True,\n                            set_velocity=True,\n                            set_effort=True):\n        \"\"\"\n        Set joint target on all joints defined in `joint_state`. This function does NOT plan a\n        smooth trajectory and only publishes joint_state as the next goal that should be reached\n        immediately.\n        \"\"\"\n        joint_trajectory = JointTrajectory()\n        joint_trajectory.joint_names = joint_state.name\n\n        point = JointTrajectoryPoint()\n        if set_position:\n            point.positions = joint_state.position\n        if set_velocity:\n            point.velocities = joint_state.velocity\n        if set_effort:\n            point.effort = joint_state.effort\n        joint_trajectory.points.append(point)\n\n        self.pub_trajectory(joint_trajectory)\n\n    # compute_fk\n    def init_compute_fk(self):\n        \"\"\"\n        Initialise `compute_fk` service.\n        \"\"\"\n        self.compute_fk_client = self.create_client(GetPositionFK,\n                                                    \"compute_fk\")\n        while not self.compute_fk_client.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info(\n                \"Service [compute_fk] not currently available, waiting...\")\n\n        self.fk_request = GetPositionFK.Request()\n        self.fk_request.header.frame_id = self.arm_base_link\n        # self.fk_request.header.stamp = \"Set during request\"\n        # self.fk_request.fk_link_names = \"Set during request\"\n        # self.fk_request.robot_state.joint_state = \"Set during request\"\n        # self.fk_request.robot_state.multi_dof_joint_state = \"Ignored\"\n        # self.fk_request.robot_state.attached_collision_objects = \"Ignored\"\n        self.fk_request.robot_state.is_diff = False\n\n    def compute_fk(self, fk_link_names=None, joint_state=None) -> GetPositionFK.Response:\n        \"\"\"\n        Call `compute_fk` service.\n        \"\"\"\n        if fk_link_names == None:\n            self.fk_request.fk_link_names = [self.arm_end_effector]\n        else:\n            self.fk_request.fk_link_names = fk_link_names\n\n        if joint_state == None:\n            self.fk_request.robot_state.joint_state = self.get_joint_state()\n        else:\n            self.fk_request.robot_state.joint_state = joint_state\n\n        self.fk_request.header.stamp = self._clock.now().to_msg()\n\n        self.compute_fk_client.wait_for_service()\n        return self.compute_fk_client.call(self.fk_request)\n\n    # compute_ik\n    def init_compute_ik(self):\n        \"\"\"\n        Initialise `compute_ik` service.\n        \"\"\"\n        # Service client for IK\n        self.compute_ik_client = self.create_client(GetPositionIK,\n                                                    \"compute_ik\")\n        while not self.compute_ik_client.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info(\n                \"Service [compute_ik] not currently available, waiting...\")\n\n        self.ik_request = GetPositionIK.Request()\n        self.ik_request.ik_request.group_name = self.arm_group_name\n        # self.ik_request.ik_request.robot_state.joint_state = \"Set during request\"\n        # self.ik_request.ik_request.robot_state.multi_dof_joint_state = \"Ignored\"\n        # self.ik_request.ik_request.robot_state.attached_collision_objects = \"Ignored\"\n        self.ik_request.ik_request.robot_state.is_diff = False\n        # self.ik_request.ik_request.constraints = \"Set during request OR Ignored\"\n        self.ik_request.ik_request.avoid_collisions = True\n        # self.ik_request.ik_request.ik_link_name = \"Ignored\"\n        self.ik_request.ik_request.pose_stamped.header.frame_id = self.arm_base_link\n        # self.ik_request.ik_request.pose_stamped.header.stamp = \"Set during request\"\n        # self.ik_request.ik_request.pose_stamped.pose = \"Set during request\"\n        # self.ik_request.ik_request.ik_link_names = \"Ignored\"\n        # self.ik_request.ik_request.pose_stamped_vector = \"Ignored\"\n        # self.ik_request.ik_request.timeout.sec = \"Ignored\"\n        # self.ik_request.ik_request.timeout.nanosec = \"Ignored\"\n\n    def compute_ik(self, pose, start_joint_state=None, constrains=None) -> GetPositionIK.Response:\n        \"\"\"\n        Call `compute_ik` service.\n        \"\"\"\n        if start_joint_state == None:\n            self.ik_request.ik_request.robot_state.joint_state = self.get_joint_state()\n        else:\n            self.ik_request.ik_request.robot_state.joint_state = start_joint_state\n\n        if constrains != None:\n            self.ik_request.ik_request.constraints = constrains\n\n        self.ik_request.ik_request.pose_stamped.pose = pose\n\n        self.ik_request.ik_request.pose_stamped.header.stamp = self._clock.now().to_msg()\n\n        self.compute_ik_client.wait_for_service()\n        return self.compute_ik_client.call(self.ik_request)\n\n    # plan_kinematic_path\n    def init_plan_kinematic_path(self):\n        \"\"\"\n        Initialise `plan_kinematic_path` service.\n        \"\"\"\n        # Service client for IK\n        self.plan_kinematic_path_client = self.create_client(GetMotionPlan,\n                                                             \"plan_kinematic_path\")\n        while not self.plan_kinematic_path_client.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info(\n                \"Service [plan_kinematic_path] not currently available, waiting...\")\n\n        self.kinematic_path_request = GetMotionPlan.Request()\n        self.kinematic_path_request.motion_plan_request.workspace_parameters.header.frame_id = \\\n            self.arm_base_link\n        # self.kinematic_path_request.motion_plan_request.workspace_parameters.header.stamp = \\\n        # \"Set during request\"\n        self.kinematic_path_request.motion_plan_request.workspace_parameters.min_corner.x = -0.855\n        self.kinematic_path_request.motion_plan_request.workspace_parameters.min_corner.y = -0.855\n        self.kinematic_path_request.motion_plan_request.workspace_parameters.min_corner.z = -0.36\n        self.kinematic_path_request.motion_plan_request.workspace_parameters.max_corner.x = 0.855\n        self.kinematic_path_request.motion_plan_request.workspace_parameters.max_corner.y = 0.855\n        self.kinematic_path_request.motion_plan_request.workspace_parameters.max_corner.z = 1.19\n        # self.kinematic_path_request.motion_plan_request.start_state = \"Ignored\"\n        self.kinematic_path_request.motion_plan_request.goal_constraints = \\\n            [Constraints()]\n        # self.kinematic_path_request.motion_plan_request.path_constraints = \"Ignored\"\n        # self.kinematic_path_request.motion_plan_request.trajectory_constraints = \"Ignored\"\n        # self.kinematic_path_request.motion_plan_request.reference_trajectories = \"Ignored\"\n        # self.kinematic_path_request.motion_plan_request.planner_id = \"Ignored\"\n        self.kinematic_path_request.motion_plan_request.group_name = self.arm_group_name\n        # self.kinematic_path_request.motion_plan_request.num_planning_attempts = \\\n        # \"Set during request\"\n        # self.kinematic_path_request.motion_plan_request.allowed_planning_time = \\\n        # \"Set during request\"\n        self.kinematic_path_request.motion_plan_request.max_velocity_scaling_factor = 0.0\n        self.kinematic_path_request.motion_plan_request.max_acceleration_scaling_factor = 0.0\n        self.kinematic_path_request.motion_plan_request.cartesian_speed_end_effector_link = \\\n            self.arm_end_effector\n        self.kinematic_path_request.motion_plan_request.max_cartesian_speed = 0.0\n\n    def set_max_velocity(self, scaling_factor):\n        \"\"\"\n        Set maximum velocity of joints as a factor of joint limits.\n        \"\"\"\n        self.kinematic_path_request.motion_plan_request.max_velocity_scaling_factor = scaling_factor\n\n    def set_max_acceleration(self, scaling_factor):\n        \"\"\"\n        Set maximum acceleration of joints as a factor of joint limits.\n        \"\"\"\n        self.kinematic_path_request.motion_plan_request.max_acceleration_scaling_factor = \\\n            scaling_factor\n\n    def set_max_cartesian_speed(self, speed):\n        \"\"\"\n        Set maximum cartesian speed of end effector.\n        \"\"\"\n        self.kinematic_path_request.motion_plan_request.max_cartesian_speed = speed\n\n    def plan_kinematic_path(self,\n                            allowed_planning_time=5.0,\n                            num_planning_attempts=10) -> GetMotionPlan.Response:\n        \"\"\"\n        Call `plan_kinematic_path` service, with goal set using either `set_joint_goal()`,\n        `set_position_goal()`, `set_orientation_goal()` or `set_pose_goal()`.\n        \"\"\"\n\n        self.kinematic_path_request.motion_plan_request.num_planning_attempts = \\\n            num_planning_attempts\n        self.kinematic_path_request.motion_plan_request.allowed_planning_time = \\\n            allowed_planning_time\n\n        self.kinematic_path_request.motion_plan_request.workspace_parameters.header.stamp = \\\n            self._clock.now().to_msg()\n\n        # Stamp message with current time\n        clock_time_now_msg = self._clock.now().to_msg()\n        self.kinematic_path_request.motion_plan_request.workspace_parameters.header.stamp = \\\n            clock_time_now_msg\n        for contraints in self.kinematic_path_request.motion_plan_request.goal_constraints:\n            for position_constraint in contraints.position_constraints:\n                position_constraint.header.stamp = clock_time_now_msg\n            for orientation_constraint in contraints.orientation_constraints:\n                orientation_constraint.header.stamp = clock_time_now_msg\n\n        self.plan_kinematic_path_client.wait_for_service()\n        response = self.plan_kinematic_path_client.call(\n            self.kinematic_path_request)\n\n        self.clear_goal_constraints()\n        self.motion_plan_ = response.motion_plan_response.trajectory\n\n        return response\n\n    def clear_goal_constraints(self):\n        \"\"\"\n        Clear all goal constraints that were previously set.\n        Note that this function is called automatically after each `plan_kinematic_path()`.\n        \"\"\"\n        self.kinematic_path_request.motion_plan_request.goal_constraints = \\\n            [Constraints()]\n\n    def create_new_goal_constraint(self):\n        \"\"\"\n        Create a new set of goal contraints that will be set together with the request. Each\n        subsequent setting of goals with `set_joint_goal()`, `set_pose_goal()` and others will be\n        added under this newly created set of contraints.\n        \"\"\"\n        (self.kinematic_path_request.motion_plan_request.goal_constraints\n         .append(Constraints()))\n\n    def set_joint_goal(self, joint_positions, tolerance=0.001, weight=1.0, joint_names=None):\n        \"\"\"\n        Set goal position in joint space. With `joint_names` specified, `joint_positions` can be\n        defined for specific joints. Otherwise, first `n` joints defined in `init_robot()` will be\n        used, where `n` is the length of `joint_positions`.\n        \"\"\"\n        if joint_names == None:\n            joint_names = self.arm_joints\n\n        for i in range(len(joint_positions)):\n            joint_constraint = JointConstraint()\n            joint_constraint.joint_name = joint_names[i]\n            joint_constraint.position = joint_positions[i]\n            joint_constraint.tolerance_above = tolerance\n            joint_constraint.tolerance_below = tolerance\n            joint_constraint.weight = weight\n\n            (self.kinematic_path_request.motion_plan_request.goal_constraints[-1].\n             joint_constraints.append(joint_constraint))\n\n    def set_position_goal(self, position, tolerance=0.001, weight=1.0, frame=None):\n        \"\"\"\n        Set goal position of `frame` in Cartesian space. Defaults to the end-effector `frame`.\n        \"\"\"\n        if frame == None:\n            frame = self.arm_base_link\n\n        position_constraint = PositionConstraint()\n        position_constraint.header.frame_id = frame\n        position_constraint.link_name = self.arm_end_effector\n        position_constraint.constraint_region.primitive_poses.append(Pose())\n        position_constraint.constraint_region.primitive_poses[0].position.x = position[0]\n        position_constraint.constraint_region.primitive_poses[0].position.y = position[1]\n        position_constraint.constraint_region.primitive_poses[0].position.z = position[2]\n\n        # Goal is defined as a sphere with radius equal to tolerance\n        position_constraint.constraint_region.primitives.append(\n            SolidPrimitive())\n        position_constraint.constraint_region.primitives[0].type = 2\n        position_constraint.constraint_region.primitives[0].dimensions = [\n            tolerance]\n        position_constraint.weight = weight\n\n        (self.kinematic_path_request.motion_plan_request.goal_constraints[-1].position_constraints\n         .append(position_constraint))\n\n    def set_orientation_goal(self, quaternion, tolerance=0.001, weight=1.0, frame=None):\n        \"\"\"\n        Set goal orientation of `frame`. Defaults to the end-effector `frame`.\n        \"\"\"\n        if frame == None:\n            frame = self.arm_end_effector\n\n        orientation_constraint = OrientationConstraint()\n        orientation_constraint.header.frame_id = self.arm_base_link\n        orientation_constraint.link_name = frame\n        orientation_constraint.orientation = quaternion\n        orientation_constraint.absolute_x_axis_tolerance = tolerance\n        orientation_constraint.absolute_y_axis_tolerance = tolerance\n        orientation_constraint.absolute_z_axis_tolerance = tolerance\n        orientation_constraint.weight = weight\n\n        (self.kinematic_path_request.motion_plan_request.goal_constraints[-1]\n         .orientation_constraints.append(orientation_constraint))\n\n    def set_pose_goal(self, position, quaternion,\n                      tolerance_position=0.001, tolerance_orientation=0.001,\n                      weight_position=1.0, weight_orientation=1.0,\n                      frame=None):\n        \"\"\"\n        Set goal pose. This is direct combination of `set_position_goal()` and\n        `set_orientation_goal()`.\n        \"\"\"\n        self.set_position_goal(\n            position, tolerance_position, weight_position, frame)\n        self.set_orientation_goal(\n            quaternion, tolerance_orientation, weight_orientation, frame)\n\n    # plan_cartesian_path\n    def init_plan_cartesian_path(self):\n        \"\"\"\n        Initialise `compute_cartesian_path` service.\n        \"\"\"\n        # TODO\n        pass\n\n    def plan_cartesian_path(self, pose,\n                            start_joint_state=None,\n                            constrains=None) -> GetCartesianPath.Response:\n        \"\"\"\n        Call `compute_cartesian_path` service.\n        \"\"\"\n        # TODO\n        pass\n"}\n{"instruction": "Write a ROS2 Python node named ex_pose_goal.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "#!/usr/bin/env python3\n\"\"\"\nExample of moving to a pose goal.\n- ros2 run frida_pymoveit2 ex_pose_goal.py --ros-args -p position:=\"[0.5, 0.5, 0.4]\" -p quat_xyzw:=\"[0.0, 0.0, 0.0, 1.0]\" -p cartesian:=False\n- ros2 run frida_pymoveit2 ex_pose_goal.py --ros-args -p position:=\"[0.5, 0.5, 0.4]\" -p quat_xyzw:=\"[0.0, 0.0, 0.0, 1.0]\" -p cartesian:=False -p synchronous:=False -p cancel_after_secs:=1.0\n- ros2 run frida_pymoveit2 ex_pose_goal.py --ros-args -p position:=\"[0.5, 0.5, 0.4]\" -p quat_xyzw:=\"[0.0, 0.0, 0.0, 1.0]\" -p cartesian:=False -p synchronous:=False -p cancel_after_secs:=0.0\n\"\"\"\n\nfrom threading import Thread\n\nimport rclpy\nfrom rclpy.callback_groups import ReentrantCallbackGroup\nfrom rclpy.node import Node\n\nfrom pymoveit2 import MoveIt2, MoveIt2State\nfrom frida_pymoveit2.robots import xarm6\n\n\ndef main():\n    rclpy.init()\n\n    # Create node for this example\n    node = Node(\"ex_pose_goal\")\n\n    # Declare parameters for position and orientation\n    node.declare_parameter(\"position\", [0.5, 0.0, 0.25])\n    node.declare_parameter(\"quat_xyzw\", [1.0, 0.0, 0.0, 0.0])\n    node.declare_parameter(\"synchronous\", True)\n    # If non-positive, don't cancel. Only used if synchronous is False\n    node.declare_parameter(\"cancel_after_secs\", 0.0)\n    # Planner ID -> Feel free to test other planners\n    node.declare_parameter(\"planner_id\", \"RRTConnect\")\n    # Declare parameters for cartesian planning -> Constrained to move \"on a plane\"\n    node.declare_parameter(\"cartesian\", False)\n    node.declare_parameter(\"cartesian_max_step\", 0.0025)\n    node.declare_parameter(\"cartesian_fraction_threshold\", 0.0)\n    node.declare_parameter(\"cartesian_jump_threshold\", 0.0)\n    node.declare_parameter(\"cartesian_avoid_collisions\", False)\n\n    # Create callback group that allows execution of callbacks in parallel without restrictions\n    callback_group = ReentrantCallbackGroup()\n\n    # Create MoveIt 2 interface\n    moveit2 = MoveIt2(\n        node=node,\n        joint_names=xarm6.joint_names(),\n        base_link_name=xarm6.base_link_name(),\n        end_effector_name=xarm6.end_effector_name(),\n        group_name=xarm6.MOVE_GROUP_ARM,\n        callback_group=callback_group,\n    )\n\n    # Spin the node in background thread(s) and wait a bit for initialization\n    executor = rclpy.executors.MultiThreadedExecutor(2)\n    executor.add_node(node)\n    executor_thread = Thread(target=executor.spin, daemon=True, args=())\n    executor_thread.start()\n    node.create_rate(1.0).sleep()\n\n    # Get parameters -> This is for this sample code, but you can use your own parameters\n    position = node.get_parameter(\"position\").get_parameter_value().double_array_value\n    quat_xyzw = node.get_parameter(\"quat_xyzw\").get_parameter_value().double_array_value\n    synchronous = node.get_parameter(\"synchronous\").get_parameter_value().bool_value\n    cancel_after_secs = (\n        node.get_parameter(\"cancel_after_secs\").get_parameter_value().double_value\n    )\n    cartesian = node.get_parameter(\"cartesian\").get_parameter_value().bool_value\n    cartesian_max_step = (\n        node.get_parameter(\"cartesian_max_step\").get_parameter_value().double_value\n    )\n    cartesian_fraction_threshold = (\n        node.get_parameter(\"cartesian_fraction_threshold\")\n        .get_parameter_value()\n        .double_value\n    )\n    cartesian_jump_threshold = (\n        node.get_parameter(\"cartesian_jump_threshold\")\n        .get_parameter_value()\n        .double_value\n    )\n    cartesian_avoid_collisions = (\n        node.get_parameter(\"cartesian_avoid_collisions\")\n        .get_parameter_value()\n        .bool_value\n    )\n\n    # Scale down velocity and acceleration of joints (percentage of maximum)\n    moveit2.max_velocity = 0.5\n    moveit2.max_acceleration = 0.5\n    # Set parameters for cartesian planning\n    moveit2.cartesian_avoid_collisions = cartesian_avoid_collisions\n    moveit2.cartesian_jump_threshold = cartesian_jump_threshold\n    # Planner\n    moveit2.planner_id = (\n        node.get_parameter(\"planner_id\").get_parameter_value().string_value\n    )\n\n    # Move to pose\n    node.get_logger().info(\n        f\"Moving to {{position: {list(position)}, quat_xyzw: {list(quat_xyzw)}}}\"\n    )\n    moveit2.move_to_pose(\n        position=position,\n        quat_xyzw=quat_xyzw,\n        cartesian=cartesian,\n        cartesian_max_step=cartesian_max_step,\n        cartesian_fraction_threshold=cartesian_fraction_threshold,\n    )\n    if synchronous:\n        # Note: the same functionality can be achieved by setting\n        # `synchronous:=false` and `cancel_after_secs` to a negative value.\n        moveit2.wait_until_executed()\n    else:\n        # Wait for the request to get accepted (i.e., for execution to start)\n        print(\"Current State: \" + str(moveit2.query_state()))\n        rate = node.create_rate(10)\n        while moveit2.query_state() != MoveIt2State.EXECUTING:\n            rate.sleep()\n\n        # Get the future\n        print(\"Current State: \" + str(moveit2.query_state()))\n        future = moveit2.get_execution_future()\n\n        # Cancel the goal\n        if cancel_after_secs > 0.0:\n            # Sleep for the specified time\n            sleep_time = node.create_rate(cancel_after_secs)\n            sleep_time.sleep()\n            # Cancel the goal\n            print(\"Cancelling goal\")\n            moveit2.cancel_execution()\n\n        # Wait until the future is done\n        while not future.done():\n            rate.sleep()\n\n        # Print the result\n        print(\"Result status: \" + str(future.result().status))\n        print(\"Result error code: \" + str(future.result().result.error_code))\n\n    rclpy.shutdown()\n    executor_thread.join()\n    exit(0)\n\n\nif __name__ == \"__main__\":\n    main()\n"}\n{"instruction": "Write a ROS2 Python node named xbox_servo_teleop.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "#!/usr/bin/env python3\n\"\"\"\nXbox 手柄实时 Servo 控制节点\n使用 MoveIt Servo 进行实时笛卡尔空间控制\n\n控制映射：\n- 左摇杆：X/Y 平移\n- LT/RT：Z 平移\n- 右摇杆：Yaw/Pitch 旋转\n- LB/RB：Roll 旋转\n\"\"\"\n\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import Joy\nfrom geometry_msgs.msg import TwistStamped\nimport math\n\n\nclass XboxServoTeleopNode(Node):\n    def __init__(self):\n        super().__init__('xbox_servo_teleop_node')\n        \n        # Declare parameters\n        self.declare_parameter('linear_scale', 0.1)  # m/s\n        self.declare_parameter('angular_scale', 0.5)  # rad/s\n        self.declare_parameter('base_frame', 'base_link')\n        self.declare_parameter('deadzone', 0.1)  # Joystick deadzone\n        \n        # Get parameters\n        self.linear_scale = self.get_parameter('linear_scale').value\n        self.angular_scale = self.get_parameter('angular_scale').value\n        self.base_frame = self.get_parameter('base_frame').value\n        self.deadzone = self.get_parameter('deadzone').value\n        \n        # Subscribe to controller input\n        self.joy_sub = self.create_subscription(\n            Joy,\n            'joy',\n            self.joy_callback,\n            10\n        )\n        \n        # Publish Twist commands to MoveIt Servo\n        self.twist_pub = self.create_publisher(\n            TwistStamped,\n            '/servo_node/delta_twist_cmds',\n            10\n        )\n        \n        self.get_logger().info('Xbox 手柄 Servo 控制节点已启动')\n        self.get_logger().info(f'线速度缩放：{self.linear_scale} m/s')\n        self.get_logger().info(f'角速度缩放：{self.angular_scale} rad/s')\n        \n    def apply_deadzone(self, value):\n        \"\"\"应用摇杆死区\"\"\"\n        if abs(value) < self.deadzone:\n            return 0.0\n        # Linearly map values outside the deadzone\n        sign = 1.0 if value > 0 else -1.0\n        return sign * (abs(value) - self.deadzone) / (1.0 - self.deadzone)\n        \n    def joy_callback(self, msg):\n        \"\"\"Controller input callback\"\"\"\n        # Xbox controller mapping:\n        # Left stick X: axes[0]\n        # Left stick Y: axes[1]\n        # LT: axes[2] (range 1.0 to -1.0, pressed is -1.0)\n        # RT: axes[5] (range 1.0 to -1.0, pressed is -1.0)\n        # Right stick X: axes[3]\n        # Right stick Y: axes[4]\n        # LB: buttons[4]\n        # RB: buttons[5]\n        \n        # Ensure indices are valid\n        if len(msg.axes) < 6 or len(msg.buttons) < 6:\n            return\n            \n        # Create Twist message\n        twist_msg = TwistStamped()\n        twist_msg.header.stamp = self.get_clock().now().to_msg()\n        twist_msg.header.frame_id = self.base_frame\n        \n        # Translation control (linear velocity)\n        twist_msg.twist.linear.x = self.apply_deadzone(msg.axes[0]) * self.linear_scale  # Left stick X -> X\n        twist_msg.twist.linear.y = self.apply_deadzone(msg.axes[1]) * self.linear_scale  # Left stick Y -> Y\n        \n        # LT/RT control Z\n        lt = (1.0 - msg.axes[2]) / 2.0  # Convert to 0-1 range\n        rt = (1.0 - msg.axes[5]) / 2.0  # Convert to 0-1 range\n        twist_msg.twist.linear.z = (rt - lt) * self.linear_scale  # RT up, LT down\n        \n        # Rotation control (angular velocity)\n        twist_msg.twist.angular.z = self.apply_deadzone(msg.axes[3]) * self.angular_scale  # Right stick X -> Yaw\n        twist_msg.twist.angular.y = self.apply_deadzone(msg.axes[4]) * self.angular_scale  # Right stick Y -> Pitch\n        \n        # LB/RB control Roll\n        twist_msg.twist.angular.x = (msg.buttons[5] - msg.buttons[4]) * self.angular_scale  # RB positive, LB negative\n        \n        # Publish Twist command\n        self.twist_pub.publish(twist_msg)\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = XboxServoTeleopNode()\n    \n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\n\nif __name__ == '__main__':\n    main()\n\n\n\n\n\n"}\n{"instruction": "Write a ROS2 Python node named picknplace_bottle_low that uses rclpy and MoveIt2 for robotic manipulation.", "response": "#!/usr/bin/env python3\n\"\"\"\nA script to outline the fundamentals of the moveit_py motion planning API.\n\"\"\"\n\nimport time\nfrom math import pi\n# generic ros libraries\nimport rclpy\nfrom rclpy.logging import get_logger\nfrom rclpy.duration import Duration\n\n# moveit python library\nfrom moveit.core.robot_state import RobotState\nfrom moveit.planning import (\n    MoveItPy,\n    MultiPipelinePlanRequestParameters,\n    PlanRequestParameters,\n)\nfrom moveit.core.kinematic_constraints import construct_joint_constraint\nfrom moveit_configs_utils import MoveItConfigsBuilder\nfrom ament_index_python import get_package_share_directory\nfrom moveit_msgs import msg\nfrom geometry_msgs.msg import PoseStamped, Quaternion\nfrom trajectory_msgs.msg import JointTrajectoryPoint\n\nfrom tf_transformations import quaternion_from_euler\n\ndef plan_and_execute(\n    robot,\n    planning_component,\n    logger,\n    single_plan_parameters=None,\n    multi_plan_parameters=None,\n    sleep_time=0.0,\n):\n    \"\"\"Helper function to plan and execute a motion.\"\"\"\n    # plan to goal\n    logger.info(\"Planning trajectory\")\n    if multi_plan_parameters is not None:\n        plan_result = planning_component.plan(\n            multi_plan_parameters=multi_plan_parameters\n        )\n    elif single_plan_parameters is not None:\n        plan_result = planning_component.plan(\n            single_plan_parameters=single_plan_parameters\n        )\n    else:\n        plan_result = planning_component.plan()\n\n    # execute the plan\n    if plan_result:\n        logger.info(\"Executing plan\")\n        robot_trajectory = plan_result.trajectory\n        robot.execute(robot_trajectory, controllers=[])\n    else:\n        logger.error(\"Planning failed\")\n\n    time.sleep(sleep_time) \n\ndef closedGripper():\n    \"\"\"Specifies closed grasp posture for the pick and place motions\"\"\"\n    # specify which end effector joints are involved in the grasp\n    gripper.set_start_state_to_current_state()\n\n    # set constraints message\n    joint_values = {\n            \"robotiq_85_left_knuckle_joint\": 0.75,\n            \"robotiq_85_right_knuckle_joint\": -0.75,\n    }\n    robot_state.joint_positions = joint_values\n    gripper.set_goal_state(robot_state=robot_state)\n    single_plan_request_params = PlanRequestParameters(\n        ur5, \"stomp_planner\")\n\n    plan_and_execute(ur5, gripper, logger, sleep_time=1.0, single_plan_parameters=single_plan_request_params)\n\ndef openGripper():\n    \"\"\"Specifies open grasp posture for the pick and place motions\"\"\"\n    # specify which end effector joints are involved in the grasp\n    # set plan start state to current state\n    gripper.set_start_state_to_current_state()\n\n    # set constraints message\n    joint_values = {\n            \"robotiq_85_left_knuckle_joint\": 0.0,\n            \"robotiq_85_right_knuckle_joint\": -0.0,\n    }\n    robot_state.joint_positions = joint_values\n    gripper.set_goal_state(robot_state=robot_state)\n    single_plan_request_params = PlanRequestParameters(\n        ur5, \"stomp_planner\")\n\n    plan_and_execute(ur5, gripper, logger, sleep_time=1.0, single_plan_parameters=single_plan_request_params)\n\n\ndef pick(move_group):\n    \"\"\"Specifies, plans, and executes a pick operation.\"\"\"\n\n    single_plan_request_params = PlanRequestParameters(\n        ur5, \"ompl_rrtc\")\n    \n    # initialise multi-pipeline plan request parameters\n    multi_pipeline_plan_request_params = MultiPipelinePlanRequestParameters(\n        ur5, [\"ompl_rrtc\", \"stomp_planner\"]\n    )\n    # set plan start state to current state\n    ur5_arm.set_start_state_to_current_state()\n\n    # Create a goal position for picking\n    pose_goal = PoseStamped()\n    pose_goal.header.frame_id = \"world\"\n    pose_goal.header.stamp = rclpy.time.Time().to_msg()\n    quat = quaternion_from_euler(1.57, 3.14, 1.57)\n    pose_goal.pose.orientation.x = quat[0]\n    pose_goal.pose.orientation.y = quat[1]\n    pose_goal.pose.orientation.z = quat[2]\n    pose_goal.pose.orientation.w = quat[3]\n    pose_goal.pose.position.x = 0.41\n    pose_goal.pose.position.y = -0.05\n    pose_goal.pose.position.z = 0.86\n    ur5_arm.set_goal_state(pose_stamped_msg=pose_goal, pose_link=\"flange\")\n    plan_and_execute(ur5, ur5_arm, logger, sleep_time=1.0, single_plan_parameters=single_plan_request_params)\n\n    # Finally we specify the parameters for the open and close\n    # posture of the grasp \n    openGripper()\n\n    # set plan start state to current state\n    ur5_arm.set_start_state_to_current_state()\n\n    pose_goal = PoseStamped()\n    pose_goal.header.frame_id = \"world\"\n    pose_goal.header.stamp = rclpy.time.Time().to_msg()\n    quat = quaternion_from_euler(1.57, 3.14, 1.57)\n    pose_goal.pose.orientation.x = quat[0]\n    pose_goal.pose.orientation.y = quat[1]\n    pose_goal.pose.orientation.z = quat[2]\n    pose_goal.pose.orientation.w = quat[3]\n    pose_goal.pose.position.x = 0.41\n    pose_goal.pose.position.y = -0.184\n    pose_goal.pose.position.z = 0.8\n    ur5_arm.set_goal_state(pose_stamped_msg=pose_goal, pose_link=\"flange\")\n    plan_and_execute(ur5, ur5_arm, logger, sleep_time=1.0, multi_plan_parameters=multi_pipeline_plan_request_params)\n\n    closedGripper()\n\n    ur5_arm.set_start_state_to_current_state()\n\n    pose_goal = PoseStamped()\n    pose_goal.header.frame_id = \"world\"\n    pose_goal.header.stamp = rclpy.time.Time().to_msg()\n    quat = quaternion_from_euler(1.57, 3.14, 1.57)\n    pose_goal.pose.orientation.x = quat[0]\n    pose_goal.pose.orientation.y = quat[1]\n    pose_goal.pose.orientation.z = quat[2]\n    pose_goal.pose.orientation.w = quat[3]\n    pose_goal.pose.position.x = 0.3\n    pose_goal.pose.position.y = 0.0\n    pose_goal.pose.position.z = 1.6\n    ur5_arm.set_goal_state(pose_stamped_msg=pose_goal, pose_link=\"flange\")\n    plan_and_execute(ur5, ur5_arm, logger, sleep_time=3.0, multi_plan_parameters=multi_pipeline_plan_request_params)\n\ndef place(move_group):\n    \"\"\"Specifies, plans, and executes a place operation.\"\"\"\n\n    # initialise multi-pipeline plan request parameters\n    multi_pipeline_plan_request_params = MultiPipelinePlanRequestParameters(\n        ur5, [\"ompl_rrtc\", \"stomp_planner\"]\n    ) \n    single_plan_request_params = PlanRequestParameters(\n        ur5, \"ompl_rrtc\")\n\n    pose_goal = PoseStamped()\n    pose_goal.header.frame_id = \"world\"\n    pose_goal.header.stamp = rclpy.time.Time().to_msg()\n    quat = quaternion_from_euler(1.57, 3.14, 1.57)\n    pose_goal.pose.orientation.x = quat[0]\n    pose_goal.pose.orientation.y = quat[1]\n    pose_goal.pose.orientation.z = quat[2]\n    pose_goal.pose.orientation.w = quat[3]\n    pose_goal.pose.position.x = -0.45\n    pose_goal.pose.position.y = 0.0\n    pose_goal.pose.position.z = 1.25\n    ur5_arm.set_goal_state(pose_stamped_msg=pose_goal, pose_link=\"flange\")\n    plan_and_execute(ur5, ur5_arm, logger, sleep_time=3.0, multi_plan_parameters=multi_pipeline_plan_request_params)\n\n    # Finally we specify the parameters for the open and close\n    # posture of the grasp \n    openGripper()\n\n\nif __name__=='__main__':\n    # Initialise moveit and ROS node\n    rclpy.init()\n    logger = get_logger(\"moveit_py.pose_goal\")\n\n    # instantiate MoveItPy instance and get planning component\n    ur5 = MoveItPy(node_name=\"moveit_py\")\n    ur5_arm = ur5.get_planning_component(\"ur5_arm\")\n    gripper = ur5.get_planning_component(\"gripper\")\n    logger.info(\"MoveItPy instance created\")\n\n    # instantiate a RobotState instance using the current robot model\n    robot_model = ur5.get_robot_model()\n    robot_state = RobotState(robot_model)\n\n    # Plan and execute the pick operation\n    pick(ur5_arm)\n\n    #rclpy.sleep(1)\n\n    # Plan and execute the place operaation\n    place(ur5_arm)"}\n{"instruction": "Write a ROS2 Python node named ros_network_viz.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "# Copyright 2021 Open Source Robotics Foundation, Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport signal\nimport sys\n\nimport networkx\n\nfrom PyQt5 import QtCore, QtGui, QtWidgets\n\nfrom ros_network_viz.ros_graph import node_is_hidden, ROSGraph, service_is_hidden, topic_is_hidden\nfrom ros_network_viz.sorted_ordered_set import SortedOrderedSet\n\n# Most of the colors in this palette are from\n# https://coolors.co/001219-005f73-0a9396-94d2bd-e9d8a6-ee9b00-ca6702-bb3e03-ae2012-9b2226\nCOLOR_PALETTE = {\n    'connection_line': 'f48c06',\n    'connection_line_highlight': 'ffba08',\n    'lifecycle_node': '0a9396',\n    'component_node': '9b2226',\n    'regular_node': '505050',\n    'node_border': '323232',\n    'node_border_highlight': 'ae2012',\n    'node_text': 'e6e6e6',\n    'topic': '005f73',\n    'service': 'bb3e03',\n    'action': 'ca6702',\n    'background': '282828',\n    'grid_line': '323232',\n}\n\n\ndef convert_hex_to_color(data):\n    r = None\n    g = None\n    b = None\n\n    if len(data) == 6:\n        r = data[0:2]\n        g = data[2:4]\n        b = data[4:6]\n    elif len(data) == 7 and data[0] == '#':\n        r = data[1:3]\n        g = data[3:5]\n        b = data[5:7]\n\n    if r is not None and g is not None and b is not None:\n        return QtGui.QColor(int(r, 16), int(g, 16), int(b, 16))\n\n    raise Exception('Invalid color, must be a hex listing with the # or not on the front')\n\n\nclass ConnectionLine(QtWidgets.QGraphicsPathItem):\n\n    def __init__(self, qos_profile):\n        super().__init__()\n\n        self.setZValue(-1)\n        self.setAcceptHoverEvents(True)\n\n        if qos_profile is not None:\n            text = '\\n'.join([\n                'Quality of Service:',\n                f'  Reliability: {qos_profile.reliability.name}',\n                f'  Durability: {qos_profile.durability.name}',\n                f'  Lifespan: {qos_profile.lifespan}',\n                f'  Deadline: {qos_profile.deadline}',\n                f'  Liveliness: {qos_profile.liveliness.name}',\n                f'  Liveliness lease duration: {qos_profile.liveliness_lease_duration}',\n            ])\n            self.setToolTip(text)\n\n        # Pens used to draw the connection line in selected and unselected states\n        self._pen = QtGui.QPen(convert_hex_to_color(COLOR_PALETTE['connection_line']), 3)\n        self._pen_sel = QtGui.QPen(\n            convert_hex_to_color(COLOR_PALETTE['connection_line_highlight']), 5)\n\n        # Brushes used to fill the arrow in selected and unselected states\n        self._brush = QtGui.QBrush(convert_hex_to_color(COLOR_PALETTE['connection_line']))\n        highlight_color = convert_hex_to_color(COLOR_PALETTE['connection_line_highlight'])\n        self._brush_sel = QtGui.QBrush(highlight_color)\n\n        self.setPen(self._pen)\n\n        # The connection line begins in the unselected state\n        self._current_brush = self._brush\n\n        # The endpoints of the connection line aren't known until update_path is called\n        self._arrow_location = None\n\n    # PyQt method override\n    def hoverEnterEvent(self, event):\n        self.setPen(self._pen_sel)\n        self._current_brush = self._brush_sel\n        super().hoverEnterEvent(event)\n\n    # PyQt method override\n    def hoverLeaveEvent(self, event):\n        self.setPen(self._pen)\n        self._current_brush = self._brush\n        super().hoverLeaveEvent(event)\n\n    # PyQt method override\n    def paint(self, painter, option, widget):\n        super().paint(painter, option, widget)\n\n        # update_path() may not have been called yet\n        if self._arrow_location:\n            x = self._arrow_location.x()\n            y = self._arrow_location.y()\n            path = QtGui.QPainterPath()\n            path.moveTo(x - 15, y + 10)\n            path.lineTo(x - 15, y - 10)\n            path.lineTo(x + 1, y)\n            path.moveTo(x - 15, y + 10)\n            painter.fillPath(path, self._current_brush)\n\n    def update_path(self, source_point, target_point):\n        path = QtGui.QPainterPath()\n\n        self._arrow_location = target_point\n        path.moveTo(source_point)\n        dx = (target_point.x() - source_point.x()) * 0.5\n        dy = target_point.y() - source_point.y()\n        ctrl1 = QtCore.QPointF(source_point.x() + dx, source_point.y() + dy * 0)\n        ctrl2 = QtCore.QPointF(source_point.x() + dx, source_point.y() + dy * 1)\n        path.cubicTo(ctrl1, ctrl2, target_point)\n\n        self.setPath(path)\n\n\nclass NodeBox(QtWidgets.QGraphicsObject):\n\n    def __init__(self, name, is_lifecycle, is_component_manager):\n        super().__init__()\n\n        self._name = name\n        self._is_lifecycle = is_lifecycle\n        self._is_component_manager = is_component_manager\n        self._lifecycle_state = None\n        self._params = {}\n        self._param_warnings = ''\n        self._managed_nodes = []\n\n        self._radius = 10\n        self._base_height = 25\n        self._node_border = 2\n\n        self.setZValue(1)\n\n        self.setFlag(QtWidgets.QGraphicsObject.ItemIsMovable)\n        self.setFlag(QtWidgets.QGraphicsObject.ItemIsSelectable)\n\n        self._brush = QtGui.QBrush()\n        self._brush.setStyle(QtCore.Qt.SolidPattern)\n        # TODO(clalancette): What happens if a node is both lifecycle *and* component manager?\n        if self._is_lifecycle:\n            self._brush.setColor(convert_hex_to_color(COLOR_PALETTE['lifecycle_node']))\n        elif self._is_component_manager:\n            self._brush.setColor(convert_hex_to_color(COLOR_PALETTE['component_node']))\n        else:\n            self._brush.setColor(convert_hex_to_color(COLOR_PALETTE['regular_node']))\n\n        self._pen = QtGui.QPen(convert_hex_to_color(COLOR_PALETTE['node_border']),\n                               self._node_border,\n                               QtCore.Qt.SolidLine)\n\n        self._pen_sel = QtGui.QPen(convert_hex_to_color(COLOR_PALETTE['node_border_highlight']),\n                                   self._node_border,\n                                   QtCore.Qt.SolidLine)\n\n        self._text_pen = QtGui.QPen(convert_hex_to_color(COLOR_PALETTE['node_text']),\n                                    0,\n                                    QtCore.Qt.SolidLine)\n\n        self._node_text_font = QtGui.QFont('Arial', 12, QtGui.QFont.Bold)\n\n        metrics = QtGui.QFontMetrics(self._node_text_font)\n        text_width = metrics.boundingRect(self._name).width() + 14\n        text_height = metrics.boundingRect(self._name).height() + 14\n        height_margin = int((text_height - self._base_height) * 0.5)\n        self._base_width = text_width\n        self._text_rect = QtCore.QRect(0, -height_margin, text_width, text_height)\n\n        self.update_tooltip()\n\n        self._anim = QtCore.QPropertyAnimation(self, b'pos')\n        self._anim.setEasingCurve(QtCore.QEasingCurve.InOutCubic)\n        self._anim.setDuration(1000)\n        self._anim.finished.connect(self.animation_finished)\n\n    # PyQt method override\n    def boundingRect(self):\n        return QtCore.QRectF(QtCore.QRect(0, 0, self._base_width, self._base_height))\n\n    # PyQt method override\n    def mouseMoveEvent(self, event):\n        self.scene().update_connections()\n        super().mouseMoveEvent(event)\n\n    # PyQt method override\n    def paint(self, painter, option, widget):\n        # First draw the rounded rectangle the represents the node\n        painter.setBrush(self._brush)\n        if self.isSelected():\n            painter.setPen(self._pen_sel)\n        else:\n            painter.setPen(self._pen)\n\n        painter.drawRoundedRect(0, 0,\n                                self._base_width,\n                                self._base_height,\n                                self._radius,\n                                self._radius)\n\n        # Now draw the node name above the rectangle\n        painter.setPen(self._text_pen)\n        painter.setFont(self._node_text_font)\n\n        painter.drawText(self._text_rect,\n                         QtCore.Qt.AlignCenter,\n                         self._name)\n\n    def update_tooltip(self):\n        text = ''\n\n        if self._lifecycle_state is not None:\n            text += 'Lifecycle state: ' + self._lifecycle_state + '\\n'\n\n        if self._managed_nodes:\n            text += 'Managed Nodes:\\n'\n            for n in self._managed_nodes:\n                text += '  ' + n + '\\n'\n\n        text += 'Parameters:\\n'\n        if self._param_warnings:\n            text += '  <' + self._param_warnings + '>\\n'\n        elif self._params:\n            for k, v in self._params.items():\n                text += '  ' + k + ' -> ' + str(v) + '\\n'\n        else:\n            text += '  None\\n'\n\n        text = text[:-1]\n\n        self.setToolTip(text)\n\n    def update_params(self, new_params, new_warnings):\n        self._params = new_params\n        self._param_warnings = new_warnings\n        self.update_tooltip()\n\n    def update_lifecycle_state(self, new_state):\n        self._lifecycle_state = new_state\n        self.update_tooltip()\n\n    def update_managed_nodes(self, new_managed_nodes):\n        self._managed_nodes = new_managed_nodes\n        self.update_tooltip()\n\n    def animation_finished(self):\n        scene = self.scene()\n        # the scene can be None if the Node was removed before the animation finished\n        if scene:\n            scene.complete_animation(self._name)\n\n    def set_position(self, x, y):\n        self._anim.setEndValue(QtCore.QPointF(x, y))\n        self._anim.start()\n\n    def left(self):\n        rect = self.boundingRect()\n        return self.mapToScene(QtCore.QPointF(0, rect.y() + rect.height() * 0.5))\n\n    def right(self):\n        rect = self.boundingRect()\n        return self.mapToScene(QtCore.QPointF(rect.x() + rect.width(),\n                                              rect.y() + rect.height() * 0.5))\n\n\nclass ConnectionBox(QtWidgets.QGraphicsObject):\n\n    def __init__(self, name, conn_type, bg_color):\n        super().__init__()\n\n        self._name = name\n\n        self._radius = 10\n        self._base_height = 25\n        self._node_border = 2\n\n        self.setZValue(1)\n\n        self.setToolTip('Type: ' + conn_type)\n\n        self.setFlag(QtWidgets.QGraphicsObject.ItemIsMovable)\n        self.setFlag(QtWidgets.QGraphicsObject.ItemIsSelectable)\n\n        self._brush = QtGui.QBrush(convert_hex_to_color(COLOR_PALETTE[bg_color]),\n                                   QtCore.Qt.SolidPattern)\n\n        self._pen = QtGui.QPen(convert_hex_to_color(COLOR_PALETTE['node_border']),\n                               self._node_border,\n                               QtCore.Qt.SolidLine)\n\n        self._pen_sel = QtGui.QPen(convert_hex_to_color(COLOR_PALETTE['node_border_highlight']),\n                                   self._node_border,\n                                   QtCore.Qt.SolidLine)\n\n        self._text_pen = QtGui.QPen(convert_hex_to_color(COLOR_PALETTE['node_text']),\n                                    0,\n                                    QtCore.Qt.SolidLine)\n\n        self._node_text_font = QtGui.QFont('Arial', 10, QtGui.QFont.Normal)\n\n        metrics = QtGui.QFontMetrics(self._node_text_font)\n        text_width = metrics.boundingRect(self._name).width() + 14\n        text_height = metrics.boundingRect(self._name).height() + 14\n        height_margin = int((text_height - self._base_height) * 0.5)\n        self._base_width = text_width\n        self._text_rect = QtCore.QRect(0, -height_margin, text_width, text_height)\n\n        self._anim = QtCore.QPropertyAnimation(self, b'pos')\n        self._anim.setEasingCurve(QtCore.QEasingCurve.InOutCubic)\n        self._anim.setDuration(1000)\n        self._anim.finished.connect(self.animation_finished)\n\n    # PyQt method override\n    def boundingRect(self):\n        return QtCore.QRectF(QtCore.QRect(0, 0, self._base_width, self._base_height))\n\n    # PyQt method override\n    def mouseMoveEvent(self, event):\n        self.scene().update_connections()\n        super().mouseMoveEvent(event)\n\n    # PyQt method override\n    def paint(self, painter, option, widget):\n        # First draw the rounded rectangle the represents the node\n        painter.setBrush(self._brush)\n        if self.isSelected():\n            painter.setPen(self._pen_sel)\n        else:\n            painter.setPen(self._pen)\n\n        painter.drawRect(0, 0, self._base_width, self._base_height)\n\n        # Now draw the node name (and lifecycle state, if applicable) above the\n        # rectangle\n        painter.setPen(self._text_pen)\n        painter.setFont(self._node_text_font)\n\n        painter.drawText(self._text_rect,\n                         QtCore.Qt.AlignCenter,\n                         self._name)\n\n    def animation_finished(self):\n        scene = self.scene()\n        # the scene can be None if the Node was removed before the animation finished\n        if scene:\n            scene.complete_animation(self._name)\n\n    def set_position(self, x, y):\n        self._anim.setEndValue(QtCore.QPointF(x, y))\n        self._anim.start()\n\n    def left(self):\n        rect = self.boundingRect()\n        return self.mapToScene(QtCore.QPointF(0, rect.y() + rect.height() * 0.5))\n\n    def right(self):\n        rect = self.boundingRect()\n        return self.mapToScene(QtCore.QPointF(rect.x() + rect.width(),\n                                              rect.y() + rect.height() * 0.5))\n\n\nclass NetworkScene(QtWidgets.QGraphicsScene):\n\n    new_node_params_signal = QtCore.pyqtSignal(str, dict, str, name='newNodeParams')\n    new_lifecycle_state_signal = QtCore.pyqtSignal(str, str, name='newLifecycleState')\n    new_component_nodes_signal = QtCore.pyqtSignal(str, list, name='newComponentManagerNodes')\n\n    new_nodes_signal = QtCore.pyqtSignal(dict, name='newNodes')\n\n    update_hidden_nodes_signal = QtCore.pyqtSignal(list, name='updateHiddenNodes')\n    update_hidden_topics_signal = QtCore.pyqtSignal(list, name='updateHiddenTopics')\n    update_hidden_services_signal = QtCore.pyqtSignal(list, name='updateHiddenServices')\n    update_hidden_actions_signal = QtCore.pyqtSignal(list, name='updateHiddenActions')\n\n    def create_bool_right_click_action(self, name, boolean_variable, callback):\n        action = QtWidgets.QAction(name, self)\n        action.setCheckable(True)\n        action.setChecked(boolean_variable)\n        action.triggered.connect(callback)\n        return action\n\n    def __init__(self, parent):\n        super().__init__(parent)\n\n        self._scene_items = {}\n        self._graph_nodes_list = {}\n        self._connections = {}\n        self._animations_waiting = set()\n        self._hidden_nodes = set()\n        self._hidden_topics = set()\n        self._hidden_services = set()\n        self._hidden_actions = set()\n\n        self._grid_size = 36\n\n        self._brush = QtGui.QBrush(convert_hex_to_color(COLOR_PALETTE['background']),\n                                   QtCore.Qt.SolidPattern)\n\n        self._pen = QtGui.QPen(convert_hex_to_color(COLOR_PALETTE['grid_line']), 0)\n\n        self._right_click_menu = QtWidgets.QMenu()\n\n        self._live_updates = True\n        self._live_updates_action = self.create_bool_right_click_action(\n            'Update scene as graph changes', self._live_updates, self.live_updates_toggle)\n        self._right_click_menu.addAction(self._live_updates_action)\n\n        self.newNodeParams.connect(self.update_node_params)\n        self.newLifecycleState.connect(self.update_lifecycle_state)\n        self.newComponentManagerNodes.connect(self.update_component_manager_nodes)\n\n        self.newNodes.connect(self.update_nodes)\n        self.updateHiddenNodes.connect(self.update_hidden_nodes)\n        self.updateHiddenTopics.connect(self.update_hidden_topics)\n        self.updateHiddenServices.connect(self.update_hidden_services)\n        self.updateHiddenActions.connect(self.update_hidden_actions)\n\n    # PyQt method override\n    def drawBackground(self, painter, rect):\n        painter.fillRect(rect, self._brush)\n\n        left_line = rect.left() - rect.left() % self._grid_size\n        top_line = rect.top() - rect.top() % self._grid_size\n        lines = []\n\n        i = int(left_line)\n        while i < int(rect.right()):\n            lines.append(QtCore.QLineF(i, rect.top(), i, rect.bottom()))\n            i += self._grid_size\n\n        u = int(top_line)\n        while u < int(rect.bottom()):\n            lines.append(QtCore.QLineF(rect.left(), u, rect.right(), u))\n            u += self._grid_size\n\n        painter.setPen(self._pen)\n        painter.drawLines(lines)\n\n    # PyQt method override\n    def contextMenuEvent(self, event):\n        self._right_click_menu.popup(QtGui.QCursor.pos())\n        super().contextMenuEvent(event)\n\n    def live_updates_toggle(self, checked):\n        self._live_updates = checked\n        self.update_nodes(self._graph_nodes_list)\n\n    def update_nodes(self, new_nodes):\n        self._graph_nodes_list = new_nodes\n\n        if not self._live_updates:\n            return\n\n        networkx_node_graph = networkx.MultiGraph()\n        added_item = False\n        items_to_remove = dict(self._scene_items)\n        conns_to_remove = dict(self._connections)\n        connection_tuples = []\n\n        for name, node in self._graph_nodes_list.items():\n            if node.name not in self._scene_items:\n                self._scene_items[node.name] = NodeBox(node.name,\n                                                       node.is_lifecycle,\n                                                       node.is_component_manager)\n                self.addItem(self._scene_items[node.name])\n                added_item = True\n\n            if node.name in items_to_remove:\n                del items_to_remove[node.name]\n\n            if node.name in self._hidden_nodes:\n                self._scene_items[node.name].setVisible(False)\n                continue\n            else:\n                self._scene_items[node.name].setVisible(True)\n\n            networkx_node_graph.add_node(node.name)\n\n            def update_one_topic(node_name, topic, direction):\n                added_topic = False\n\n                # TODO(clalancette): What if there are multiple topics with\n                # different types and/or QoS settings?\n                if topic.conn_name in self._hidden_topics:\n                    if topic.conn_name in self._scene_items:\n                        self._scene_items[topic.conn_name].setVisible(False)\n                    return added_topic\n\n                if topic.conn_name not in self._scene_items:\n                    added_topic = True\n                    new_box = ConnectionBox(topic.conn_name, topic.conn_type, 'topic')\n                    self._scene_items[topic.conn_name] = new_box\n                    self.addItem(self._scene_items[topic.conn_name])\n\n                self._scene_items[topic.conn_name].setVisible(True)\n\n                if topic.conn_name in items_to_remove:\n                    del items_to_remove[topic.conn_name]\n\n                if direction == 'node_to_conn':\n                    networkx_node_graph.add_edge(node_name, topic.conn_name)\n                else:\n                    networkx_node_graph.add_edge(topic.conn_name, node_name)\n\n                connection_tuples.append((node_name, topic, direction))\n\n                return added_topic\n\n            def update_one_service(node_name, service, direction):\n                added_service = False\n\n                # TODO(clalancette): What if there are multiple services with\n                # different types and/or QoS settings?\n                if service.conn_name in self._hidden_services:\n                    if service.conn_name in self._scene_items:\n                        self._scene_items[service.conn_name].setVisible(False)\n                    return added_service\n\n                if service.conn_name not in self._scene_items:\n                    added_service = True\n                    new_box = ConnectionBox(service.conn_name, service.conn_type, 'service')\n                    self._scene_items[service.conn_name] = new_box\n                    self.addItem(self._scene_items[service.conn_name])\n\n                self._scene_items[service.conn_name].setVisible(True)\n\n                if service.conn_name in items_to_remove:\n                    del items_to_remove[service.conn_name]\n\n                if direction == 'node_to_conn':\n                    networkx_node_graph.add_edge(node_name, service.conn_name)\n                else:\n                    networkx_node_graph.add_edge(service.conn_name, node_name)\n\n                connection_tuples.append((node_name, service, direction))\n\n                return added_service\n\n            def update_one_action(node_name, action, direction):\n                added_action = False\n\n                if action.conn_name in self._hidden_actions:\n                    if action.conn_name in self._scene_items:\n                        self._scene_items[action.conn_name].setVisible(False)\n                    return added_action\n\n                if action.conn_name not in self._scene_items:\n                    added_action = True\n                    new_box = ConnectionBox(action.conn_name, action.conn_type, 'action')\n                    self._scene_items[action.conn_name] = new_box\n                    self.addItem(self._scene_items[action.conn_name])\n                    self._scene_items[action.conn_name].setPos(1100, 900)\n\n                self._scene_items[action.conn_name].setVisible(True)\n\n                if action.conn_name in items_to_remove:\n                    del items_to_remove[action.conn_name]\n\n                if direction == 'node_to_conn':\n                    networkx_node_graph.add_edge(node_name, action.conn_name)\n                else:\n                    networkx_node_graph.add_edge(action.conn_name, node_name)\n\n                connection_tuples.append((node_name, action, direction))\n\n                return added_action\n\n            for topic in node.topic_publishers:\n                added_item = update_one_topic(node.name, topic, 'node_to_conn')\n\n            for topic in node.topic_subscribers:\n                added_item = update_one_topic(node.name, topic, 'conn_to_node')\n\n            for service in node.service_clients:\n                added_item = update_one_service(node.name, service, 'node_to_conn')\n\n            for service in node.service_servers:\n                added_item = update_one_service(node.name, service, 'conn_to_node')\n\n            for action in node.action_clients:\n                added_item = update_one_action(node.name, action, 'node_to_conn')\n\n            for action in node.action_servers:\n                added_item = update_one_action(node.name, action, 'conn_to_node')\n\n        for name, item in items_to_remove.items():\n            if name in self._scene_items:\n                self.removeItem(self._scene_items[name])\n                del self._scene_items[name]\n\n        for conn_tuple in connection_tuples:\n            if conn_tuple not in self._connections:\n                added_item = True\n                self._connections[conn_tuple] = ConnectionLine(conn_tuple[1].qos_profile)\n                self.addItem(self._connections[conn_tuple])\n            if conn_tuple in conns_to_remove:\n                del conns_to_remove[conn_tuple]\n\n        for conn_tuple, item in conns_to_remove.items():\n            self.removeItem(self._connections[conn_tuple])\n            del self._connections[conn_tuple]\n\n        if (added_item or items_to_remove) and \\\n           (networkx_node_graph.nodes or networkx_node_graph.edges):\n            center_x = self.parent()._size.width() // 2\n            center_y = self.parent()._size.height() // 2\n            pos = networkx.kamada_kawai_layout(networkx_node_graph,\n                                               center=(center_x, center_y),\n                                               scale=400.0)\n\n            for name, item in self._scene_items.items():\n                if name in pos:\n                    self._animations_waiting.add(name)\n                    item.set_position(pos[name][0], pos[name][1])\n\n        if not self._animations_waiting:\n            self.update_connections()\n\n        self.update()\n\n    def update_connections(self):\n        for (node_name, conn, direction), item in self._connections.items():\n            if node_name in self._scene_items and conn.conn_name in self._scene_items:\n                if direction == 'node_to_conn':\n                    source = self._scene_items[node_name].right()\n                    target = self._scene_items[conn.conn_name].left()\n                else:\n                    source = self._scene_items[conn.conn_name].right()\n                    target = self._scene_items[node_name].left()\n\n                item.update_path(source, target)\n\n    def update_node_params(self, node_name, new_params, new_warnings):\n        if node_name in self._scene_items:\n            self._scene_items[node_name].update_params(new_params, new_warnings)\n\n    def update_lifecycle_state(self, node_name, new_state):\n        if node_name in self._scene_items:\n            self._scene_items[node_name].update_lifecycle_state(new_state)\n\n    def update_component_manager_nodes(self, node_name, managed_nodes):\n        if node_name in self._scene_items:\n            self._scene_items[node_name].update_managed_nodes(managed_nodes)\n\n    def update_hidden_nodes(self, node_names):\n        before = set(self._hidden_nodes)\n\n        for node_name, is_visible in node_names:\n            if is_visible:\n                self._hidden_nodes.discard(node_name)\n            else:\n                self._hidden_nodes.add(node_name)\n\n        if before != self._hidden_nodes:\n            self.update_nodes(self._graph_nodes_list)\n\n    def update_hidden_topics(self, topic_names):\n        before = set(self._hidden_topics)\n\n        for topic_name, is_visible in topic_names:\n            if is_visible:\n                self._hidden_topics.discard(topic_name)\n            else:\n                self._hidden_topics.add(topic_name)\n\n        if before != self._hidden_topics:\n            self.update_nodes(self._graph_nodes_list)\n\n    def update_hidden_services(self, service_names):\n        before = set(self._hidden_services)\n\n        for service_name, is_visible in service_names:\n            if is_visible:\n                self._hidden_services.discard(service_name)\n            else:\n                self._hidden_services.add(service_name)\n\n        if before != self._hidden_services:\n            self.update_nodes(self._graph_nodes_list)\n\n    def update_hidden_actions(self, action_names):\n        before = set(self._hidden_actions)\n\n        for action_name, is_visible in action_names:\n            if is_visible:\n                self._hidden_actions.discard(action_name)\n            else:\n                self._hidden_actions.add(action_name)\n\n        if before != self._hidden_actions:\n            self.update_nodes(self._graph_nodes_list)\n\n    def complete_animation(self, name):\n        if name in self._animations_waiting:\n            self._animations_waiting.remove(name)\n        self.update_connections()\n        self.update()\n\n\nclass NodeGraphicsView(QtWidgets.QGraphicsView):\n\n    def __init__(self, parent):\n        super().__init__(parent)\n\n        # Setup Qt\n        self.setRenderHint(QtGui.QPainter.Antialiasing, True)\n        self.setRenderHint(QtGui.QPainter.TextAntialiasing, True)\n        self.setRenderHint(QtGui.QPainter.HighQualityAntialiasing, True)\n        self.setRenderHint(QtGui.QPainter.SmoothPixmapTransform, True)\n        self.setRenderHint(QtGui.QPainter.NonCosmeticDefaultPen, True)\n        self.setViewportUpdateMode(QtWidgets.QGraphicsView.FullViewportUpdate)\n        self.setTransformationAnchor(QtWidgets.QGraphicsView.AnchorUnderMouse)\n        self.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)\n        self.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)\n\n        # Instantiate the scene\n        scene = NetworkScene(self)\n        self.setScene(scene)\n\n        self.setMouseTracking(True)\n\n        self.selection_box = QtWidgets.QRubberBand(QtWidgets.QRubberBand.Rectangle, self)\n        self.selection_origin = None\n\n        self._size = QtCore.QSize(500, 500)\n\n    # PyQt method override\n    def wheelEvent(self, event):\n        self.setTransformationAnchor(QtWidgets.QGraphicsView.AnchorUnderMouse)\n\n        inFactor = 1.15\n        outFactor = 1 / inFactor\n\n        if event.angleDelta().y() > 0:\n            zoomFactor = inFactor\n        else:\n            zoomFactor = outFactor\n\n        self.scale(zoomFactor, zoomFactor)\n\n        super().wheelEvent(event)\n\n    # PyQt method override\n    def mousePressEvent(self, event):\n        if (event.button() == QtCore.Qt.LeftButton and\n                event.modifiers() == QtCore.Qt.NoModifier and\n                self.scene().itemAt(self.mapToScene(event.pos()), QtGui.QTransform()) is None):\n            self.selection_origin = event.pos()\n            self.selection_box.setGeometry(QtCore.QRect(event.pos(), QtCore.QSize()))\n            self.selection_box.show()\n\n        super().mousePressEvent(event)\n\n    # PyQt method override\n    def mouseMoveEvent(self, event):\n        if self.selection_origin is not None:\n            rect = QtCore.QRect(self.selection_origin, event.pos()).normalized()\n            self.selection_box.setGeometry(rect)\n\n        super().mouseMoveEvent(event)\n\n    # PyQt method override\n    def mouseReleaseEvent(self, event):\n        if self.selection_origin is not None:\n            rect = QtCore.QRect(self.selection_origin, event.pos()).normalized()\n            self.selection_box.setGeometry(rect)\n\n            painter_path = QtGui.QPainterPath()\n            rect = self.mapToScene(self.selection_box.geometry())\n            painter_path.addPolygon(rect)\n            self.selection_box.hide()\n            self.scene().setSelectionArea(painter_path)\n            self.selection_origin = None\n\n        super().mouseReleaseEvent(event)\n\n    # PyQt method override\n    def resizeEvent(self, event):\n        self._size = event.size()\n        return super().resizeEvent(event)\n\n    # PyQt method override\n    def sizeHint(self):\n        return self._size\n\n\nclass MainGrid(QtWidgets.QWidget):\n\n    def __init__(self, ros_network):\n        super().__init__()\n\n        self._ros_network = ros_network\n        self._node_parameters = {}\n        self._lifecycle_states = {}\n        self._component_manager_nodes = {}\n        self._node_list = {}\n        self._node_name_to_row = SortedOrderedSet()\n        self._topic_name_to_row = SortedOrderedSet()\n        self._service_name_to_row = SortedOrderedSet()\n        self._action_name_to_row = SortedOrderedSet()\n\n        self.setWindowTitle('ROS 2 network visualizer')\n\n        self._splitter = QtWidgets.QSplitter(QtCore.Qt.Horizontal)\n\n        self._gv = NodeGraphicsView(self)\n\n        self._model = QtGui.QStandardItemModel(self)\n        self._model.setRowCount(0)\n\n        self._labels_to_rows = {\n            'Nodes': 0,\n            'Topics': 1,\n            'Services': 2,\n            'Actions': 3,\n        }\n\n        label = ''\n        for name in self._labels_to_rows.keys():\n            self._model.invisibleRootItem().appendRow([self.create_checkable_item(name, False)])\n            if label:\n                label = label + ', '\n            label = label + name\n        self._model.setHorizontalHeaderLabels([label])\n        self._model.itemChanged.connect(self.state_changed)\n\n        self._tree = QtWidgets.QTreeView(self)\n        self._tree.setModel(self._model)\n        self._tree.expandAll()\n\n        self._splitter.addWidget(self._gv)\n        self._splitter.addWidget(self._tree)\n\n        self._hlayout = QtWidgets.QHBoxLayout()\n        self._hlayout.addWidget(self._splitter)\n\n        self.setLayout(self._hlayout)\n\n        # TODO(clalancette): This sucks that we are polling to get changes to\n        # the ROS graph.  Unfortunately the graph APIs are not available in\n        # Python, so this is the best we can do for now.\n        self._timer = QtCore.QTimer()\n        self._timer.timeout.connect(self.get_ros_graph_updates)\n        self._timer.start(500)\n\n    # PyQt method override\n    def closeEvent(self, *args, **kwargs):\n        self._ros_network.shutdown()\n\n    def state_changed(self, item):\n        parent = item.parent()\n        if parent is None:\n            item_type = item.text()\n        else:\n            item_type = parent.text()\n        item_name = item.text()\n        item_state = item.checkState()\n\n        item_list = []\n\n        if parent is not None:\n            # If the parent is not None, that means this is an individual\n            # check-box, and we {en,dis}able just that item\n            item_list.append((item_name, item_state == QtCore.Qt.Checked))\n        else:\n            # If the parent is None, this is a top-level check-box and we want\n            # to {en,dis}able everything\n\n            is_visible = item_state == QtCore.Qt.Checked\n\n            this_row = self._model.invisibleRootItem().child(self._labels_to_rows[item_name])\n            # If we leave the itemChanged signal in place, then Qt emits a\n            # itemChanged signal for *every* item we change the check state for,\n            # which can cause us to do many redraws and hold up the UI.  Instead\n            # we disconnect the signal temporarily, mark all of the check boxes,\n            # and then reenable the signal.  Then below we emit one large change\n            # which is a lot faster.\n            self._model.itemChanged.disconnect(self.state_changed)\n            for i in range(0, this_row.rowCount()):\n                this_row.child(i).setCheckState(item_state)\n                item_list.append((this_row.child(i).text(), is_visible))\n            self._model.itemChanged.connect(self.state_changed)\n\n        if item_type == 'Nodes':\n            self._gv.scene().updateHiddenNodes.emit(item_list)\n        elif item_type == 'Topics':\n            self._gv.scene().updateHiddenTopics.emit(item_list)\n        elif item_type == 'Services':\n            self._gv.scene().updateHiddenServices.emit(item_list)\n        elif item_type == 'Actions':\n            self._gv.scene().updateHiddenActions.emit(item_list)\n\n    def create_checkable_item(self, name, is_hidden):\n        item = QtGui.QStandardItem(name)\n        item.setCheckable(True)\n        if not is_hidden:\n            item.setCheckState(QtCore.Qt.Checked)\n        return item\n\n    def update_nodes(self):\n        node_list = self._ros_network.get_nodes()\n\n        if node_list == self._node_list:\n            return\n\n        # Here, we assume that we are going to remove *all* of the existing\n        # nodes.  As we see node names in the new list, we remove them from\n        # this list, which means at the end we are left with just the ones\n        # we should remove.\n        nodes_to_remove = dict(self._node_list)\n        topics_to_remove = self._topic_name_to_row.copy()\n        services_to_remove = self._service_name_to_row.copy()\n        actions_to_remove = self._action_name_to_row.copy()\n\n        for name, node in node_list.items():\n            if name not in self._node_list:\n                index = self._node_name_to_row.add(name)\n                checked_node = self.create_checkable_item(name, node_is_hidden(name))\n                self._model.invisibleRootItem().child(\n                    self._labels_to_rows['Nodes']).insertRow(index, checked_node)\n                if node_is_hidden(name):\n                    self._gv.scene().updateHiddenNodes.emit([(name, False)])\n            self._node_list[name] = node\n\n            for topic in node.topic_publishers + node.topic_subscribers:\n                if topic.conn_name not in self._topic_name_to_row:\n                    index = self._topic_name_to_row.add(topic.conn_name)\n                    hidden = topic_is_hidden(topic.conn_name, topic.conn_type)\n                    checked_topic = self.create_checkable_item(topic.conn_name, hidden)\n                    self._model.invisibleRootItem().child(\n                        self._labels_to_rows['Topics']).insertRow(index, checked_topic)\n                    if hidden:\n                        self._gv.scene().updateHiddenTopics.emit([(topic.conn_name, False)])\n\n                if topic.conn_name in topics_to_remove:\n                    topics_to_remove.discard(topic.conn_name)\n\n            for service in node.service_clients + node.service_servers:\n                if service.conn_name not in self._service_name_to_row:\n                    index = self._service_name_to_row.add(service.conn_name)\n                    hidden = service_is_hidden(service.conn_name, service.conn_type)\n                    checked_service = self.create_checkable_item(service.conn_name, hidden)\n                    self._model.invisibleRootItem().child(\n                        self._labels_to_rows['Services']).insertRow(index, checked_service)\n                    if hidden:\n                        self._gv.scene().updateHiddenServices.emit([(service.conn_name, False)])\n\n                if service.conn_name in services_to_remove:\n                    services_to_remove.discard(service.conn_name)\n\n            for action in node.action_clients + node.action_servers:\n                if action.conn_name not in self._action_name_to_row:\n                    index = self._action_name_to_row.add(action.conn_name)\n                    checked_action = self.create_checkable_item(action.conn_name, False)\n                    self._model.invisibleRootItem().child(\n                        self._labels_to_rows['Actions']).insertRow(index, checked_action)\n\n                if action.conn_name in actions_to_remove:\n                    actions_to_remove.discard(action.conn_name)\n\n            if name in nodes_to_remove:\n                del nodes_to_remove[name]\n\n        for name, node in nodes_to_remove.items():\n            if name in self._node_list:\n                del self._node_list[name]\n            if name in self._node_parameters:\n                del self._node_parameters[name]\n            if name in self._lifecycle_states:\n                del self._lifecycle_states[name]\n            if name in self._component_manager_nodes:\n                del self._component_manager_nodes[name]\n\n            if name in self._node_name_to_row:\n                found_row = self._node_name_to_row.index(name)\n                child = self._model.invisibleRootItem().child(self._labels_to_rows['Nodes'])\n                child.removeRow(found_row)\n                self._node_name_to_row.discard(name)\n\n        for topic in topics_to_remove:\n            if topic in self._topic_name_to_row:\n                found_row = self._topic_name_to_row.index(topic)\n                child = self._model.invisibleRootItem().child(self._labels_to_rows['Topics'])\n                child.removeRow(found_row)\n                self._topic_name_to_row.discard(topic)\n\n        for service in services_to_remove:\n            if service in self._service_name_to_row:\n                found_row = self._service_name_to_row.index(service)\n                child = self._model.invisibleRootItem().child(self._labels_to_rows['Services'])\n                child.removeRow(found_row)\n                self._service_name_to_row.discard(service)\n\n        for action in actions_to_remove:\n            if action in self._action_name_to_row:\n                found_row = self._action_name_to_row.index(action)\n                child = self._model.invisibleRootItem().child(self._labels_to_rows['Actions'])\n                child.removeRow(found_row)\n                self._action_name_to_row.discard(action)\n\n        self._gv.scene().newNodes.emit(self._node_list)\n\n    def update_parameters(self, node_name):\n        if node_name not in self._node_parameters:\n            self._node_parameters[node_name] = ({}, '')\n\n        params, warnings = self._ros_network.get_node_parameters(node_name)\n        if (params and params != self._node_parameters[node_name][0]) or \\\n           (warnings and warnings != self._node_parameters[node_name][1]):\n            self._gv.scene().newNodeParams.emit(node_name, params, warnings)\n            self._node_parameters[node_name] = (dict(params), warnings)\n\n    def update_lifecycle_state(self, node_name):\n        if node_name not in self._lifecycle_states:\n            self._lifecycle_states[node_name] = None\n\n        ret = self._ros_network.get_lifecycle_node_state(node_name)\n        if ret and ret != self._lifecycle_states[node_name]:\n            self._gv.scene().newLifecycleState.emit(node_name, ret)\n            self._lifecycle_states[node_name] = ret\n\n    def update_component_manager_nodes(self, node_name):\n        if node_name not in self._component_manager_nodes:\n            self._component_manager_nodes[node_name] = []\n\n        ret = self._ros_network.get_component_manager_nodes(node_name)\n        if ret and ret != self._component_manager_nodes[node_name]:\n            self._gv.scene().newComponentManagerNodes.emit(node_name, ret)\n            self._component_manager_nodes[node_name] = list(ret)\n\n    def get_ros_graph_updates(self):\n        self.update_nodes()\n\n        # TODO(clalancette): We need to do this every time we update so that\n        # we keep the state machines running.  But it means that we are\n        # iterating over the list twice, once in update_nodes and once here.\n        # On the other hand, update_nodes is expensive if the list updates,\n        # so we don't necessarily want to include that there.  Not sure what\n        # to do about this yet.\n        for name, node in self._node_list.items():\n            self.update_parameters(name)\n            if node.is_lifecycle:\n                self.update_lifecycle_state(name)\n            if node.is_component_manager:\n                self.update_component_manager_nodes(name)\n\n\n# TODO(clalancette): We currently rely on /parameter_events to get updates about\n# parameters in the system.  In the case where the user has that disabled, we\n# should provide an alternative way to refresh (button, or periodic, maybe?)\n\n# TODO(clalancette): It sure would be nice if the connections animated along\n# with everything else.\n\n# TODO(clalancette): It would be nice if there was an arrow or other indication\n# on whether a connection is a publication, subscription, etc.\n\n# TODO(clalancette): On large graphs, the redraw update can take a long time.\n# What's going on with that?\n\n\ndef main():\n    app = QtWidgets.QApplication([])\n\n    # Note that we set this up *before* calling rclpy.init()\n    # so that we don't override ROS signal handlers\n    def do_shutdown(a, b):\n        ros_network.shutdown()\n        app.quit()\n    signal.signal(signal.SIGINT, do_shutdown)\n\n    ros_network = ROSGraph()\n\n    grid = MainGrid(ros_network)\n    grid.show()\n\n    return app.exec_()\n\n\nif __name__ == '__main__':\n    sys.exit(main())\n"}\n{"instruction": "Write a ROS2 Python node named xbox_teleop_node.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "#!/usr/bin/env python3\n\"\"\"\nXbox 手柄实时控制节点\n使用笛卡尔空间控制机械臂末端执行器\n\n控制映射：\n- 左摇杆：X/Y 平移\n- LT/RT：Z 方向平移\n- 右摇杆：Yaw/Roll 旋转\n- LB/RB：Pitch 旋转\n- A 键：切换速度档位（5 档）\n- B 键：回到 home 位置\n- Y 键：切换重力补偿模式（手动示教/拖动）\n- Menu 键：切换主从遥操作（can0 主臂可拖动 / can1 从臂实时跟随）\n\"\"\"\n\nimport rclpy\nfrom rclpy.node import Node\nfrom rclpy.action import ActionClient\nfrom rclpy.qos import QoSProfile, ReliabilityPolicy, HistoryPolicy\nfrom sensor_msgs.msg import Joy\nimport socket\nimport struct\nfrom geometry_msgs.msg import PoseStamped, Pose\nfrom moveit_msgs.action import MoveGroup, ExecuteTrajectory\nfrom moveit_msgs.msg import (\n    MotionPlanRequest,\n    Constraints,\n    PositionConstraint,\n    OrientationConstraint,\n    BoundingVolume,\n    PlanningOptions,\n    RobotState,\n    JointConstraint,\n)\nfrom moveit_msgs.srv import GetCartesianPath, GetPositionIK\nfrom std_srvs.srv import SetBool\nfrom shape_msgs.msg import SolidPrimitive\nfrom trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint\nfrom sensor_msgs.msg import JointState\nfrom control_msgs.action import FollowJointTrajectory\nfrom builtin_interfaces.msg import Duration\nimport tf2_ros\nimport tf2_geometry_msgs\nimport math\nimport numpy as np\nimport copy\n\n# Use scipy instead of tf_transformations\nfrom scipy.spatial.transform import Rotation as R\n\ndef quaternion_from_euler(roll, pitch, yaw):\n    \"\"\"将欧拉角转换为四元数 (x, y, z, w)\"\"\"\n    rot = R.from_euler('xyz', [roll, pitch, yaw])\n    quat = rot.as_quat()  # Returns (x, y, z, w)\n    return quat\n\ndef euler_from_quaternion(quaternion):\n    \"\"\"将四元数 (x, y, z, w) 转换为欧拉角\"\"\"\n    rot = R.from_quat(quaternion)\n    euler = rot.as_euler('xyz')\n    return euler[0], euler[1], euler[2]  # roll, pitch, yaw\n\n\nclass XboxTeleopNode(Node):\n    def __init__(self):\n        super().__init__('xbox_teleop_node')\n        \n        # Declare parameters\n        self.declare_parameter('update_rate', 50.0)  # Hz - 50Hz for better smoothness\n        self.declare_parameter('planning_group', 'arm')\n        self.declare_parameter('base_frame', 'base_link')\n        self.declare_parameter('end_effector_frame', 'end_effector')\n        self.declare_parameter('deadzone', 0.15)  # Joystick deadzone\n        self.declare_parameter('debug_input', False)  # Debug mode\n        self.declare_parameter('use_fast_ik_mode', True)  # Use fast IK mode for 50Hz control\n        \n        # Cartesian velocity parameters (actual physical units)\n        self.declare_parameter('max_linear_velocity', 0.15)   # m/s max linear velocity\n        self.declare_parameter('max_angular_velocity', 1.5)   # rad/s max angular velocity\n        \n        # Joint output smoothing parameters\n        self.declare_parameter('joint_smoothing_alpha', 0.15)  # Joint smoothing coefficient\n        self.declare_parameter('max_joint_velocity', 1.5)      # rad/s max single joint velocity\n        self.declare_parameter('max_joint_acceleration', 5.0)  # rad/s² max single joint acceleration\n        \n        # Input smoothing parameters\n        self.declare_parameter('input_smoothing_factor', 0.5)  # Input smoothing coefficient\n        \n        # Singularity protection parameters\n        self.declare_parameter('max_ik_jump_threshold', 0.5)   # rad max allowed single joint jump\n        self.declare_parameter('singularity_warning_count', 5) # Consecutive rejection warning threshold\n        \n        # Collision detection parameters\n        self.declare_parameter('enable_collision_check', True)  # Enable collision detection after initialization\n        \n        # Master-slave teleoperation parameters (Menu button triggered)\n        self.declare_parameter('master_slave_enabled', True)\n        self.declare_parameter('master_joint_state_topic', '/arm1/joint_states')\n        self.declare_parameter('master_trajectory_topic', '/arm1/arm1_arm_controller/joint_trajectory')\n        self.declare_parameter('master_zero_torque_service', '/el_a3/set_zero_torque_mode')\n        self.declare_parameter('master_joint_prefix', 'arm1_')\n        self.declare_parameter('slave_joint_state_topic', '/arm2/joint_states')\n        self.declare_parameter('slave_trajectory_topic', '/arm2/arm2_arm_controller/joint_trajectory')\n        self.declare_parameter('slave_joint_prefix', 'arm2_')\n        self.declare_parameter('go_zero_duration', 3.0)\n        \n        # Get parameters\n        self.update_rate = self.get_parameter('update_rate').value\n        self.planning_group = self.get_parameter('planning_group').value\n        self.base_frame = self.get_parameter('base_frame').value\n        self.end_effector_frame = self.get_parameter('end_effector_frame').value\n        self.deadzone = self.get_parameter('deadzone').value\n        self.debug_input = self.get_parameter('debug_input').value\n        self.use_fast_ik_mode = self.get_parameter('use_fast_ik_mode').value\n        \n        # Cartesian velocity parameters\n        self.max_linear_velocity = self.get_parameter('max_linear_velocity').value\n        self.max_angular_velocity = self.get_parameter('max_angular_velocity').value\n        \n        # Joint smoothing parameters\n        self.joint_smoothing_alpha = self.get_parameter('joint_smoothing_alpha').value\n        self.max_joint_velocity = self.get_parameter('max_joint_velocity').value\n        self.max_joint_acceleration = self.get_parameter('max_joint_acceleration').value\n        self.last_joint_velocities = None  # Previous frame joint velocities (for acceleration limiting)\n        \n        # Input smoothing parameters\n        self.input_smoothing_factor = self.get_parameter('input_smoothing_factor').value\n        \n        # Singularity protection parameters\n        self.max_ik_jump_threshold = self.get_parameter('max_ik_jump_threshold').value\n        self.singularity_warning_count = self.get_parameter('singularity_warning_count').value\n        self.consecutive_ik_rejects = 0  # Consecutive rejection counter\n        self.ik_seed_just_initialized = False  # IK seed just initialized flag, skip first frame jump detection\n        \n        # Collision detection parameters\n        self.enable_collision_check = self.get_parameter('enable_collision_check').value\n        self.collision_check_active = False  # Disabled during initialization, enabled after completion\n        \n        # Master-slave teleoperation parameters\n        self.master_slave_enabled = self.get_parameter('master_slave_enabled').value\n        master_joint_state_topic = self.get_parameter('master_joint_state_topic').value\n        master_trajectory_topic = self.get_parameter('master_trajectory_topic').value\n        master_zero_torque_service = self.get_parameter('master_zero_torque_service').value\n        master_prefix = self.get_parameter('master_joint_prefix').value\n        slave_joint_state_topic = self.get_parameter('slave_joint_state_topic').value\n        slave_trajectory_topic = self.get_parameter('slave_trajectory_topic').value\n        slave_prefix = self.get_parameter('slave_joint_prefix').value\n        self.go_zero_duration = self.get_parameter('go_zero_duration').value\n        \n        # Calculate time step\n        self.dt = 1.0 / self.update_rate\n        \n        # Debug counter - avoid log spam\n        self.debug_counter = 0\n        \n        # Speed level settings (5 levels) - using speed scale factor\n        # Actual speed = max_velocity * factor\n        self.speed_levels = [\n            {'name': '极慢', 'factor': 0.1},   # 10% 最大速度\n            {'name': '慢', 'factor': 0.25},    # 25% 最大速度\n            {'name': '中', 'factor': 0.5},     # 50% 最大速度\n            {'name': '快', 'factor': 0.75},    # 75% 最大速度\n            {'name': '最大', 'factor': 1.0},   # 100% 最大速度\n        ]\n        self.current_speed_level = 2  # Default medium speed (0-indexed)\n        self.speed_factor = self.speed_levels[self.current_speed_level]['factor']\n        \n        # Button state tracking (for debouncing)\n        self.last_a_button = 0\n        self.last_b_button = 0\n        self.last_x_button = 0\n        self.last_y_button = 0\n        self.is_going_home = False  # Whether currently returning to home/zero\n        self.home_start_time = None  # Home return start time\n        self.home_timeout = 15.0  # Home return timeout (seconds)\n        \n        # Zero-torque (gravity compensation) mode\n        self.zero_torque_mode = False\n        self.zero_torque_client = self.create_client(\n            SetBool, '/el_a3/set_zero_torque_mode')\n        \n        # Master-slave teleoperation mode state\n        self.master_slave_mode = False\n        self.entering_master_slave = False  # Switching in progress (go-to-zero process)\n        self.last_menu_button = 0\n        \n        # Slave arm ROS2 interface\n        # Use same BEST_EFFORT QoS as main arm trajectory publisher to match arm_controller subscriber\n        slave_trajectory_qos = QoSProfile(\n            reliability=ReliabilityPolicy.BEST_EFFORT,\n            history=HistoryPolicy.KEEP_LAST,\n            depth=1\n        )\n        self.slave_joint_state = None\n        self.slave_joint_sub = self.create_subscription(\n            JointState, slave_joint_state_topic,\n            self.slave_joint_state_callback, 10)\n        self.slave_trajectory_pub = self.create_publisher(\n            JointTrajectory, slave_trajectory_topic, slave_trajectory_qos)\n        \n        # Master arm namespace interface (for master arm communication in multi_arm mode)\n        self.master_joint_state_ms = None  # Master-slave mode dedicated\n        self.master_joint_sub_ms = self.create_subscription(\n            JointState, master_joint_state_topic,\n            self.master_joint_state_ms_callback, 10)\n        self.master_trajectory_pub_ms = self.create_publisher(\n            JointTrajectory, master_trajectory_topic, slave_trajectory_qos)\n        self.master_zero_torque_client_ms = self.create_client(\n            SetBool, master_zero_torque_service)\n        \n        # Master-slave mode joint names (no prefix, matches URDF; arms distinguished by topic namespace)\n        self.slave_joint_names = [f\"L{i}_joint\" for i in range(1, 7)]\n        self.master_joint_names_ms = [f\"L{i}_joint\" for i in range(1, 7)]\n        \n        # D-pad controls gripper motor (ID=7)\n        self.last_dpad_up = 0\n        self.last_dpad_down = 0\n        self.gripper_torque = 0.0  # Current gripper torque\n        self.gripper_torque_step = 1.0  # Torque increment per button press (Nm)\n        self.gripper_motor_id = 7\n        \n        # Initialize CAN socket for direct gripper command sending\n        self.can_socket = None\n        self.gripper_enabled = False\n        try:\n            self.can_socket = socket.socket(socket.AF_CAN, socket.SOCK_RAW, socket.CAN_RAW)\n            self.can_socket.bind(('can0',))\n            self.get_logger().info('CAN socket 初始化成功，已启用夹爪控制')\n            # Enable gripper motor\n            self.enable_gripper_motor()\n        except Exception as e:\n            self.get_logger().warn(f'CAN socket 初始化失败，已禁用夹爪控制：{e}')\n        \n        # Motor 7 (gripper) parameter ranges for MIT mode\n        self.P_MIN, self.P_MAX = -12.57, 12.57\n        self.V_MIN, self.V_MAX = -50.0, 50.0\n        self.KP_MIN, self.KP_MAX = 0.0, 500.0\n        self.KD_MIN, self.KD_MAX = 0.0, 5.0\n        self.T_MIN, self.T_MAX = -12.0, 12.0\n        \n        # Motor 7 master-slave state\n        self.motor7_position = 0.0\n        self.motor7_valid = False\n        \n        # CAN-based slave arm direct control parameters (all 7 motors)\n        self.slave_follow_kp = 80.0  # MIT mode Kp for position follow\n        self.slave_follow_kd = 2.0   # MIT mode Kd for velocity damping\n        # Motor direction mapping: joint_pos * direction = motor_pos (from URDF ros2_control config)\n        # Motors 1-6 (L1-L6 joints), Motor 7 (gripper, no direction inversion needed)\n        self.motor_directions = [-1.0, 1.0, -1.0, 1.0, -1.0, 1.0, 1.0]  # 7 motors\n        self._slave_can_going_zero = False\n        self._slave_zero_start_positions = [0.0] * 7  # Motors 1-7 (in motor coordinate frame)\n        self._slave_zero_frame = 0\n        self._slave_zero_total_frames = 0\n        \n        # Set can0 socket to non-blocking for Motor 7 feedback reading\n        if self.can_socket is not None:\n            self.can_socket.setblocking(False)\n        \n        # CAN1 socket for Motor 7 slave follow (only if master-slave enabled)\n        self.can1_socket = None\n        if self.master_slave_enabled:\n            try:\n                self.can1_socket = socket.socket(socket.AF_CAN, socket.SOCK_RAW, socket.CAN_RAW)\n                self.can1_socket.bind(('can1',))\n                self.can1_socket.setblocking(False)\n                self._enable_motor_on_socket(self.can1_socket, self.gripper_motor_id)\n                self.get_logger().info('CAN1 socket 初始化成功（从臂 Motor 7 跟随）')\n            except Exception as e:\n                self.get_logger().warn(f'CAN1 socket 初始化失败，从臂 Motor 7 跟随不可用：{e}')\n        \n        # Input smoothing filter state (exponential moving average)\n        self.smoothed_vx = 0.0  # Smoothed X velocity\n        self.smoothed_vy = 0.0  # Smoothed Y velocity\n        self.smoothed_vz = 0.0  # Smoothed Z velocity\n        self.smoothed_vroll = 0.0  # Smoothed Roll angular velocity\n        self.smoothed_vpitch = 0.0  # Smoothed Pitch angular velocity\n        self.smoothed_vyaw = 0.0  # Smoothed Yaw angular velocity\n        \n        # Joint output smoothing state\n        self.smoothed_joint_positions = None  # Smoothed joint positions\n        \n        # Accumulated deltas (for accumulating input during motion)\n        self.pending_dx = 0.0\n        self.pending_dy = 0.0\n        self.pending_dz = 0.0\n        self.pending_droll = 0.0\n        self.pending_dpitch = 0.0\n        self.pending_dyaw = 0.0\n        \n        # Subscribe to controller input\n        self.joy_sub = self.create_subscription(\n            Joy,\n            'joy',\n            self.joy_callback,\n            10\n        )\n        \n        # TF2 listener\n        self.tf_buffer = tf2_ros.Buffer()\n        self.tf_listener = tf2_ros.TransformListener(self.tf_buffer, self)\n        \n        # Target pose publisher\n        self.target_pose_pub = self.create_publisher(\n            PoseStamped,\n            '/target_pose',\n            10\n        )\n        \n        # Cartesian path service client\n        self.cartesian_path_client = self.create_client(\n            GetCartesianPath,\n            '/compute_cartesian_path'\n        )\n        \n        # IK service client - for fast control\n        self.ik_client = self.create_client(\n            GetPositionIK,\n            '/compute_ik'\n        )\n        \n        # Direct joint trajectory publishing - for fast control\n        # Use BEST_EFFORT QoS to match arm_controller subscription settings\n        trajectory_qos = QoSProfile(\n            reliability=ReliabilityPolicy.BEST_EFFORT,\n            history=HistoryPolicy.KEEP_LAST,\n            depth=1\n        )\n        self.joint_trajectory_pub = self.create_publisher(\n            JointTrajectory,\n            '/arm_controller/joint_trajectory',\n            trajectory_qos\n        )\n        \n        # Joint trajectory Action client - for direct trajectory sending\n        self.follow_joint_trajectory_client = ActionClient(\n            self,\n            FollowJointTrajectory,\n            '/arm_controller/follow_joint_trajectory'\n        )\n        \n        # Subscribe to current joint states\n        self.current_joint_state = None\n        self.joint_state_sub = self.create_subscription(\n            JointState,\n            '/joint_states',\n            self.joint_state_callback,\n            10\n        )\n        \n        # Joint names\n        self.joint_names = ['L1_joint', 'L2_joint', 'L3_joint', 'L4_joint', 'L5_joint', 'L6_joint']\n        \n        # [Debug] IK solution publisher - for Foxglove tracking\n        self.ik_solution_pub = self.create_publisher(\n            JointState,\n            '/debug/ik_solution',\n            10\n        )\n        \n        # [Debug] Raw IK solution publisher (before processing) - for comparison\n        self.ik_raw_solution_pub = self.create_publisher(\n            JointState,\n            '/debug/ik_raw_solution',\n            10\n        )\n        \n        # IK request state tracking (for fast IK mode)\n        self.pending_ik_request = False  # Whether there is a pending IK request\n        self.last_ik_joint_positions = None  # Cache of last IK joint positions\n        \n        # Execute trajectory Action client\n        self.execute_trajectory_client = ActionClient(\n            self,\n            ExecuteTrajectory,\n            '/execute_trajectory'\n        )\n        \n        # MoveGroup Action client (for returning to home)\n        self.move_group_client = ActionClient(\n            self,\n            MoveGroup,\n            '/move_action'\n        )\n        \n        # State variables\n        self.current_joy = None\n        self.target_pose = None\n        self.is_moving = False\n        self.last_update_time = self.get_clock().now()\n        self.pose_initialized = False  # Whether pose is properly initialized\n        self.last_sent_pose = None  # Last sent pose, for change detection\n        self.min_move_threshold = 0.00005  # Minimum move threshold (meters)\n        self.move_start_time = None  # Motion start time, for timeout detection\n        self.move_timeout = 2.0  # Motion timeout (seconds)\n        \n        # Wait for services\n        if self.use_fast_ik_mode:\n            self.get_logger().info('等待 IK 服务（快速模式）...')\n            self.ik_client.wait_for_service()\n            self.get_logger().info('IK 服务已连接：使用 50Hz 快速 IK 控制模式')\n        else:\n            self.get_logger().info('等待笛卡尔路径服务...')\n            self.cartesian_path_client.wait_for_service()\n        self.get_logger().info('等待轨迹执行服务...')\n        self.execute_trajectory_client.wait_for_server()\n        self.get_logger().info('等待 MoveGroup 服务...')\n        self.move_group_client.wait_for_server()\n        self.get_logger().info('服务已连接')\n        \n        # [Auto home on startup]\n        # 1. Wait for joint states to be available (ensure motor positions are read)\n        self.get_logger().info('等待关节状态（读取电机位置）...')\n        self.wait_for_joint_states()\n        \n        # 2. Print current joint positions\n        if self.current_joint_state:\n            self.get_logger().info('已读取当前电机位置：')\n            for i, name in enumerate(self.current_joint_state.name):\n                if i < len(self.current_joint_state.position):\n                    self.get_logger().info(f'  {name}: {self.current_joint_state.position[i]:.4f} rad')\n        \n        # 3. Automatically move to zero position\n        self.get_logger().info('正在规划运动到零位...')\n        self.startup_go_zero()\n        \n        # Create timer for periodic target pose update\n        self.timer = self.create_timer(1.0 / self.update_rate, self.update_callback)\n        \n        self.get_logger().info('Xbox 手柄控制节点已启动')\n        self.get_logger().info(f'规划组：{self.planning_group}')\n        self.get_logger().info(f'末端执行器：{self.end_effector_frame}')\n        self.get_logger().info(f'更新频率：{self.update_rate} Hz（dt={self.dt*1000:.1f}ms）')\n        self.get_logger().info(f'最大线速度：{self.max_linear_velocity} m/s')\n        self.get_logger().info(f'最大角速度：{self.max_angular_velocity} rad/s')\n        self.get_logger().info(f'关节平滑：alpha={self.joint_smoothing_alpha}，max_vel={self.max_joint_velocity} rad/s')\n        if self.use_fast_ik_mode:\n            self.get_logger().info('控制模式：快速 IK 模式（50Hz 笛卡尔控制）')\n        else:\n            self.get_logger().info('控制模式：传统路径规划模式')\n        self.get_logger().info('=== 控制说明 ===')\n        self.get_logger().info('左摇杆：XY 平移 | LT/RT：Z 平移')\n        self.get_logger().info('右摇杆：Yaw/Roll | LB/RB：Pitch')\n        self.get_logger().info('A：切换速度档 | B：回 home | X：回零位')\n        self.get_logger().info('Y：切换重力补偿模式（手动示教/拖动）')\n        self.get_logger().info('Menu：切换主从遥操作（can0 主 / can1 从）')\n        self.log_speed_level()\n        \n    def sync_current_pose(self):\n        \"\"\"Sync current end effector pose from TF as target pose starting point\n        \n        Each call gets the latest actual pose, ensuring incremental motion\n        is based on the correct starting point.\n        \n        Returns:\n            bool: True on success, False on failure\n        \"\"\"\n        try:\n            # Try to get TF transform (with shorter timeout)\n            transform = self.tf_buffer.lookup_transform(\n                self.base_frame,\n                self.end_effector_frame,\n                rclpy.time.Time(),\n                timeout=rclpy.duration.Duration(seconds=0.1)  # Shorter timeout for faster response\n            )\n            \n            # Update target pose to current actual pose every time\n            self.target_pose = PoseStamped()\n            self.target_pose.header.frame_id = self.base_frame\n            self.target_pose.pose.position.x = transform.transform.translation.x\n            self.target_pose.pose.position.y = transform.transform.translation.y\n            self.target_pose.pose.position.z = transform.transform.translation.z\n            self.target_pose.pose.orientation = transform.transform.rotation\n            \n            if not self.pose_initialized:\n                self.get_logger().info(f'Initial pose sync: x={self.target_pose.pose.position.x:.4f}, '\n                                     f'y={self.target_pose.pose.position.y:.4f}, '\n                                     f'z={self.target_pose.pose.position.z:.4f}')\n                # [Key] If IK seed is preset (e.g., from home/zero callbacks), keep it.\n                # Otherwise initialize from current joint state.\n                if self.last_ik_joint_positions is None:\n                    # Only initialize from joint_states when IK seed is unset\n                    if self.current_joint_state:\n                        seed_positions = []\n                        for joint_name in self.joint_names:\n                            if joint_name in self.current_joint_state.name:\n                                idx = self.current_joint_state.name.index(joint_name)\n                                seed_positions.append(self.current_joint_state.position[idx])\n                            else:\n                                seed_positions.append(0.0)  # Default\n                        self.last_ik_joint_positions = seed_positions\n                        self.smoothed_joint_positions = list(seed_positions)\n                        self.last_joint_velocities = [0.0] * len(seed_positions)\n                        self.get_logger().info(f'IK 种子已从 joint_states 初始化：{[f\"{p:.3f}\" for p in self.last_ik_joint_positions]}')\n                        self.ik_seed_just_initialized = True\n                        self.consecutive_ik_rejects = 0\n                else:\n                    # IK seed already preset (from home/zero callbacks); only sync Cartesian pose\n                    self.get_logger().info(f'使用预设 IK 种子：{[f\"{p:.3f}\" for p in self.last_ik_joint_positions]}')\n                self.pose_initialized = True\n            \n            return True\n            \n        except Exception as e:\n            self.get_logger().debug(f'TF 查询失败：{str(e)}')\n            return False\n            \n    def joint_state_callback(self, msg):\n        \"\"\"Joint state callback\"\"\"\n        self.current_joint_state = msg\n    \n    def slave_joint_state_callback(self, msg):\n        \"\"\"Slave joint state callback (for master-slave mode)\"\"\"\n        self.slave_joint_state = msg\n    \n    def master_joint_state_ms_callback(self, msg):\n        \"\"\"Master namespace joint state callback (for master-slave mode)\"\"\"\n        self.master_joint_state_ms = msg\n    \n    def wait_for_joint_states(self, timeout_sec=10.0):\n        \"\"\"Wait for joint states (ensure motor positions are read)\"\"\"\n        import time\n        start_time = time.time()\n        while self.current_joint_state is None:\n            rclpy.spin_once(self, timeout_sec=0.1)\n            if time.time() - start_time > timeout_sec:\n                self.get_logger().warn('等待关节状态超时！将使用默认位置')\n                return False\n        return True\n    \n    def startup_go_zero(self):\n        \"\"\"Move to zero position on startup (sync), then enable collision checking\"\"\"\n        import time\n        \n        self.is_going_home = True\n        self.home_start_time = self.get_clock().now()\n        \n        # Wait for MoveGroup service to be fully ready (including planning scene)\n        self.get_logger().info('等待 MoveGroup 服务完全就绪...')\n        time.sleep(3.0)  # Wait for MoveGroup initialization\n        \n        # Retry mechanism\n        max_retries = 3\n        for retry in range(max_retries):\n            # Create MoveGroup request\n            goal_msg = MoveGroup.Goal()\n            goal_msg.request.group_name = self.planning_group\n            goal_msg.request.num_planning_attempts = 10\n            goal_msg.request.allowed_planning_time = 10.0\n            goal_msg.request.max_velocity_scaling_factor = 0.15  # Slower motion on startup for safety\n            goal_msg.request.max_acceleration_scaling_factor = 0.15\n            \n            # Set target joint positions (zero position)\n            # Zero position: all joints to zero\n            joint_names = ['L1_joint', 'L2_joint', 'L3_joint', 'L4_joint', 'L5_joint', 'L6_joint']\n            joint_values = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]  # All joints to zero\n            \n            constraints = Constraints()\n            for name, value in zip(joint_names, joint_values):\n                joint_constraint = JointConstraint()\n                joint_constraint.joint_name = name\n                joint_constraint.position = value\n                joint_constraint.tolerance_above = 0.01\n                joint_constraint.tolerance_below = 0.01\n                joint_constraint.weight = 1.0\n                constraints.joint_constraints.append(joint_constraint)\n            \n            goal_msg.request.goal_constraints = [constraints]\n            goal_msg.planning_options.plan_only = False\n            goal_msg.planning_options.replan = True\n            goal_msg.planning_options.replan_attempts = 3\n            \n            # Send request and wait for result\n            self.get_logger().info(f'发送零位运动请求...（第 {retry + 1}/{max_retries} 次）')\n            send_goal_future = self.move_group_client.send_goal_async(goal_msg)\n            \n            # Wait for goal acceptance\n            rclpy.spin_until_future_complete(self, send_goal_future, timeout_sec=10.0)\n            goal_handle = send_goal_future.result()\n            \n            if goal_handle and goal_handle.accepted:\n                self.get_logger().info('零位请求已接受，正在低速执行...')\n                \n                # Wait for execution to complete\n                result_future = goal_handle.get_result_async()\n                rclpy.spin_until_future_complete(self, result_future, timeout_sec=60.0)\n                \n                result = result_future.result()\n                self.is_going_home = False\n                self.home_start_time = None\n                \n                # Check result\n                try:\n                    if result and result.result and result.result.error_code.val == result.result.error_code.SUCCESS:\n                        self.get_logger().info('✓ 已低速移动到零位！')\n                        # [Improvement] Use zero position as starting point to avoid TF drift\n                        zero_joint_positions = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n                        self.last_ik_joint_positions = zero_joint_positions\n                        self.smoothed_joint_positions = list(zero_joint_positions)\n                        self.last_joint_velocities = [0.0] * 6\n                        self.ik_seed_just_initialized = True\n                        self.consecutive_ik_rejects = 0\n                        self.pose_initialized = False  # Still need Cartesian pose from TF\n                        self.get_logger().info('IK 种子已设置为零位')\n                        # Enable collision checking after successful motion\n                        if self.enable_collision_check:\n                            self.collision_check_active = True\n                            self.get_logger().info('✓ 已启用碰撞检测')\n                        return True\n                    else:\n                        error_code = 'unknown'\n                        if result and result.result and hasattr(result.result, 'error_code'):\n                            error_code = result.result.error_code.val\n                        self.get_logger().warn(f'零位执行失败：error_code={error_code}')\n                        # Reset state on failure\n                        self.pose_initialized = False\n                        self.smoothed_joint_positions = None\n                        self.last_ik_joint_positions = None\n                except Exception as e:\n                    self.get_logger().warn(f'解析零位结果失败：{e}')\n                    self.pose_initialized = False\n                    self.smoothed_joint_positions = None\n                    self.last_ik_joint_positions = None\n            else:\n                self.get_logger().warn('零位请求被拒绝，正在重试...')\n                time.sleep(2.0)  # Wait before retry\n        \n        self.get_logger().error('多次尝试后零位仍失败。请手动控制机械臂。')\n        self.is_going_home = False\n        self.home_start_time = None\n        self.pose_initialized = False\n        self.smoothed_joint_positions = None\n        self.last_ik_joint_positions = None\n        return False\n    \n    def joy_callback(self, msg):\n        \"\"\"Controller input callback\"\"\"\n        self.current_joy = msg\n        \n        # Debug mode: periodically print raw input\n        if self.debug_input:\n            self.debug_counter += 1\n            if self.debug_counter >= 40:  # Print every 2s (assumes 20Hz)\n                self.debug_counter = 0\n                if len(msg.axes) >= 6:\n                    self.get_logger().info(\n                        f'摇杆原始值：LX={msg.axes[0]:.3f} LY={msg.axes[1]:.3f} '\n                        f'LT={msg.axes[2]:.3f} RX={msg.axes[3]:.3f} '\n                        f'RY={msg.axes[4]:.3f} RT={msg.axes[5]:.3f}'\n                    )\n        \n    def apply_deadzone(self, value):\n        \"\"\"Apply stick deadzone\"\"\"\n        if abs(value) < self.deadzone:\n            return 0.0\n        # Linearly remap values outside deadzone\n        sign = 1.0 if value > 0 else -1.0\n        return sign * (abs(value) - self.deadzone) / (1.0 - self.deadzone)\n    \n    def apply_trigger_deadzone(self, trigger_value):\n        \"\"\"Apply trigger deadzone - for LT/RT\"\"\"\n        # Trigger range is 1.0 (not pressed) to -1.0 (fully pressed)\n        # Convert to 0.0 (not pressed) to 1.0 (fully pressed)\n        normalized = (1.0 - trigger_value) / 2.0\n        \n        # Apply deadzone (triggers need a slightly larger deadzone)\n        trigger_deadzone = self.deadzone * 1.5  # Larger deadzone for triggers\n        if normalized < trigger_deadzone:\n            return 0.0\n        # Linear mapping\n        return (normalized - trigger_deadzone) / (1.0 - trigger_deadzone)\n    \n    def log_speed_level(self):\n        \"\"\"Log current speed level\"\"\"\n        level = self.speed_levels[self.current_speed_level]\n        actual_linear = self.max_linear_velocity * self.speed_factor\n        actual_angular = self.max_angular_velocity * self.speed_factor\n        self.get_logger().info(\n            f'当前速度档位：{self.current_speed_level + 1}/5 [{level[\"name\"]}] '\n            f'(线速度={actual_linear*1000:.0f}mm/s，角速度={actual_angular:.2f}rad/s)'\n        )\n    \n    def switch_speed_level(self):\n        \"\"\"Switch speed level\"\"\"\n        self.current_speed_level = (self.current_speed_level + 1) % len(self.speed_levels)\n        level = self.speed_levels[self.current_speed_level]\n        self.speed_factor = level['factor']\n        self.log_speed_level()\n    \n    def go_home(self):\n        \"\"\"Return to home position\"\"\"\n        if self.is_moving or self.is_going_home:\n            self.get_logger().warn('当前正在执行其他动作，请稍后再试')\n            return\n        \n        self.is_going_home = True\n        self.home_start_time = self.get_clock().now()\n        self.get_logger().info('正在回到 home 位置...')\n        \n        # Create MoveGroup request\n        goal_msg = MoveGroup.Goal()\n        \n        # Configure motion request\n        goal_msg.request.group_name = self.planning_group\n        goal_msg.request.num_planning_attempts = 5\n        goal_msg.request.allowed_planning_time = 5.0\n        goal_msg.request.max_velocity_scaling_factor = 0.3\n        goal_msg.request.max_acceleration_scaling_factor = 0.3\n        \n        # Set target to named position \"home\"\n        goal_msg.request.goal_constraints = []\n        \n        # Use joint constraints to define home position\n        # Home position: L1=0, L2=45°, L3=-45°, L4=0, L5=0, L6=0\n        joint_names = ['L1_joint', 'L2_joint', 'L3_joint', 'L4_joint', 'L5_joint', 'L6_joint']\n        joint_values = [0.0, 0.785, -0.785, 0.0, 0.0, 0.0]  # Radians\n        \n        constraints = Constraints()\n        for name, value in zip(joint_names, joint_values):\n            joint_constraint = JointConstraint()\n            joint_constraint.joint_name = name\n            joint_constraint.position = value\n            joint_constraint.tolerance_above = 0.01\n            joint_constraint.tolerance_below = 0.01\n            joint_constraint.weight = 1.0\n            constraints.joint_constraints.append(joint_constraint)\n        \n        goal_msg.request.goal_constraints = [constraints]\n        \n        # Set planning options\n        goal_msg.planning_options.plan_only = False\n        goal_msg.planning_options.look_around = False\n        goal_msg.planning_options.replan = True\n        goal_msg.planning_options.replan_attempts = 3\n        \n        # Send request\n        send_goal_future = self.move_group_client.send_goal_async(goal_msg)\n        send_goal_future.add_done_callback(self.home_response_callback)\n    \n    def home_response_callback(self, future):\n        \"\"\"Home response callback\"\"\"\n        goal_handle = future.result()\n        \n        if not goal_handle.accepted:\n            self.get_logger().warn('home 请求被拒绝')\n            self.is_going_home = False\n            self.home_start_time = None\n            return\n        \n        self.get_logger().info('home 请求已接受，正在执行...')\n        result_future = goal_handle.get_result_async()\n        result_future.add_done_callback(self.home_result_callback)\n    \n    def home_result_callback(self, future):\n        \"\"\"Home result callback\"\"\"\n        result = future.result().result\n        self.is_going_home = False\n        self.home_start_time = None\n        \n        if result.error_code.val == result.error_code.SUCCESS:\n            self.get_logger().info('已回到 home 位置！')\n            # [Improvement] Use home as start to avoid TF drift\n            home_joint_positions = [0.0, 0.785, -0.785, 0.0, 0.0, 0.0]\n            self.last_ik_joint_positions = home_joint_positions\n            self.smoothed_joint_positions = list(home_joint_positions)\n            self.last_joint_velocities = [0.0] * 6\n            self.ik_seed_just_initialized = True\n            self.consecutive_ik_rejects = 0\n            # Still let sync_current_pose() get Cartesian pose (from TF)\n            self.pose_initialized = False\n            self.get_logger().info(f'IK 种子已设置为 home：{[f\"{p:.3f}\" for p in home_joint_positions]}')\n        else:\n            self.get_logger().warn(f'home 运动失败：error_code={result.error_code.val}')\n            self.pose_initialized = False\n            self.smoothed_joint_positions = None\n            self.last_ik_joint_positions = None\n    \n    def go_zero(self):\n        \"\"\"Return to zero position (all joints zero)\"\"\"\n        if self.is_moving or self.is_going_home:\n            self.get_logger().warn('当前正在执行其他动作，请稍后再试')\n            return\n        \n        self.is_going_home = True\n        self.home_start_time = self.get_clock().now()\n        self.get_logger().info('正在回到零位...')\n        \n        # Create MoveGroup request\n        goal_msg = MoveGroup.Goal()\n        \n        # Configure motion request\n        goal_msg.request.group_name = self.planning_group\n        goal_msg.request.num_planning_attempts = 5\n        goal_msg.request.allowed_planning_time = 5.0\n        goal_msg.request.max_velocity_scaling_factor = 0.3\n        goal_msg.request.max_acceleration_scaling_factor = 0.3\n        \n        # Set target to zero position\n        # Zero position: all joints are 0\n        joint_names = ['L1_joint', 'L2_joint', 'L3_joint', 'L4_joint', 'L5_joint', 'L6_joint']\n        joint_values = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]  # Radians\n        \n        constraints = Constraints()\n        for name, value in zip(joint_names, joint_values):\n            joint_constraint = JointConstraint()\n            joint_constraint.joint_name = name\n            joint_constraint.position = value\n            joint_constraint.tolerance_above = 0.01\n            joint_constraint.tolerance_below = 0.01\n            joint_constraint.weight = 1.0\n            constraints.joint_constraints.append(joint_constraint)\n        \n        goal_msg.request.goal_constraints = [constraints]\n        \n        # Set planning options\n        goal_msg.planning_options.plan_only = False\n        goal_msg.planning_options.look_around = False\n        goal_msg.planning_options.replan = True\n        goal_msg.planning_options.replan_attempts = 3\n        \n        # Send request\n        send_goal_future = self.move_group_client.send_goal_async(goal_msg)\n        send_goal_future.add_done_callback(self.zero_response_callback)\n    \n    def zero_response_callback(self, future):\n        \"\"\"Zero response callback\"\"\"\n        goal_handle = future.result()\n        \n        if not goal_handle.accepted:\n            self.get_logger().warn('零位请求被拒绝')\n            self.is_going_home = False\n            self.home_start_time = None\n            return\n        \n        self.get_logger().info('零位请求已接受，正在执行...')\n        result_future = goal_handle.get_result_async()\n        result_future.add_done_callback(self.zero_result_callback)\n    \n    def zero_result_callback(self, future):\n        \"\"\"Zero result callback\"\"\"\n        result = future.result().result\n        self.is_going_home = False\n        self.home_start_time = None\n        \n        if result.error_code.val == result.error_code.SUCCESS:\n            self.get_logger().info('已回到零位！')\n            # [Improvement] Use zero as start to avoid TF drift\n            zero_joint_positions = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n            self.last_ik_joint_positions = zero_joint_positions\n            self.smoothed_joint_positions = list(zero_joint_positions)\n            self.last_joint_velocities = [0.0] * 6\n            self.ik_seed_just_initialized = True\n            self.consecutive_ik_rejects = 0\n            # Still let sync_current_pose() get Cartesian pose (from TF)\n            self.pose_initialized = False\n            self.get_logger().info(f'IK 种子已设置为零位：{[f\"{p:.3f}\" for p in zero_joint_positions]}')\n        else:\n            self.get_logger().warn(f'零位运动失败：error_code={result.error_code.val}')\n            self.pose_initialized = False\n            self.smoothed_joint_positions = None\n            self.last_ik_joint_positions = None\n    \n    def toggle_zero_torque_mode(self):\n        \"\"\"Toggle gravity compensation (zero torque) mode\"\"\"\n        if not self.zero_torque_client.service_is_ready():\n            self.get_logger().warn('零力矩/重力补偿服务不可用')\n            return\n\n        new_state = not self.zero_torque_mode\n\n        if not new_state:\n            # Before disabling: send current position to arm_controller to prevent jump\n            self._sync_controller_to_current_position()\n\n        # Call service\n        req = SetBool.Request()\n        req.data = new_state\n        future = self.zero_torque_client.call_async(req)\n        future.add_done_callback(\n            lambda f: self._zero_torque_response(f, new_state))\n\n    def _sync_controller_to_current_position(self):\n        \"\"\"Send current joint positions to arm_controller to avoid mode-switch jumps\"\"\"\n        if self.current_joint_state is None:\n            return\n        positions = []\n        for name in self.joint_names:\n            if name in self.current_joint_state.name:\n                idx = self.current_joint_state.name.index(name)\n                positions.append(self.current_joint_state.position[idx])\n            else:\n                positions.append(0.0)\n        # Send a short trajectory to update arm_controller state immediately\n        msg = JointTrajectory()\n        msg.joint_names = self.joint_names\n        point = JointTrajectoryPoint()\n        point.positions = positions\n        point.velocities = [0.0] * 6\n        point.time_from_start = Duration(sec=0, nanosec=50_000_000)  # 50ms\n        msg.points = [point]\n        self.joint_trajectory_pub.publish(msg)\n\n    def _zero_torque_response(self, future, new_state):\n        \"\"\"Zero torque service callback\"\"\"\n        try:\n            result = future.result()\n            if result.success:\n                self.zero_torque_mode = new_state\n                if new_state:\n                    self.get_logger().info('>>> 已开启重力补偿：机械臂可手动拖动 <<<')\n                else:\n                    # Restore control: resync pose and IK seed\n                    self.pose_initialized = False  # Trigger pose resync\n                    self.last_ik_joint_positions = None  # Re-init IK seed from joint_states\n                    self.get_logger().info('>>> 已关闭重力补偿：恢复控制器控制 <<<')\n            else:\n                self.get_logger().error(f'零力矩模式切换失败：{result.message}')\n        except Exception as e:\n            self.get_logger().error(f'零力矩服务调用异常：{e}')\n        \n    # ============ Master-slave teleoperation mode ============\n\n    def toggle_master_slave_mode(self):\n        \"\"\"Toggle master-slave teleoperation mode (Menu button)\"\"\"\n        if self.entering_master_slave:\n            self.get_logger().warn('正在切换主从模式，请稍候')\n            return\n        \n        if not self.master_slave_mode:\n            # === Enable master-slave mode ===\n            self.get_logger().info('>>> 正在启用主从遥操作模式 <<<')\n            self.entering_master_slave = True\n            \n            # Check master joint states availability (slave uses direct CAN, no ROS topic needed)\n            if self.master_joint_state_ms is None:\n                self.get_logger().error('主臂关节状态不可用，无法启用主从模式')\n                self.get_logger().error('请确认主臂 ros2_control 已启动')\n                self.entering_master_slave = False\n                return\n            \n            # Send zero trajectory to both arms\n            self._move_both_to_zero()\n            \n            # Use timer to wait for zero motion then proceed\n            delay = self.go_zero_duration + 0.5  # Extra 0.5s to ensure arrival\n            self._ms_enable_timer = self.create_timer(\n                delay, self._on_go_zero_done_enable)\n        else:\n            # === Disable master-slave mode ===\n            self.get_logger().info('>>> 正在关闭主从遥操作模式 <<<')\n            self.master_slave_mode = False\n            self.entering_master_slave = True\n            \n            # Note: can1 motors 1-7 keep holding last position during go-zero phase\n            # They will be released (zero torque) in _on_go_zero_done_disable()\n            \n            # First disable master gravity compensation (restore trajectory control)\n            self._set_master_zero_torque(False)\n            \n            # Wait for gravity compensation to disable before zeroing\n            self._ms_disable_pre_timer = self.create_timer(\n                0.5, self._on_gravity_off_then_go_zero)\n\n    def _on_gravity_off_then_go_zero(self):\n        \"\"\"Send zero trajectory after gravity compensation is off\"\"\"\n        # Destroy this one-shot timer\n        self._ms_disable_pre_timer.cancel()\n        self.destroy_timer(self._ms_disable_pre_timer)\n        \n        # Re-read joint states and send zero trajectory\n        self._move_both_to_zero()\n        \n        # Use timer to wait for zero motion\n        delay = self.go_zero_duration + 0.5\n        self._ms_disable_timer = self.create_timer(\n            delay, self._on_go_zero_done_disable)\n\n    def _on_go_zero_done_enable(self):\n        \"\"\"Enable master gravity compensation after zeroing (enable flow)\"\"\"\n        # Destroy this one-shot timer\n        self._ms_enable_timer.cancel()\n        self.destroy_timer(self._ms_enable_timer)\n        \n        # Enable master gravity compensation (L1-L6)\n        self._set_master_zero_torque(True)\n        \n        # Enable can0 Motor 7 for zero torque mode (draggable)\n        if self.can_socket is not None:\n            self._enable_motor_on_socket(self.can_socket, self.gripper_motor_id)\n            self.get_logger().info('can0 Motor 7 已使能（零力矩模式）')\n        \n        # Re-ensure all can1 motors enabled (already enabled in _move_both_to_zero)\n        if self.can1_socket is not None:\n            for motor_id in range(1, 8):\n                self._enable_motor_on_socket(self.can1_socket, motor_id)\n            self.get_logger().info('can1 Motors 1-7 已确认使能（CAN 跟随模式）')\n        \n        self.motor7_valid = False\n        self.master_slave_mode = True\n        self.entering_master_slave = False\n        self.get_logger().info('>>> 主从遥操作已启用（全 CAN 直接通信） <<<')\n        self.get_logger().info('  can0（主臂）：L1-L6 重力补偿 + L7 零力矩可拖动')\n        self.get_logger().info('  can1（从臂）：L1-L7 直接 CAN MIT 跟随')\n        self.get_logger().info('  注意：请勿同时运行 arm2 的 ros2_control_node')\n        self.get_logger().info('  再按一次 Menu 退出')\n\n    def _on_go_zero_done_disable(self):\n        \"\"\"Restore normal control after zeroing (disable flow)\"\"\"\n        # Destroy this one-shot timer\n        self._ms_disable_timer.cancel()\n        self.destroy_timer(self._ms_disable_timer)\n        \n        # Release all can1 motors (send zero torque)\n        if self.can1_socket is not None:\n            for motor_id in range(1, 8):\n                self._send_mit_command(\n                    self.can1_socket, motor_id,\n                    0.0, 0.0, 0.0, 0.0, 0.0)\n            self.get_logger().info('can1 Motors 1-7 已释放（零力矩）')\n        \n        self.entering_master_slave = False\n        \n        # Sync controller to zero, restore normal Xbox control\n        self._sync_controller_to_current_position()\n        self.pose_initialized = False\n        self.last_ik_joint_positions = None\n        self.smoothed_joint_positions = None\n        self.get_logger().info('>>> 主从遥操作已关闭：恢复 Xbox 控制 <<<')\n\n    def _set_master_zero_torque(self, enable):\n        \"\"\"Set master gravity compensation (namespaced service for master-slave)\"\"\"\n        if not self.master_zero_torque_client_ms.service_is_ready():\n            self.get_logger().warn(f'主臂零力矩服务不可用：{self.master_zero_torque_client_ms.srv_name}')\n            return\n        \n        req = SetBool.Request()\n        req.data = enable\n        future = self.master_zero_torque_client_ms.call_async(req)\n        future.add_done_callback(\n            lambda f: self._master_zero_torque_response(f, enable))\n\n    def _master_zero_torque_response(self, future, enable):\n        \"\"\"Master gravity compensation service callback\"\"\"\n        try:\n            result = future.result()\n            if result.success:\n                state_str = '已开启' if enable else '已关闭'\n                self.get_logger().info(f'主臂重力补偿{state_str}')\n            else:\n                self.get_logger().error(f'主臂重力补偿切换失败：{result.message}')\n        except Exception as e:\n            self.get_logger().error(f'主臂重力补偿服务异常：{e}')\n\n    def _move_both_to_zero(self):\n        \"\"\"Send slow zero trajectories to both arms\"\"\"\n        duration = self.go_zero_duration\n        \n        # Master arm zeroing - use main joint_trajectory_pub (known working QoS)\n        if self.current_joint_state is not None:\n            master_positions = self._extract_joint_positions(\n                self.current_joint_state, self.joint_names)\n            if master_positions is not None:\n                traj = self._generate_zero_trajectory(\n                    master_positions, self.joint_names, duration)\n                self.joint_trajectory_pub.publish(traj)\n                self.get_logger().info(f'主臂（can0）已发送回零轨迹（{duration}s）')\n            else:\n                self.get_logger().warn('无法读取主臂关节位置')\n        \n        # Slave arm zeroing via direct CAN (all 7 motors)\n        if self.can1_socket is not None:\n            # Enable all motors 1-7 on can1 first\n            for motor_id in range(1, 8):\n                self._enable_motor_on_socket(self.can1_socket, motor_id)\n            self.get_logger().info('can1 Motors 1-7 已使能（准备回零）')\n            \n            # Get L1-L6 start positions: prefer slave joint state, fallback to master\n            slave_positions = None\n            if self.slave_joint_state is not None:\n                slave_positions = self._extract_joint_positions(\n                    self.slave_joint_state, self.slave_joint_names)\n            if slave_positions is None and self.master_joint_state_ms is not None:\n                slave_positions = self._extract_joint_positions(\n                    self.master_joint_state_ms, self.master_joint_names_ms)\n                self.get_logger().info('从臂关节状态不可用，使用主臂位置作为近似起始')\n            if slave_positions is None:\n                slave_positions = [0.0] * 6\n                self.get_logger().info('使用零位作为从臂起始位置')\n            \n            # Get Motor 7 start position from can0 feedback (already in motor frame)\n            motor7_start = self.motor7_position if self.motor7_valid else 0.0\n            \n            # Convert L1-L6 from joint coordinate → motor coordinate frame\n            motor_start_positions = [\n                slave_positions[i] * self.motor_directions[i] for i in range(6)\n            ]\n            # All 7 motors start positions (in motor coordinate frame)\n            self._slave_zero_start_positions = motor_start_positions + [motor7_start]\n            self._slave_zero_frame = 0\n            self._slave_zero_total_frames = int(duration * self.update_rate)\n            self._slave_can_going_zero = True\n            pos_str = ', '.join([f'{p:.3f}' for p in self._slave_zero_start_positions])\n            self.get_logger().info(\n                f'从臂（can1）CAN 直接回零（{duration}s），起始=[{pos_str}]')\n        else:\n            self.get_logger().warn('can1 socket 不可用，无法控制从臂回零')\n\n    def _extract_joint_positions(self, joint_state, joint_names):\n        \"\"\"Extract joint positions by name from JointState message\"\"\"\n        positions = []\n        for name in joint_names:\n            if name in joint_state.name:\n                idx = joint_state.name.index(name)\n                positions.append(joint_state.position[idx])\n            else:\n                return None  # Missing joint data\n        return positions\n\n    def _generate_zero_trajectory(self, current_positions, joint_names, duration=3.0, num_points=30):\n        \"\"\"Generate a smooth S-curve trajectory from current position to zero\n        \n        Uses cosine interpolation (S-curve) for smooth acceleration/deceleration.\n        Start and end velocities are zero; intermediate velocities computed from derivatives.\n        \"\"\"\n        trajectory = JointTrajectory()\n        trajectory.joint_names = joint_names\n        n_joints = len(joint_names)\n        \n        for i in range(1, num_points + 1):\n            t_frac = i / num_points\n            # S-curve: alpha = 0.5 * (1 - cos(pi * t_frac))\n            # Starts slow, accelerates, then decelerates to stop\n            alpha = 0.5 * (1.0 - math.cos(math.pi * t_frac))\n            \n            point = JointTrajectoryPoint()\n            point.positions = [c * (1.0 - alpha) for c in current_positions]\n            \n            # Compute velocity from S-curve derivative:\n            # d(alpha)/dt = 0.5 * pi * sin(pi * t_frac) / duration\n            if i < num_points:\n                d_alpha = 0.5 * math.pi * math.sin(math.pi * t_frac) / duration\n                point.velocities = [-c * d_alpha for c in current_positions]\n            else:\n                point.velocities = [0.0] * n_joints  # Final point: zero velocity\n            \n            t = duration * t_frac\n            point.time_from_start = Duration(\n                sec=int(t), nanosec=int((t % 1) * 1e9))\n            trajectory.points.append(point)\n        \n        return trajectory\n\n    def _master_slave_follow(self):\n        \"\"\"Master-slave follow: read master and send to slave via direct CAN (50Hz)\n        All 7 motors use CAN MIT commands: can0 read → can1 write\n        \"\"\"\n        if self.master_joint_state_ms is None:\n            return\n        \n        # === L1-L6: Direct CAN MIT commands to can1 ===\n        # Convert joint coordinate → motor coordinate: motor_pos = joint_pos * direction\n        master_positions = self._extract_joint_positions(\n            self.master_joint_state_ms, self.master_joint_names_ms)\n        if master_positions is not None and self.can1_socket is not None:\n            for i, pos in enumerate(master_positions):\n                motor_id = i + 1  # Motor IDs 1-6\n                motor_pos = pos * self.motor_directions[i]  # Joint → Motor frame\n                self._send_mit_command(\n                    self.can1_socket, motor_id,\n                    motor_pos, 0.0, self.slave_follow_kp, self.slave_follow_kd, 0.0)\n        \n        # Periodic debug logging (every 2 seconds at 50Hz = every 100 frames)\n        if not hasattr(self, '_ms_follow_count'):\n            self._ms_follow_count = 0\n        self._ms_follow_count += 1\n        if self._ms_follow_count % 100 == 1:\n            if master_positions is not None:\n                pos_str = ', '.join([f'{p:.3f}' for p in master_positions])\n                m7_str = f'{self.motor7_position:.3f}' if self.motor7_valid else 'N/A'\n                self.get_logger().info(\n                    f'[主从跟随-CAN] L1-L6=[{pos_str}] L7={m7_str} '\n                    f'Kp={self.slave_follow_kp} Kd={self.slave_follow_kd}')\n            else:\n                self.get_logger().warn(\n                    f'[主从跟随-CAN] master_positions=None | '\n                    f'joint_names={self.master_joint_names_ms}')\n        \n        # === Motor 7 (gripper): can0 zero torque + can1 position follow ===\n        # Read Motor 7 feedback from can0\n        self._read_motor7_feedback()\n        \n        # can0 Motor 7: pure zero torque (Kp=0, Kd=0, torque=0) - draggable\n        if self.can_socket is not None:\n            self._send_mit_command(\n                self.can_socket, self.gripper_motor_id,\n                0.0, 0.0, 0.0, 0.0, 0.0)\n        \n        # can1 Motor 7: position follow\n        if self.can1_socket is not None and self.motor7_valid:\n            self._send_mit_command(\n                self.can1_socket, self.gripper_motor_id,\n                self.motor7_position, 0.0,\n                self.slave_follow_kp, self.slave_follow_kd, 0.0)\n\n    def _slave_can_go_zero_tick(self):\n        \"\"\"CAN-based slave arm go-zero: send one S-curve interpolated frame for all 7 motors\"\"\"\n        if self.can1_socket is None or not self._slave_can_going_zero:\n            return\n        \n        self._slave_zero_frame += 1\n        if self._slave_zero_frame > self._slave_zero_total_frames:\n            self._slave_can_going_zero = False\n            self.get_logger().info('从臂（can1）CAN 回零完成')\n            return\n        \n        # S-curve interpolation (same formula as _generate_zero_trajectory)\n        t_frac = self._slave_zero_frame / self._slave_zero_total_frames\n        alpha = 0.5 * (1.0 - math.cos(math.pi * t_frac))\n        \n        for i, start_pos in enumerate(self._slave_zero_start_positions):\n            motor_id = i + 1  # Motors 1-7\n            target_pos = start_pos * (1.0 - alpha)  # Interpolate to zero\n            self._send_mit_command(\n                self.can1_socket, motor_id,\n                target_pos, 0.0, self.slave_follow_kp, self.slave_follow_kd, 0.0)\n\n    def _enable_motor_on_socket(self, can_socket, motor_id):\n        \"\"\"Enable motor on specified CAN socket (comm type 3)\"\"\"\n        host_can_id = 253  # 0xFD\n        comm_type = 3\n        can_id = (comm_type << 24) | (host_can_id << 8) | motor_id\n        can_id |= 0x80000000  # Extended frame flag\n        data = bytes(8)\n        frame = struct.pack('=IB3x8s', can_id, 8, data)\n        can_socket.send(frame)\n\n    def _send_mit_command(self, can_socket, motor_id, position, velocity, kp, kd, torque):\n        \"\"\"Send MIT control mode command to motor via specified CAN socket\"\"\"\n        try:\n            pos_raw = self._float_to_uint16(position, self.P_MIN, self.P_MAX)\n            vel_raw = self._float_to_uint16(velocity, self.V_MIN, self.V_MAX)\n            kp_raw = self._float_to_uint16(kp, self.KP_MIN, self.KP_MAX)\n            kd_raw = self._float_to_uint16(kd, self.KD_MIN, self.KD_MAX)\n            torque_raw = self._float_to_uint16(torque, self.T_MIN, self.T_MAX)\n            \n            comm_type = 1\n            can_id = (comm_type << 24) | (torque_raw << 8) | motor_id\n            can_id |= 0x80000000  # Extended frame flag\n            \n            data = struct.pack('>HHHH', pos_raw, vel_raw, kp_raw, kd_raw)\n            frame = struct.pack('=IB3x8s', can_id, 8, data)\n            can_socket.send(frame)\n        except Exception as e:\n            self.get_logger().debug(f'MIT command 发送失败：{e}')\n\n    def _float_to_uint16(self, x, x_min, x_max):\n        \"\"\"Float to uint16 conversion (MIT mode encoding)\"\"\"\n        x = max(x_min, min(x_max, x))\n        return int((x - x_min) * 65535.0 / (x_max - x_min))\n\n    def _uint16_to_float(self, x_int, x_min, x_max):\n        \"\"\"uint16 to float conversion (MIT mode decoding)\"\"\"\n        return x_min + (x_max - x_min) * x_int / 65535.0\n\n    def _read_motor7_feedback(self):\n        \"\"\"Read Motor 7 feedback from can0 (non-blocking), update self.motor7_position\"\"\"\n        if self.can_socket is None:\n            return\n        \n        for _ in range(50):  # Read up to 50 frames to drain buffer\n            try:\n                frame_data = self.can_socket.recv(16)\n                can_id_raw, dlc = struct.unpack_from('=IB', frame_data, 0)\n                data = frame_data[8:16]\n                \n                can_id = can_id_raw & 0x1FFFFFFF  # Remove extended frame flag\n                comm_type = (can_id >> 24) & 0x3F\n                motor_id = (can_id >> 8) & 0xFF\n                \n                if comm_type == 2 and motor_id == self.gripper_motor_id:\n                    pos_raw = (data[0] << 8) | data[1]\n                    self.motor7_position = self._uint16_to_float(\n                        pos_raw, self.P_MIN, self.P_MAX)\n                    self.motor7_valid = True\n            except BlockingIOError:\n                break\n            except Exception:\n                break\n\n    def update_callback(self):\n        \"\"\"Periodic update callback\"\"\"\n        if self.current_joy is None:\n            return\n        \n        joy = self.current_joy\n        \n        # Ensure indices are valid\n        if len(joy.axes) < 6 or len(joy.buttons) < 6:\n            return\n        \n        # A button: switch speed level (edge-triggered)\n        a_button = joy.buttons[0]\n        if a_button == 1 and self.last_a_button == 0:\n            self.switch_speed_level()\n        self.last_a_button = a_button\n        \n        # B button: go home (edge-triggered)\n        b_button = joy.buttons[1]\n        if b_button == 1 and self.last_b_button == 0:\n            self.go_home()\n        self.last_b_button = b_button\n        \n        # X button: go zero (edge-triggered)\n        x_button = joy.buttons[2]\n        if x_button == 1 and self.last_x_button == 0:\n            self.go_zero()\n        self.last_x_button = x_button\n        \n        # Y button: toggle gravity compensation (edge-triggered)\n        y_button = joy.buttons[3]\n        if y_button == 1 and self.last_y_button == 0:\n            self.toggle_zero_torque_mode()\n        self.last_y_button = y_button\n        \n        # Menu button: toggle master-slave teleop (edge-triggered)\n        if len(joy.buttons) > 7 and self.master_slave_enabled:\n            menu_button = joy.buttons[7]\n            if menu_button == 1 and self.last_menu_button == 0:\n                self.toggle_master_slave_mode()\n            self.last_menu_button = menu_button\n        \n        # D-pad: control gripper motor (ID=7) torque (skip in master-slave mode)\n        # Xbox D-pad: axes[6]=left/right, axes[7]=up/down (up=1, down=-1)\n        if len(joy.axes) >= 8 and self.can_socket is not None and not self.master_slave_mode:\n            dpad_vertical = joy.axes[7]  # Up=1, down=-1\n            \n            # D-pad up: increase torque\n            dpad_up = 1 if dpad_vertical > 0.5 else 0\n            if dpad_up == 1 and self.last_dpad_up == 0:\n                self.gripper_torque = self.gripper_torque_step\n                self.send_gripper_torque(self.gripper_torque)\n                self.get_logger().info(f'夹爪力矩：+{self.gripper_torque:.2f} Nm')\n            elif dpad_up == 0 and self.last_dpad_up == 1:\n                # Send zero torque when released\n                self.gripper_torque = 0.0\n                self.send_gripper_torque(0.0)\n            self.last_dpad_up = dpad_up\n            \n            # D-pad down: decrease torque\n            dpad_down = 1 if dpad_vertical < -0.5 else 0\n            if dpad_down == 1 and self.last_dpad_down == 0:\n                self.gripper_torque = -self.gripper_torque_step\n                self.send_gripper_torque(self.gripper_torque)\n                self.get_logger().info(f'夹爪力矩：{self.gripper_torque:.2f} Nm')\n            elif dpad_down == 0 and self.last_dpad_down == 1:\n                # Send zero torque when released\n                self.gripper_torque = 0.0\n                self.send_gripper_torque(0.0)\n            self.last_dpad_down = dpad_down\n            \n        # CAN-based slave go-zero tick (runs during entering_master_slave phase)\n        if self._slave_can_going_zero:\n            self._slave_can_go_zero_tick()\n        elif self.entering_master_slave and self.can1_socket is not None:\n            # Go-zero complete but still waiting for timer: hold can1 motors at zero\n            for motor_id in range(1, 8):\n                self._send_mit_command(\n                    self.can1_socket, motor_id,\n                    0.0, 0.0, self.slave_follow_kp, self.slave_follow_kd, 0.0)\n        \n        # In master-slave mode: follow master, skip normal controller input\n        if self.master_slave_mode:\n            self._master_slave_follow()\n            return\n        if self.entering_master_slave:\n            return\n        \n        # Skip motion control in zero-torque mode (only when NOT in master-slave mode)\n        if self.zero_torque_mode:\n            return\n        \n        # If returning home/zero, skip normal motion control (with timeout protection)\n        if self.is_going_home:\n            # Timeout check to prevent permanent block\n            if self.home_start_time is not None:\n                elapsed = (self.get_clock().now() - self.home_start_time).nanoseconds / 1e9\n                if elapsed > self.home_timeout:\n                    self.get_logger().warn(f'home/零位超时（{elapsed:.1f}s），正在重置状态并恢复控制')\n                    self.is_going_home = False\n                    self.home_start_time = None\n                    self.pose_initialized = False  # Resync pose\n                else:\n                    return\n            else:\n                return\n            \n        # Parse controller input -> Cartesian velocity mapping\n        # Xbox mapping:\n        # Left stick X: axes[0], Left stick Y: axes[1]\n        # LT: axes[2], RT: axes[5] (range 1.0 to -1.0, pressed = -1.0)\n        # Right stick X: axes[3], Right stick Y: axes[4]\n        # LB: buttons[4], RB: buttons[5]\n        # A: buttons[0], B: buttons[1]\n        \n        # ============ Cartesian velocity mapping ============\n        # Stick input → velocity (m/s, rad/s) → position delta\n        \n        # Compute actual max speed at current level\n        current_max_linear = self.max_linear_velocity * self.speed_factor\n        current_max_angular = self.max_angular_velocity * self.speed_factor\n        \n        # Translation - swap and invert left stick XY\n        raw_vx = -self.apply_deadzone(joy.axes[1]) * current_max_linear  # 左摇杆Y -> X速度 (m/s)\n        raw_vy = -self.apply_deadzone(joy.axes[0]) * current_max_linear  # 左摇杆X -> Y速度 (m/s)\n        \n        # LT/RT control Z velocity\n        lt = self.apply_trigger_deadzone(joy.axes[2])  # 转换为0-1范围并应用死区\n        rt = self.apply_trigger_deadzone(joy.axes[5])  # 转换为0-1范围并应用死区\n        raw_vz = (rt - lt) * current_max_linear  # RT up, LT down (m/s)\n        \n        # Rotation velocities\n        raw_vyaw = self.apply_deadzone(joy.axes[3]) * current_max_angular   # 右摇杆X -> Yaw速度 (rad/s)\n        raw_vroll = self.apply_deadzone(joy.axes[4]) * current_max_angular  # 右摇杆Y -> Roll速度 (rad/s)\n        \n        # LB/RB control pitch velocity\n        raw_vpitch = (joy.buttons[5] - joy.buttons[4]) * current_max_angular  # RB positive, LB negative (rad/s)\n        \n        # Apply input smoothing filter (exponential moving average)\n        alpha = self.input_smoothing_factor\n        self.smoothed_vx = alpha * raw_vx + (1 - alpha) * self.smoothed_vx\n        self.smoothed_vy = alpha * raw_vy + (1 - alpha) * self.smoothed_vy\n        self.smoothed_vz = alpha * raw_vz + (1 - alpha) * self.smoothed_vz\n        self.smoothed_vroll = alpha * raw_vroll + (1 - alpha) * self.smoothed_vroll\n        self.smoothed_vpitch = alpha * raw_vpitch + (1 - alpha) * self.smoothed_vpitch\n        self.smoothed_vyaw = alpha * raw_vyaw + (1 - alpha) * self.smoothed_vyaw\n        \n        # Velocity × dt = position delta\n        dx = self.smoothed_vx * self.dt\n        dy = self.smoothed_vy * self.dt\n        dz = self.smoothed_vz * self.dt\n        droll = self.smoothed_vroll * self.dt\n        dpitch = self.smoothed_vpitch * self.dt\n        dyaw = self.smoothed_vyaw * self.dt\n        \n        # Check for input based on velocity thresholds\n        velocity_threshold = 0.001  # Below 1mm/s treated as no input\n        angular_threshold = 0.01    # Below 0.01 rad/s treated as no input\n        translation_threshold = velocity_threshold * self.dt\n        rotation_threshold = angular_threshold * self.dt\n        \n        has_translation = abs(dx) > translation_threshold or abs(dy) > translation_threshold or abs(dz) > translation_threshold\n        has_rotation = abs(dyaw) > rotation_threshold or abs(dpitch) > rotation_threshold or abs(droll) > rotation_threshold\n        \n        if not has_translation and not has_rotation:\n            # [Change] Keep computing IK even without input, to keep debug topic updated\n            # and observe IK stability at rest.\n            if self.use_fast_ik_mode and self.pose_initialized:\n                self.send_cartesian_goal()  # Keep IK computing current target pose\n            return  # No valid input, skip target update\n        \n        # Accumulate deltas\n        self.pending_dx += dx\n        self.pending_dy += dy\n        self.pending_dz += dz\n        self.pending_droll += droll\n        self.pending_dpitch += dpitch\n        self.pending_dyaw += dyaw\n        \n        # [Key change] Sync pose only once, then accumulate deltas onto target pose\n        # This avoids Z drift from tracking errors (e.g., sagging under gravity).\n        if not self.pose_initialized:\n            if not self.sync_current_pose():\n                self.get_logger().warn('等待 TF 树就绪...')\n                return  # TF not ready, skip this update\n        \n        # Use accumulated deltas\n        dx = self.pending_dx\n        dy = self.pending_dy\n        dz = self.pending_dz\n        droll = self.pending_droll\n        dpitch = self.pending_dpitch\n        dyaw = self.pending_dyaw\n        \n        # Clear accumulated deltas\n        self.pending_dx = 0.0\n        self.pending_dy = 0.0\n        self.pending_dz = 0.0\n        self.pending_droll = 0.0\n        self.pending_dpitch = 0.0\n        self.pending_dyaw = 0.0\n            \n        # Save last target to detect jumps\n        if hasattr(self, 'last_target_x'):\n            position_jump = math.sqrt(\n                (self.target_pose.pose.position.x - self.last_target_x) ** 2 +\n                (self.target_pose.pose.position.y - self.last_target_y) ** 2 +\n                (self.target_pose.pose.position.z - self.last_target_z) ** 2\n            )\n            # Detect position jumps (warn if > 50mm)\n            if position_jump > 0.05:\n                self.get_logger().warn(f'检测到目标位姿跳变！距离={position_jump*1000:.1f}mm')\n        \n        # Debug: print actual inputs (only when there is input)\n        if self.debug_input:\n            self.get_logger().info(\n                f'输入：dx={dx:.6f} dy={dy:.6f} dz={dz:.6f} '\n                f'droll={droll:.6f} dpitch={dpitch:.6f} dyaw={dyaw:.6f}'\n            )\n            \n        # Update target pose\n        # Translation\n        self.target_pose.pose.position.x += dx\n        self.target_pose.pose.position.y += dy\n        self.target_pose.pose.position.z += dz\n        \n        # Rotation - convert current quaternion to Euler\n        q = self.target_pose.pose.orientation\n        current_roll, current_pitch, current_yaw = euler_from_quaternion([\n            q.x, q.y, q.z, q.w\n        ])\n        \n        # Update Euler angles\n        new_roll = current_roll + droll\n        new_pitch = current_pitch + dpitch\n        new_yaw = current_yaw + dyaw\n        \n        # Convert back to quaternion\n        new_q = quaternion_from_euler(new_roll, new_pitch, new_yaw)\n        self.target_pose.pose.orientation.x = new_q[0]\n        self.target_pose.pose.orientation.y = new_q[1]\n        self.target_pose.pose.orientation.z = new_q[2]\n        self.target_pose.pose.orientation.w = new_q[3]\n        \n        # Save current target for next jump detection\n        self.last_target_x = self.target_pose.pose.position.x\n        self.last_target_y = self.target_pose.pose.position.y\n        self.last_target_z = self.target_pose.pose.position.z\n        \n        # Publish target pose for visualization\n        self.target_pose.header.stamp = self.get_clock().now().to_msg()\n        self.target_pose_pub.publish(self.target_pose)\n        \n        # Send motion command\n        self.send_cartesian_goal()\n        \n    def pose_changed_significantly(self):\n        \"\"\"Check if target pose changed significantly\"\"\"\n        if self.last_sent_pose is None:\n            return True\n        \n        # Compute position change\n        dx = abs(self.target_pose.pose.position.x - self.last_sent_pose.pose.position.x)\n        dy = abs(self.target_pose.pose.position.y - self.last_sent_pose.pose.position.y)\n        dz = abs(self.target_pose.pose.position.z - self.last_sent_pose.pose.position.z)\n        \n        # If position change exceeds threshold, treat as significant change\n        if dx > self.min_move_threshold or dy > self.min_move_threshold or dz > self.min_move_threshold:\n            return True\n        \n        # Check orientation change (simplified: quaternion w component)\n        dw = abs(self.target_pose.pose.orientation.w - self.last_sent_pose.pose.orientation.w)\n        if dw > 0.01:  # About 1 degree\n            return True\n        \n        return False\n    \n    def send_cartesian_goal(self):\n        \"\"\"Send Cartesian goal - use fast IK or path planning based on mode\"\"\"\n        if self.use_fast_ik_mode:\n            self.send_ik_goal()\n        else:\n            self.send_cartesian_path_goal()\n    \n    def send_ik_goal(self):\n        \"\"\"Compute joints via IK service and publish trajectory - 50Hz fast mode\"\"\"\n        # Allow overriding old requests, but avoid queue buildup\n        if self.pending_ik_request:\n            return  # Previous IK request still processing\n        \n        # Debug log\n        self.get_logger().debug('正在发送 IK 请求...')\n        \n        # Build IK request\n        request = GetPositionIK.Request()\n        request.ik_request.group_name = self.planning_group\n        request.ik_request.robot_state.is_diff = False  # Use full state, not diff\n        \n        # [Key fix] Use last successful IK solution as seed to keep continuity\n        # This avoids pose jumps from gravity sag.\n        if self.last_ik_joint_positions is not None:\n            # Use last IK solution as seed\n            seed_state = JointState()\n            seed_state.name = self.joint_names\n            seed_state.position = self.last_ik_joint_positions\n            request.ik_request.robot_state.joint_state = seed_state\n        elif self.current_joint_state:\n            # First time: use current joint state\n            request.ik_request.robot_state.joint_state = self.current_joint_state\n        \n        # Set target end-effector pose\n        request.ik_request.pose_stamped.header.frame_id = self.base_frame\n        request.ik_request.pose_stamped.header.stamp = self.get_clock().now().to_msg()\n        request.ik_request.pose_stamped.pose = self.target_pose.pose\n        \n        # Set timeout (short to keep high rate)\n        request.ik_request.timeout.sec = 0\n        request.ik_request.timeout.nanosec = 10_000_000  # 10ms timeout\n        \n        # Set collision checking\n        request.ik_request.avoid_collisions = self.collision_check_active\n        \n        # Call IK service asynchronously\n        self.pending_ik_request = True\n        future = self.ik_client.call_async(request)\n        future.add_done_callback(self.ik_callback)\n    \n    def ik_callback(self, future):\n        \"\"\"IK completion callback - publish joint trajectory\"\"\"\n        self.pending_ik_request = False\n        \n        # Skip if in master-slave mode or transitioning (avoid overriding zero trajectory)\n        if self.master_slave_mode or self.entering_master_slave:\n            return\n        \n        try:\n            response = future.result()\n            \n            # Check IK success (SUCCESS = 1)\n            if response.error_code.val != 1:\n                # IK failed, target may be unreachable\n                self.get_logger().debug(f'IK 失败：error_code={response.error_code.val}')\n                return\n            \n            # Extract joint positions\n            solution = response.solution.joint_state\n            ik_positions = []\n            \n            for joint_name in self.joint_names:\n                if joint_name in solution.name:\n                    idx = solution.name.index(joint_name)\n                    ik_positions.append(solution.position[idx])\n                else:\n                    return  # Missing joint data\n            \n            # [Debug] Publish raw IK solution (before any processing)\n            self.publish_ik_raw_debug(ik_positions)\n            \n            # Check if IK solution change is too small or too large\n            if self.last_ik_joint_positions is not None:\n                max_diff = max(abs(ik_positions[i] - self.last_ik_joint_positions[i]) for i in range(len(ik_positions)))\n                \n                # Change too small, skip\n                if max_diff < 0.0001:\n                    return\n                \n                # [Singularity protection] Too large change -> reject IK solution\n                # If IK seed just initialized, skip first-frame check to set baseline\n                if max_diff > self.max_ik_jump_threshold:\n                    if self.ik_seed_just_initialized:\n                        # First frame: accept IK solution, clear flag\n                        self.get_logger().info(f'IK 种子初始化后的首帧：接受 IK 解（diff={max_diff:.3f}rad）')\n                        self.ik_seed_just_initialized = False\n                    else:\n                        self.consecutive_ik_rejects += 1\n                        if self.consecutive_ik_rejects >= self.singularity_warning_count:\n                            self.get_logger().warn(\n                                f'疑似奇异区：IK 跳变={max_diff:.3f}rad，已保护 {self.consecutive_ik_rejects} 帧'\n                            )\n                        # [Auto recovery] Re-sync IK seed after 50 consecutive rejects\n                        if self.consecutive_ik_rejects >= 50:\n                            self.get_logger().warn('IK 解已连续拒绝 50+ 帧，自动重新同步位姿...')\n                            self.pose_initialized = False\n                            self.smoothed_joint_positions = None\n                            self.last_ik_joint_positions = None\n                            self.consecutive_ik_rejects = 0\n                        # Reject this solution and keep last joint positions\n                        return\n                else:\n                    # IK solution ok: reset counters and flags\n                    if self.consecutive_ik_rejects > 0:\n                        self.consecutive_ik_rejects = 0\n                    if self.ik_seed_just_initialized:\n                        self.ik_seed_just_initialized = False\n            \n            # [Key] Apply joint output smoothing\n            # Avoid mechanical shocks from IK jumps\n            target_positions = self.smooth_joint_positions(ik_positions)\n            self.last_ik_joint_positions = target_positions\n            \n            # [Debug] Publish IK solution to /debug/ik_solution\n            self.publish_ik_debug(target_positions)\n            \n            # Build and publish joint trajectory\n            trajectory = JointTrajectory()\n            trajectory.header.stamp = self.get_clock().now().to_msg()\n            trajectory.joint_names = self.joint_names\n            \n            # Single-point trajectory - short time lets hardware smooth\n            point = JointTrajectoryPoint()\n            point.positions = target_positions\n            point.velocities = [0.0] * 6  # Target velocity is 0\n            point.time_from_start.sec = 0\n            point.time_from_start.nanosec = 20_000_000  # 20ms (50Hz)\n            \n            trajectory.points = [point]\n            \n            # Publish trajectory directly to controller\n            self.joint_trajectory_pub.publish(trajectory)\n            \n            # Count IK successes\n            if not hasattr(self, 'ik_success_count'):\n                self.ik_success_count = 0\n            self.ik_success_count += 1\n            if self.ik_success_count % 50 == 0:  # Log every 50\n                self.get_logger().info(f'IK 控制：已发送 {self.ik_success_count} 条轨迹指令')\n            \n            # Update last sent pose (for change detection)\n            self.last_sent_pose = copy.deepcopy(self.target_pose)\n            \n        except Exception as e:\n            self.get_logger().error(f'IK 回调异常：{e}')\n    \n    def smooth_joint_positions(self, target_positions):\n        \"\"\"Smooth IK joint positions (critical damping + deadzone).\n        \n        Uses critical damping + position deadzone + asymmetric decel to avoid\n        joint jumps and idle oscillations.\n        \n        Args:\n            target_positions: Target joint positions from IK\n            \n        Returns:\n            Smoothed joint positions\n        \"\"\"\n        # Initialize on first call\n        if self.smoothed_joint_positions is None:\n            self.smoothed_joint_positions = list(target_positions)\n            self.last_joint_velocities = [0.0] * len(target_positions)\n            return target_positions\n        \n        # Ensure velocity array initialized\n        if self.last_joint_velocities is None:\n            self.last_joint_velocities = [0.0] * len(target_positions)\n        \n        smoothed = []\n        new_velocities = []\n        alpha = self.joint_smoothing_alpha\n        max_delta_v = self.max_joint_acceleration * self.dt  # Max velocity change per cycle\n        \n        # [New] Position deadzone (below this is treated as reached)\n        position_deadzone = 0.0005  # 0.5 mrad ≈ 0.03 deg\n        \n        for i in range(len(target_positions)):\n            pos_error = target_positions[i] - self.smoothed_joint_positions[i]\n            current_velocity = self.last_joint_velocities[i]\n            \n            # [Improvement 1] Position deadzone: zero when error and velocity are tiny\n            if abs(pos_error) < position_deadzone and abs(current_velocity) < 0.01:\n                smoothed.append(self.smoothed_joint_positions[i])\n                new_velocities.append(0.0)\n                continue\n            \n            # [Improvement 2] Critical damping: desired_velocity considers current velocity\n            # PD-like: v_desired = Kp * pos_error - Kd * current_velocity\n            # Here Kp is alpha/dt, Kd is damping coefficient.\n            damping = 0.7  # Damping coefficient, ~critical damping\n            \n            # Desired velocity = position error term - damping term\n            desired_velocity = alpha * pos_error / self.dt - damping * current_velocity\n            \n            # [Improvement 3] Asymmetric accel limit: allow 2x accel when decelerating\n            velocity_change = desired_velocity - current_velocity\n            is_decelerating = (current_velocity * desired_velocity < 0) or \\\n                              (abs(desired_velocity) < abs(current_velocity))\n            \n            if is_decelerating:\n                effective_max_delta_v = max_delta_v * 2.0  # Double accel when decelerating\n            else:\n                effective_max_delta_v = max_delta_v\n            \n            if abs(velocity_change) > effective_max_delta_v:\n                desired_velocity = current_velocity + effective_max_delta_v * (1 if velocity_change > 0 else -1)\n            \n            # Velocity limit\n            if abs(desired_velocity) > self.max_joint_velocity:\n                desired_velocity = self.max_joint_velocity * (1 if desired_velocity > 0 else -1)\n            \n            # Compute final position\n            final_pos = self.smoothed_joint_positions[i] + desired_velocity * self.dt\n            \n            smoothed.append(final_pos)\n            new_velocities.append(desired_velocity)\n        \n        self.smoothed_joint_positions = smoothed\n        self.last_joint_velocities = new_velocities\n        return smoothed\n    \n    def send_joint_positions(self, positions):\n        \"\"\"Send joint positions to controller directly (no IK)\"\"\"\n        # Build and publish joint trajectory\n        trajectory = JointTrajectory()\n        trajectory.header.stamp = self.get_clock().now().to_msg()\n        trajectory.joint_names = self.joint_names\n        \n        # Single-point trajectory - short execution time\n        point = JointTrajectoryPoint()\n        point.positions = list(positions)\n        point.velocities = [0.0] * 6\n        point.time_from_start.sec = 0\n        point.time_from_start.nanosec = 20_000_000  # 20ms\n        \n        trajectory.points = [point]\n        \n        # Publish trajectory\n        self.joint_trajectory_pub.publish(trajectory)\n    \n    def publish_ik_debug(self, positions):\n        \"\"\"Publish IK debug info to /debug/ik_solution (continuous, even without input)\"\"\"\n        ik_debug_msg = JointState()\n        ik_debug_msg.header.stamp = self.get_clock().now().to_msg()\n        \n        # [Key change] Use joint_states order if known to align indices in Foxglove\n        if self.current_joint_state is not None:\n            ik_debug_msg.name = self.current_joint_state.name\n            \n            # Build name-to-position map\n            pos_map = {name: pos for name, pos in zip(self.joint_names, positions)}\n            \n            # Fill positions following joint_states order\n            ordered_positions = []\n            for name in ik_debug_msg.name:\n                if name in pos_map:\n                    ordered_positions.append(pos_map[name])\n                else:\n                    ordered_positions.append(0.0)  # Fallback\n            ik_debug_msg.position = ordered_positions\n        else:\n            # Fallback: use default order\n            ik_debug_msg.name = self.joint_names\n            ik_debug_msg.position = list(positions)\n            \n        self.ik_solution_pub.publish(ik_debug_msg)\n    \n    def publish_ik_raw_debug(self, positions):\n        \"\"\"Publish raw IK solution (pre-processing) to /debug/ik_raw_solution for comparison\"\"\"\n        ik_raw_msg = JointState()\n        ik_raw_msg.header.stamp = self.get_clock().now().to_msg()\n        \n        if self.current_joint_state is not None:\n            ik_raw_msg.name = self.current_joint_state.name\n            pos_map = {name: pos for name, pos in zip(self.joint_names, positions)}\n            ordered_positions = []\n            for name in ik_raw_msg.name:\n                if name in pos_map:\n                    ordered_positions.append(pos_map[name])\n                else:\n                    ordered_positions.append(0.0)\n            ik_raw_msg.position = ordered_positions\n        else:\n            ik_raw_msg.name = self.joint_names\n            ik_raw_msg.position = list(positions)\n            \n        self.ik_raw_solution_pub.publish(ik_raw_msg)\n    \n    def send_cartesian_path_goal(self):\n        \"\"\"Plan Cartesian path with MoveIt (traditional mode) for RViz update and precision\"\"\"\n        # Check if moving (with timeout)\n        if self.is_moving:\n            # Timeout check to avoid permanent block\n            if self.move_start_time is not None:\n                elapsed = (self.get_clock().now() - self.move_start_time).nanoseconds / 1e9\n                if elapsed > self.move_timeout:\n                    self.get_logger().warn(f'运动超时（{elapsed:.1f}s），正在重置状态')\n                    self.is_moving = False\n                else:\n                    return\n            else:\n                return\n        \n        # Mark as moving\n        self.is_moving = True\n        self.move_start_time = self.get_clock().now()\n        \n        # Create Cartesian path request\n        request = GetCartesianPath.Request()\n        request.header.stamp = self.get_clock().now().to_msg()\n        request.header.frame_id = self.base_frame\n        request.group_name = self.planning_group\n        request.link_name = self.end_effector_frame\n        \n        # Set waypoints - target only\n        waypoint = Pose()\n        waypoint.position = self.target_pose.pose.position\n        waypoint.orientation = self.target_pose.pose.orientation\n        request.waypoints = [waypoint]\n        \n        # Set parameters\n        request.max_step = 0.01  # 10mm step\n        request.jump_threshold = 0.0  # Disable jump detection\n        request.avoid_collisions = self.collision_check_active  # Enable collision checking by state\n        \n        # Call service asynchronously\n        future = self.cartesian_path_client.call_async(request)\n        future.add_done_callback(self.cartesian_path_callback)\n        \n    def cartesian_path_callback(self, future):\n        \"\"\"Cartesian path planning callback\"\"\"\n        try:\n            response = future.result()\n            \n            if response.fraction < 0.9:\n                self.is_moving = False\n                return\n            \n            # Get planned trajectory\n            trajectory = response.solution\n            \n            # Speed up trajectory execution\n            self.scale_trajectory_speed(trajectory, 5.0)\n            \n            # Execute trajectory\n            goal_msg = ExecuteTrajectory.Goal()\n            goal_msg.trajectory = trajectory\n            \n            send_goal_future = self.execute_trajectory_client.send_goal_async(goal_msg)\n            send_goal_future.add_done_callback(self.execute_response_callback)\n            \n        except Exception as e:\n            self.is_moving = False\n    \n    def scale_trajectory_speed(self, trajectory, speed_scale):\n        \"\"\"Scale trajectory speed - speed_scale > 1 faster, < 1 slower\"\"\"\n        if speed_scale <= 0:\n            return\n        \n        for point in trajectory.joint_trajectory.points:\n            # Compute new time (speed_scale > 1 shorter time, < 1 longer)\n            total_nsec = point.time_from_start.sec * 1e9 + point.time_from_start.nanosec\n            new_total_nsec = total_nsec / speed_scale\n            point.time_from_start.sec = int(new_total_nsec // 1e9)\n            point.time_from_start.nanosec = int(new_total_nsec % 1e9)\n            \n            # Scale velocities (speed_scale > 1 higher)\n            point.velocities = [v * speed_scale for v in point.velocities]\n            \n            # Scale accelerations (speed_scale > 1 higher)\n            if point.accelerations:\n                point.accelerations = [a * speed_scale * speed_scale for a in point.accelerations]\n    \n    def execute_response_callback(self, future):\n        \"\"\"Execute trajectory response callback\"\"\"\n        try:\n            goal_handle = future.result()\n            \n            if not goal_handle.accepted:\n                self.get_logger().warn('轨迹执行请求被拒绝')\n                self.is_moving = False\n                return\n                \n            # Wait for execution result\n            result_future = goal_handle.get_result_async()\n            result_future.add_done_callback(self.execute_result_callback)\n        except Exception as e:\n            self.get_logger().error(f'执行响应回调异常：{e}')\n            self.is_moving = False\n        \n    def execute_result_callback(self, future):\n        \"\"\"Execute result callback\"\"\"\n        try:\n            result = future.result().result\n            self.is_moving = False\n            \n            if result.error_code.val == result.error_code.SUCCESS:\n                # Update last sent pose\n                self.last_sent_pose = copy.deepcopy(self.target_pose)\n            else:\n                self.get_logger().warn(f'运动失败：error_code={result.error_code.val}')\n        except Exception as e:\n            self.get_logger().error(f'执行结果回调异常：{e}')\n            self.is_moving = False\n\n\n    def enable_gripper_motor(self):\n        \"\"\"Enable gripper motor (ID=7)\"\"\"\n        if self.can_socket is None:\n            return False\n        \n        try:\n            motor_id = self.gripper_motor_id  # 7\n            host_can_id = 253  # 0xFD - host CAN ID\n            comm_type = 3  # Communication type 3: enable motor\n            \n            # Build 29-bit extended CAN ID: (comm_type << 24) | (host_can_id << 8) | motor_id\n            can_id = (comm_type << 24) | (host_can_id << 8) | motor_id\n            can_id |= 0x80000000  # Set extended frame flag\n            \n            # Build 8-byte data (all zeros)\n            data = bytes(8)\n            \n            # Build CAN frame\n            frame = struct.pack('=IB3x8s', can_id, 8, data)\n            \n            # Send\n            self.can_socket.send(frame)\n            self.gripper_enabled = True\n            self.get_logger().info(f'夹爪电机已使能（ID={motor_id}）')\n            return True\n            \n        except Exception as e:\n            self.get_logger().error(f'使能夹爪电机失败：{e}')\n            return False\n\n    def send_gripper_torque(self, torque):\n        \"\"\"\n        Send torque command to gripper motor (ID=7) on can0\n        position=0, velocity=0, kp=0, kd=0, torque=specified value\n        \"\"\"\n        if self.can_socket is None:\n            return False\n        try:\n            self._send_mit_command(\n                self.can_socket, self.gripper_motor_id,\n                0.0, 0.0, 0.0, 0.0, torque)\n            return True\n        except Exception as e:\n            self.get_logger().error(f'发送夹爪指令失败：{e}')\n            return False\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = XboxTeleopNode()\n    \n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\n\nif __name__ == '__main__':\n    main()\n\n"}\n{"instruction": "Write a ROS2 Python node named base_planner.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "# Copyright 2023, Evan Palmer\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n# THE SOFTWARE.\n\nfrom abc import ABC, abstractmethod\n\nfrom moveit_msgs.srv import GetMotionPlan\nfrom rclpy.node import Node\n\n\nclass Planner(Node, ABC):\n    \"\"\"Base class for a planner.\"\"\"\n\n    def __init__(self, node_name: str) -> None:\n        \"\"\"Create a new planner.\n\n        Args:\n            node_name: The name of the ROS node.\n        \"\"\"\n        super().__init__(node_name)\n        Node.__init__(self, node_name)\n        ABC.__init__(self)\n\n        self.planning_srv = self.create_service(\n            GetMotionPlan, f\"/angler/{node_name}/plan\", self.plan\n        )\n\n    @abstractmethod\n    def plan(\n        self, request: GetMotionPlan.Request, response: GetMotionPlan.Response\n    ) -> GetMotionPlan.Response:\n        \"\"\"Get a motion plan for the robot to follow.\n\n        Args:\n            request: The motion plan request.\n            response: The planning response.\n\n        Raises:\n            NotImplementedError: This method hasn't been implemented.\n\n        Returns:\n            The planning response.\n        \"\"\"\n        raise NotImplementedError(\"This method has not yet been implemented!\")\n"}\n{"instruction": "Write a ROS2 Python node named jacobi_robot_ros.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "import numpy as np\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState\nfrom trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint\nfrom builtin_interfaces.msg import Duration\nfrom std_msgs.msg import String\nfrom typing import Optional, List\nfrom teleop.utils.jacobi_robot import JacobiRobot\nfrom rclpy.qos import QoSProfile, QoSReliabilityPolicy, QoSDurabilityPolicy\nimport tempfile\n\n\nclass JacobiRobotROS(JacobiRobot):\n    def __init__(\n        self,\n        node: Node,\n        robot_description_topic: str = \"/robot_description\",\n        ee_link: str = \"end_effector\",\n        joint_names: Optional[List[str]] = None,\n        joint_state_topic: str = \"/joint_states\",\n        position_command_topic: str = \"/joint_trajectory\",\n        max_linear_vel: float = 0.4,\n        max_angular_vel: float = 0.9,\n        max_linear_acc: float = 3.0,\n        max_angular_acc: float = 6.0,\n        max_joint_vel: float = 5.0,\n        min_linear_vel: float = 0.03,\n        min_angular_vel: float = 0.1,\n        linear_gain: float = 5.0,\n        angular_gain: float = 1.0,\n    ):\n        \"\"\"\n        Initialize ROS 2-enabled Jacobian robot.\n\n        Args:\n            node: ROS 2 node instance\n            robot_description_topic: Topic for robot description (URDF)\n            ee_link: End-effector frame name\n            joint_names: List of joint names (if None, will be extracted from URDF)\n            joint_state_topic: Topic for joint states\n            position_command_topic: Topic for position commands\n            velocity_command_topic: Topic for velocity commands\n            max_linear_vel: Maximum linear velocity\n            max_angular_vel: Maximum angular velocity\n            max_linear_acc: Maximum linear acceleration\n            max_angular_acc: Maximum angular acceleration\n            max_joint_vel: Maximum joint velocity\n            min_linear_vel: Minimum linear velocity\n            min_angular_vel: Minimum angular velocity\n            linear_gain: Linear gain for control\n            angular_gain: Angular gain for control\n        \"\"\"\n\n        self.node = node\n        urdf_path = self.__get_robot_description_from_topic(robot_description_topic)\n\n        # Initialize JacobiRobot\n        super().__init__(\n            urdf_path,\n            ee_link,\n            max_linear_vel,\n            max_angular_vel,\n            max_linear_acc,\n            max_angular_acc,\n            max_joint_vel,\n            min_linear_vel,\n            min_angular_vel,\n            linear_gain,\n            angular_gain,\n        )\n\n        self.joint_states_received = False\n\n        # Joint configuration\n        if joint_names is None:\n            self.joint_names = self.__extract_joint_names_from_urdf()\n        else:\n            self.joint_names = joint_names\n\n        # ROS 2 subscribers\n        self.joint_state_sub = self.node.create_subscription(\n            JointState, joint_state_topic, self.__joint_state_callback, 1\n        )\n        self.trajectory_publisher = self.node.create_publisher(\n            JointTrajectory, position_command_topic, 1\n        )\n\n    def __get_robot_description_from_topic(self, topic: str) -> str:\n        # Initialize URDF path from robot description topic\n        urdf = None\n\n        def robot_description_callback(msg: String):\n            nonlocal urdf\n            urdf = msg.data\n\n        robot_description_sub = self.node.create_subscription(\n            String,\n            topic,\n            robot_description_callback,\n            QoSProfile(\n                depth=1,\n                reliability=QoSReliabilityPolicy.RELIABLE,\n                durability=QoSDurabilityPolicy.TRANSIENT_LOCAL,\n            ),\n        )\n        robot_description_sub\n        self.node.get_logger().info(f\"Waiting for robot description on topic: {topic}\")\n        while urdf is None:\n            rclpy.spin_once(self.node, timeout_sec=0.1)\n            if not rclpy.ok():\n                self.node.get_logger().error(\"Failed to receive robot description\")\n                return None\n\n        with tempfile.NamedTemporaryFile(\n            delete=False, suffix=\".urdf\"\n        ) as temp_urdf_file:\n            temp_urdf_file.write(urdf.encode(\"utf-8\"))\n            urdf_path = temp_urdf_file.name\n        self.node.get_logger().info(f\"URDF saved to temporary file: {urdf_path}\")\n        return urdf_path\n\n    def __extract_joint_names_from_urdf(self) -> List[str]:\n        \"\"\"Extract joint names from Pinocchio model.\"\"\"\n\n        # find only non-fixed joints up to end-effector\n        joint_names = []\n        for i in range(1, self.model.njoints):  # Skip universe joint\n            joint_name = self.model.names[i]\n            if joint_name == \"universe\":\n                continue\n\n            joint_names.append(joint_name)\n        return joint_names\n\n    def __joint_state_callback(self, msg: JointState):\n        \"\"\"Callback for joint state updates.\"\"\"\n        if self.joint_states_received:\n            return\n\n        if not msg.name or not msg.position:\n            return\n\n        # Update joint positions\n        for i, name in enumerate(msg.name):\n            if name not in self.joint_names:\n                continue\n            try:\n                self.set_joint_position(name, msg.position[i])\n            except ValueError as e:\n                self.node.get_logger().error(\n                    f\"Failed to set joint position for {name}: {e}\"\n                )\n        self.joint_states_received = True\n\n    def __send_joint_trajectory_topic(\n        self,\n        duration: float = 0.05,\n    ) -> bool:\n        \"\"\"Send joint trajectory via topic (not action).\"\"\"\n        if not self.trajectory_publisher:\n            self.node.get_logger().error(\"Trajectory publisher not available\")\n            return False\n\n        # Create trajectory message\n        traj_msg = JointTrajectory()\n        traj_msg.joint_names = self.joint_names\n\n        # End point\n        end_point = JointTrajectoryPoint()\n        end_point.velocities = [\n            self.get_joint_velocity(name) for name in self.joint_names\n        ]\n        end_point.positions = [\n            self.get_joint_position(name) for name in self.joint_names\n        ]\n\n        end_point.time_from_start = Duration(\n            sec=int(duration), nanosec=int((duration % 1) * 1e9)\n        )\n        traj_msg.points.append(end_point)\n\n        # Publish trajectory\n        self.trajectory_publisher.publish(traj_msg)\n        return True\n\n    def twist(self, linear: np.ndarray, angular: np.ndarray, dt: float = 0.1) -> bool:\n        \"\"\"Send twist command to the robot.\"\"\"\n        reached = super().twist(linear, angular, dt)\n        if reached is None:\n            self.node.get_logger().error(\"Failed to compute joint positions for twist\")\n            return False\n\n        self.__send_joint_trajectory_topic(duration=dt)\n        return reached\n\n    def servo_to_pose(self, target_pose: np.ndarray, dt: float = 0.1) -> bool:\n        reached = super().servo_to_pose(target_pose, dt)\n        if reached is None:\n            self.node.get_logger().error(\n                \"Failed to compute joint positions for target pose\"\n            )\n            return False\n\n        self.__send_joint_trajectory_topic(duration=dt)\n        return reached\n\n    def reset_joint_states(self, blocked: bool = True):\n        \"\"\"Reset the robot state.\"\"\"\n        self.joint_states_received = False\n        if not blocked:\n            return\n        while not self.joint_states_received:\n            rclpy.spin_once(self.node, timeout_sec=0.1)\n            if not rclpy.ok():\n                self.node.get_logger().error(\"Failed to reset robot state\")\n                return\n\n    def are_joint_states_received(self) -> bool:\n        \"\"\"Check if joint states have been received.\"\"\"\n        return self.joint_states_received\n\n\n# sudo apt install ros-jazzy-moveit-resources-panda-moveit-config\n# ros2 launch moveit_resources_panda_moveit_config demo.launch.py\ndef main():\n    \"\"\"Example usage of JacobiRobotROS.\"\"\"\n    rclpy.init()\n\n    try:\n        # Create ROS 2 node\n        node = Node(\"jacobian_robot_node\")\n\n        # Initialize robot with node reference\n        robot = JacobiRobotROS(\n            node=node,\n            ee_link=\"panda_hand\",\n            joint_names=[\n                \"panda_joint1\",\n                \"panda_joint2\",\n                \"panda_joint3\",\n                \"panda_joint4\",\n                \"panda_joint5\",\n                \"panda_joint6\",\n                \"panda_joint7\",\n            ],\n            position_command_topic=\"/panda_arm_controller/joint_trajectory\",\n        )\n\n        node.get_logger().info(\"Waiting for joint states...\")\n        robot.reset_joint_states()\n        node.get_logger().info(\"Joint states received, robot initialized.\")\n\n        # Get current pose\n        current_pose = robot.get_ee_pose()\n        node.get_logger().info(f\"Current EE position: {current_pose[:3, 3]}\")\n\n        target_poses = [\n            np.copy(current_pose),\n            np.copy(current_pose),\n            np.copy(current_pose),\n        ]\n        target_poses[0][:3, 3] += np.array([0.3, 0.0, 0.0])\n        target_poses[1][:3, 3] += np.array([0.0, 0.0, -0.2])\n\n        pose_index = 0\n        while True:\n            reached = robot.servo_to_pose(target_poses[pose_index], dt=0.03)\n            if reached:\n                node.get_logger().info(\"Target pose reached.\")\n                pose_index = (pose_index + 1) % len(target_poses)\n            try:\n                rclpy.spin_once(node, timeout_sec=0.03)\n            except rclpy.executors.ExternalShutdownException:\n                node.get_logger().info(\"Node shutdown, exiting loop\")\n                break\n            except Exception as e:\n                pass\n\n    except Exception as e:\n        print(f\"Error: {e}\")\n        import traceback\n\n        traceback.print_exc()\n    finally:\n        if \"node\" in locals():\n            node.destroy_node()\n        rclpy.shutdown()\n\n\nif __name__ == \"__main__\":\n    main()\n"}\n{"instruction": "Write a ROS2 Python node named demo_pick_and_place.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "#!/usr/bin/env python3\n\"\"\"\nNote: !! This file does not contain the full solution. Your task is to implement the missing parts. !!\n\nDemo script for pick&place task sequence. Compatible with fake, simulated and real robot.\n- ros2 run phantomx_pincher_demos demo_pick_and_place.py\n\nThis demo is used as a part of Gazebo demo `demo_orbit_pick_and_place.launch.py`.\n- ros2 launch phantomx_pincher_demos demo_orbit_pick_and_place.launch.py\n\"\"\"\n\nimport random\nfrom copy import deepcopy\nfrom math import pi\nfrom threading import Thread\nfrom typing import Tuple\n\nimport geometry_msgs.msg\nimport rclpy\nimport std_msgs.msg\nimport tf2_geometry_msgs\nimport tf2_ros\nfrom pymoveit2 import GripperInterface, MoveIt2\nfrom pymoveit2.robots import phantomx_pincher\nfrom rclpy.callback_groups import ReentrantCallbackGroup\nfrom rclpy.node import Node\n\n# Size and pose of a blank module cover (box geometry)\nMODULE_COVER_SIZE: Tuple[float, float, float] = (0.148, 0.148, 0.003)\nMODULE_COVER_POSE = geometry_msgs.msg.PoseStamped(\n    header=std_msgs.msg.Header(\n        frame_id=\"phantomx_pincher_task_board_module_link\",\n    ),\n    pose=geometry_msgs.msg.Pose(\n        position=geometry_msgs.msg.Point(x=0.0, y=0.0, z=MODULE_COVER_SIZE[2] / 2.0),\n        orientation=geometry_msgs.msg.Quaternion(x=0.0, y=0.0, z=0.0, w=1.0),\n    ),\n)\n\n# Size and pose of an object for pick&place (box geometry)\nOBJECT_SIZE: Tuple[float, float, float] = (0.015,) * 3\nINITIAL_OBJECT_POSE = geometry_msgs.msg.PoseStamped(\n    header=std_msgs.msg.Header(\n        frame_id=\"phantomx_pincher_task_board_module_link\",\n    ),\n    pose=geometry_msgs.msg.Pose(\n        # On top of the module (in the centre), with a tolerance of 5 mm\n        position=geometry_msgs.msg.Point(\n            x=0.0,\n            y=0.0,\n            z=MODULE_COVER_SIZE[2] + OBJECT_SIZE[2] / 2.0 + 0.005,\n        ),\n        orientation=geometry_msgs.msg.Quaternion(x=1.0, y=0.0, z=0.0, w=0.0),\n    ),\n)\n\n\ndef main():\n    rclpy.init()\n\n    # Create node for this demo\n    node = Node(\"demo_pick_and_place\")\n\n    # Create callback group that allows execution of callbacks in parallel without restrictions\n    callback_group = ReentrantCallbackGroup()\n\n    # Create MoveIt 2 interfaces\n    moveit2 = MoveIt2(\n        node=node,\n        joint_names=phantomx_pincher.joint_names(),\n        base_link_name=phantomx_pincher.base_link_name(),\n        end_effector_name=phantomx_pincher.end_effector_name(),\n        group_name=phantomx_pincher.MOVE_GROUP_ARM,\n        callback_group=callback_group,\n        execute_via_moveit=True,\n    )\n    gripper = GripperInterface(\n        node=node,\n        gripper_joint_names=phantomx_pincher.gripper_joint_names(),\n        open_gripper_joint_positions=phantomx_pincher.OPEN_GRIPPER_JOINT_POSITIONS,\n        closed_gripper_joint_positions=phantomx_pincher.CLOSED_GRIPPER_JOINT_POSITIONS,\n        gripper_group_name=phantomx_pincher.MOVE_GROUP_GRIPPER,\n        callback_group=callback_group,\n        execute_via_moveit=True,\n    )\n\n    # Instantiate tf2 buffer and listener for looking up transforms\n    tf2_buffer = tf2_ros.Buffer(node=node)\n    tf2_listener = tf2_ros.TransformListener(buffer=tf2_buffer, node=node)\n\n    # Spin the node in background thread(s) and wait a bit for initialization\n    executor = rclpy.executors.MultiThreadedExecutor(2)\n    executor.add_node(node)\n    executor_thread = Thread(target=executor.spin, daemon=True, args=())\n    executor_thread.start()\n    node.create_rate(1.0).sleep()\n\n    # Scale down velocity and acceleration of joints (percentage of maximum)\n    moveit2.max_velocity = 0.5\n    moveit2.max_acceleration = 0.5\n\n    # Wait until the simulated robot is ready to be controlled\n    rate = node.create_rate(1.0)\n    while rclpy.ok() and moveit2.joint_state is None:\n        rate.sleep()\n    rate.destroy()\n\n    ### Setup the Planning Scene ###\n    # Clean the previous scene\n    reset_planning_scene(moveit2=moveit2)\n    # Move to initial joint configuration\n    moveit2.move_to_configuration(\n        joint_positions=[\n            0.0,\n            0.0,\n            pi / 2,\n            pi / 2,\n        ],\n    )\n    moveit2.wait_until_executed()\n    # Setup the new scene\n    setup_planning_scene(moveit2=moveit2)\n\n    # Initialize the grasp pose\n    grasp_pose = INITIAL_OBJECT_POSE\n    grasp_pose.pose.position.z += OBJECT_SIZE[2]\n\n    ##\n    # TODO: Make your changes here (pick & place the object)\n    ##\n\n    rclpy.shutdown()\n    executor_thread.join()\n    exit(0)\n\n\ndef setup_planning_scene(\n    moveit2: MoveIt2,\n):\n    \"\"\"\n    Setup the planning scene of MoveIt for collision checking.\n    \"\"\"\n\n    ## 1: Add `module_cover` to the planning scene\n    moveit2.add_collision_box(\n        \"module_cover\",\n        pose=MODULE_COVER_POSE,\n        size=MODULE_COVER_SIZE,\n    )\n\n    ## 2 (Optional): Add `object` to the planning scene\n    moveit2.add_collision_box(\n        \"object\",\n        pose=INITIAL_OBJECT_POSE,\n        size=OBJECT_SIZE,\n    )\n\n\ndef reset_planning_scene(\n    moveit2: MoveIt2,\n):\n    \"\"\"\n    Remove all scene objects from previous run.\n    \"\"\"\n\n    moveit2.detach_all_collision_objects()\n    moveit2.remove_collision_object(\"module_cover\")\n    moveit2.remove_collision_object(\"object\")\n\n\nif __name__ == \"__main__\":\n    main()\n"}\n{"instruction": "Write a ROS2 Python node named pick_place_loop.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "#!/usr/bin/env python3\n# Copyright 2026 selfpatch\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Continuous pick-and-place loop for MoveIt 2 Panda demo.\n\nPerforms repeating pick-and-place cycles so faults can be injected mid-operation.\nUses MoveGroupInterface via the MoveGroup action for motion planning and execution.\n\nAll targets are joint-space goals for guaranteed reachability in both\nfake-hardware and Gazebo simulation modes.\n\"\"\"\n\nimport rclpy\nfrom rclpy.node import Node\nfrom rclpy.action import ActionClient\nfrom action_msgs.msg import GoalStatus\nfrom moveit_msgs.action import MoveGroup\nfrom moveit_msgs.msg import Constraints, JointConstraint\n\n# Joint-space targets (all within Panda limits, collision-free)\nPANDA_TARGETS = {\n    # \"ready\" / home — standard upright pose from SRDF\n    \"ready\": {\n        \"panda_joint1\": 0.0,\n        \"panda_joint2\": -0.785,   # -π/4\n        \"panda_joint3\": 0.0,\n        \"panda_joint4\": -2.356,   # -3π/4\n        \"panda_joint5\": 0.0,\n        \"panda_joint6\": 1.571,    # π/2\n        \"panda_joint7\": 0.785,    # π/4\n    },\n    # \"pick\" — arm reaching forward and down\n    \"pick\": {\n        \"panda_joint1\": 0.0,\n        \"panda_joint2\": 0.3,\n        \"panda_joint3\": 0.0,\n        \"panda_joint4\": -1.5,\n        \"panda_joint5\": 0.0,\n        \"panda_joint6\": 1.9,\n        \"panda_joint7\": 0.785,\n    },\n    # \"place\" — arm reaching to the left\n    \"place\": {\n        \"panda_joint1\": 1.2,\n        \"panda_joint2\": 0.0,\n        \"panda_joint3\": 0.3,\n        \"panda_joint4\": -1.8,\n        \"panda_joint5\": 0.0,\n        \"panda_joint6\": 1.9,\n        \"panda_joint7\": 0.785,\n    },\n}\n\n\nclass PickPlaceLoop(Node):\n    \"\"\"Repeatedly executes pick-and-place cycles using MoveGroup action.\"\"\"\n\n    def __init__(self):\n        super().__init__(\"pick_place_loop\")\n\n        # Parameters\n        self.declare_parameter(\"cycle_delay_sec\", 5.0)\n        self.cycle_delay = self.get_parameter(\"cycle_delay_sec\").value\n\n        # MoveGroup action client\n        # In MoveIt 2 Jazzy, MoveGroupMoveAction serves at /move_action\n        self.move_group_client = ActionClient(self, MoveGroup, \"/move_action\")\n\n        # State machine: pick → place → home → pick ...\n        self.cycle_count = 0\n        self.phases = [\"pick\", \"place\", \"home\"]\n        self.phase_idx = 0\n\n        # State flags\n        self.move_group_ready = False\n        self.goal_in_flight = False  # Guard against overlapping goals\n\n        # Wait for MoveGroup with periodic retries (non-blocking startup)\n        self.get_logger().info(\"PickPlaceLoop initialized, waiting for MoveGroup...\")\n        self.startup_timer = self.create_timer(5.0, self.check_move_group_ready)\n\n    def check_move_group_ready(self):\n        \"\"\"Periodically check if MoveGroup action server is available.\"\"\"\n        if self.move_group_client.server_is_ready():\n            self.get_logger().info(\"MoveGroup available, starting pick-and-place loop\")\n            self.move_group_ready = True\n            self.startup_timer.cancel()\n\n            # Start the cycle timer\n            self.timer = self.create_timer(self.cycle_delay, self.execute_cycle)\n        else:\n            self.get_logger().info(\n                \"MoveGroup not yet available, retrying in 5 seconds...\"\n            )\n\n    def execute_cycle(self):\n        \"\"\"One pick-and-place cycle step.\"\"\"\n        if not self.move_group_ready:\n            return\n        if self.goal_in_flight:\n            return  # Skip — previous goal still executing\n\n        phase = self.phases[self.phase_idx]\n        self.cycle_count += 1\n        self.get_logger().info(f\"=== Cycle {self.cycle_count} ({phase}) ===\")\n\n        # Map phase to joint target\n        target_name = \"ready\" if phase == \"home\" else phase\n        self.send_joint_goal(target_name, phase)\n\n    def send_joint_goal(self, target_name, label):\n        \"\"\"Send a MoveGroup goal using joint-space target values.\"\"\"\n        joint_values = PANDA_TARGETS.get(target_name)\n        if not joint_values:\n            self.get_logger().error(f\"Unknown target: {target_name}\")\n            return\n\n        goal = MoveGroup.Goal()\n        goal.request.group_name = \"panda_arm\"\n        goal.request.num_planning_attempts = 5\n        goal.request.allowed_planning_time = 5.0\n        goal.planning_options.plan_only = False\n        goal.planning_options.replan = True\n        goal.planning_options.replan_attempts = 3\n\n        # Build joint constraints\n        constraints = Constraints()\n        for joint_name, position in joint_values.items():\n            jc = JointConstraint()\n            jc.joint_name = joint_name\n            jc.position = position\n            jc.tolerance_above = 0.01\n            jc.tolerance_below = 0.01\n            jc.weight = 1.0\n            constraints.joint_constraints.append(jc)\n        goal.request.goal_constraints.append(constraints)\n\n        self.get_logger().info(f\"Sending {label} goal (target: {target_name})...\")\n        self.goal_in_flight = True\n        future = self.move_group_client.send_goal_async(goal)\n        future.add_done_callback(lambda f: self.goal_response_callback(f, label))\n\n    def goal_response_callback(self, future, label):\n        \"\"\"Handle MoveGroup goal acceptance/rejection.\"\"\"\n        goal_handle = future.result()\n        if not goal_handle.accepted:\n            self.get_logger().error(f\"{label} goal REJECTED\")\n            self.goal_in_flight = False\n            return\n\n        self.get_logger().info(f\"{label} goal accepted, waiting for result...\")\n        result_future = goal_handle.get_result_async()\n        result_future.add_done_callback(lambda f: self.result_callback(f, label))\n\n    def result_callback(self, future, label):\n        \"\"\"Handle MoveGroup result and advance state machine.\"\"\"\n        result = future.result().result\n        status = future.result().status\n\n        self.goal_in_flight = False\n\n        if status == GoalStatus.STATUS_SUCCEEDED:\n            self.get_logger().info(f\"{label} SUCCEEDED\")\n            # Advance state machine\n            self.phase_idx = (self.phase_idx + 1) % len(self.phases)\n        else:\n            error_code = result.error_code.val if result else \"unknown\"\n            self.get_logger().warn(\n                f\"{label} FAILED with status {status}, error_code={error_code}\"\n            )\n            # On failure, retry same phase next cycle\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = PickPlaceLoop()\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        # Allow clean shutdown on Ctrl+C without printing a traceback.\n        pass\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\n\nif __name__ == \"__main__\":\n    main()\n"}\n{"instruction": "Write a ROS2 Python node named ex_collision_primitive.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "#!/usr/bin/env python3\n\"\"\"\nExample of adding and removing a collision object with a primitive geometry.\n- ros2 run pymoveit2 ex_collision_primitive.py --ros-args -p shape:=\"sphere\" -p position:=\"[0.5, 0.0, 0.5]\" -p dimensions:=\"[0.04]\"\n- ros2 run pymoveit2 ex_collision_primitive.py --ros-args -p shape:=\"cylinder\" -p position:=\"[0.2, 0.0, -0.045]\" -p quat_xyzw:=\"[0.0, 0.0, 0.0, 1.0]\" -p dimensions:=\"[0.04, 0.02]\"\n- ros2 run pymoveit2 ex_collision_primitive.py --ros-args -p action:=\"remove\" -p shape:=\"sphere\"\n- ros2 run pymoveit2 ex_collision_primitive.py --ros-args -p action:=\"move\" -p shape:=\"sphere\" -p position:=\"[0.2, 0.0, 0.2]\"\n\"\"\"\n\nfrom threading import Thread\n\nimport rclpy\nfrom rclpy.callback_groups import ReentrantCallbackGroup\nfrom rclpy.node import Node\n\nfrom pymoveit2 import MoveIt2\nfrom pymoveit2.robots import panda as robot\n\n\ndef main():\n    rclpy.init()\n\n    # Create node for this example\n    node = Node(\"ex_collision_primitive\")\n\n    # Declare parameter for joint positions\n    node.declare_parameter(\n        \"shape\",\n        \"box\",\n    )\n    node.declare_parameter(\n        \"action\",\n        \"add\",\n    )\n    node.declare_parameter(\"position\", [0.5, 0.0, 0.5])\n    node.declare_parameter(\"quat_xyzw\", [0.0, 0.0, -0.7071, 0.7071])\n    node.declare_parameter(\"dimensions\", [0.1, 0.1, 0.1])\n\n    # Create callback group that allows execution of callbacks in parallel without restrictions\n    callback_group = ReentrantCallbackGroup()\n\n    # Create MoveIt 2 interface\n    moveit2 = MoveIt2(\n        node=node,\n        joint_names=robot.joint_names(),\n        base_link_name=robot.base_link_name(),\n        end_effector_name=robot.end_effector_name(),\n        group_name=robot.MOVE_GROUP_ARM,\n        callback_group=callback_group,\n    )\n\n    # Spin the node in background thread(s) and wait a bit for initialization\n    executor = rclpy.executors.MultiThreadedExecutor(2)\n    executor.add_node(node)\n    executor_thread = Thread(target=executor.spin, daemon=True, args=())\n    executor_thread.start()\n    node.create_rate(1.0).sleep()\n\n    # Get parameters\n    shape = node.get_parameter(\"shape\").get_parameter_value().string_value\n    action = node.get_parameter(\"action\").get_parameter_value().string_value\n    position = node.get_parameter(\"position\").get_parameter_value().double_array_value\n    quat_xyzw = node.get_parameter(\"quat_xyzw\").get_parameter_value().double_array_value\n    dimensions = (\n        node.get_parameter(\"dimensions\").get_parameter_value().double_array_value\n    )\n\n    # Use the name of the primitive shape as the ID\n    object_id = shape\n\n    if action == \"add\":\n        # Add collision primitive\n        node.get_logger().info(\n            f\"Adding collision primitive of type '{shape}' \"\n            f\"{{position: {list(position)}, quat_xyzw: {list(quat_xyzw)}, dimensions: {list(dimensions)}}}\"\n        )\n        if shape == \"box\":\n            moveit2.add_collision_box(\n                id=object_id, position=position, quat_xyzw=quat_xyzw, size=dimensions\n            )\n        elif shape == \"sphere\":\n            moveit2.add_collision_sphere(\n                id=object_id, position=position, radius=dimensions[0]\n            )\n        elif shape == \"cylinder\":\n            moveit2.add_collision_cylinder(\n                id=object_id,\n                position=position,\n                quat_xyzw=quat_xyzw,\n                height=dimensions[0],\n                radius=dimensions[1],\n            )\n        elif shape == \"cone\":\n            moveit2.add_collision_cone(\n                id=object_id,\n                position=position,\n                quat_xyzw=quat_xyzw,\n                height=dimensions[0],\n                radius=dimensions[1],\n            )\n        else:\n            raise ValueError(f\"Unknown shape '{shape}'\")\n    elif action == \"remove\":\n        # Remove collision primitive\n        node.get_logger().info(f\"Removing collision primitive with ID '{object_id}'\")\n        moveit2.remove_collision_object(id=object_id)\n    elif action == \"move\":\n        # Move collision primitive\n        node.get_logger().info(\n            f\"Moving collision primitive with ID '{object_id}' to \"\n            f\"{{position: {list(position)}, quat_xyzw: {list(quat_xyzw)}}}\"\n        )\n        moveit2.move_collision(id=object_id, position=position, quat_xyzw=quat_xyzw)\n    else:\n        raise ValueError(\n            f\"Unknown action '{action}'. Valid values are 'add', 'remove', 'move'\"\n        )\n\n    rclpy.shutdown()\n    executor_thread.join()\n    exit(0)\n\n\nif __name__ == \"__main__\":\n    main()\n"}\n{"instruction": "Write a ROS2 Python node named arm_driver_node.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "#!/usr/bin/env python3\n\"\"\"\nArm Driver Node for Feetech Servos with MoveIt2 Integration.\n\nThis node provides ROS2 interface for controlling a 6-DOF robotic arm\nequipped with Feetech ST3215 serial servos. It translates joint trajectory\ncommands from MoveIt2 into servo control signals and publishes joint states.\n\nAuthor: lododo\nLicense: Apache 2.0\n\"\"\"\n\nimport traceback\nimport rclpy\nfrom rclpy.node import Node\nfrom rclpy.action import ActionServer\nfrom sensor_msgs.msg import JointState\nfrom std_msgs.msg import Float64MultiArray\nfrom control_msgs.action import FollowJointTrajectory\nfrom trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint\nfrom rclpy.callback_groups import ReentrantCallbackGroup\nfrom std_srvs.srv import Trigger\nfrom sensor_msgs.msg import JointState as JointStateMsg\nimport time\nimport threading\nimport math\nimport numpy as np\nfrom rclpy.qos import (\n    QoSProfile,\n    QoSReliabilityPolicy,\n    QoSDurabilityPolicy,\n    QoSHistoryPolicy,\n)\n\n# Import Feetech servo controller\nfrom .sdk.ftservo.ft_arm_controller import ServoArmController\nfrom .gripper_adapter import normalize_gripper_input, angle_to_servo_position\n\n\nclass ArmDriverNode(Node):\n    \"\"\"\n    ROS2 driver node for Feetech servo-based robotic arm.\n    \n    Provides:\n    - Joint state publishing for ROS2 Control/MoveIt2\n    - Trajectory execution via FollowJointTrajectory action\n    - Gripper control with position feedback\n    - Calibration and home position reset services\n    \"\"\"\n    \n    def __init__(self):\n        super().__init__(\"arm_driver_node\")\n\n        # Calibration and reset services\n        self.calibration_service = self.create_service(\n            Trigger, \"/arm/calibrate\", self.calibration_callback\n        )\n\n        self.reset_service = self.create_service(\n            Trigger, \"/arm/reset_to_home\", self.reset_to_home_callback\n        )\n\n        # Safe initial position (all joints at 0 radians)\n        self.safe_position = [0.0, 0.0, 0.0, 0.0, 0.0]\n\n        # ROS2 parameters declaration\n        self.declare_parameter(\"serial_port\", \"/dev/ttyACM0\")\n        self.declare_parameter(\"baud_rate\", 1000000)  # Feetech default: 1M baud\n        self.declare_parameter(\"update_rate\", 20.0)  # Hz, joint state publishing rate\n        self.declare_parameter(\"cmd_delay_time\", 0.002)  # Delay between servo commands (s)\n\n        # Fast trajectory execution mode parameters\n        self.declare_parameter(\"fast_trajectory_execution\", False)\n        self.declare_parameter(\n            \"fast_trajectory_threshold\", 10\n        )  # Enable fast mode when waypoints > threshold\n\n        self.declare_parameter(\"auto_reset_home\", False)  # Auto-reset to home on startup\n\n        # Load fast execution mode settings\n        self.use_fast_mode = self.get_parameter(\"fast_trajectory_execution\").value\n        self.fast_threshold = self.get_parameter(\"fast_trajectory_threshold\").value\n        self.auto_reset_home = self.get_parameter(\"auto_reset_home\").value\n\n        # Joint names configuration\n        self.joint_names = [\"joint1\", \"joint2\", \"joint3\", \"joint4\", \"joint5\"]\n        self.finger_joint_name = \"finger_joint1\"\n\n        # Servo position to radians conversion constants\n        self.CENTER_POSITION = 2048  # Center position (0 radians)\n        self.POSITION_PER_RAD = 2048 / math.pi  # Position units per radian\n        self.POINTS_BATCH_SIZE = 20  # Feedback publishing interval (waypoints)\n\n        # Initialize joint state variables\n        self.joint_positions = [0.0, 0.0, 0.0, 0.0, 0.0]  # Radians\n        self.joint_velocities = [0.0, 0.0, 0.0, 0.0, 0.0]  # Currently unused\n        self.gripper_position = 0.0  # Radians\n\n        # Initialize hardware connection\n        self.init_hardware()\n\n        # Create QoS profile compatible with robot_state_publisher\n        state_qos = QoSProfile(\n            reliability=QoSReliabilityPolicy.RELIABLE,\n            durability=QoSDurabilityPolicy.TRANSIENT_LOCAL,  # Critical for TF synchronization\n            history=QoSHistoryPolicy.KEEP_LAST,\n            depth=10,\n        )\n\n        # Joint state publisher for ROS2 Control/MoveIt2\n        self.joint_state_publisher = self.create_publisher(\n            JointState, \"/joint_states\", qos_profile=state_qos\n        )\n        \n        # Callback group for concurrent action handling\n        self.callback_group = ReentrantCallbackGroup()\n\n        # Action server for arm trajectory execution\n        self._action_server = ActionServer(\n            self,\n            FollowJointTrajectory,\n            \"/arm_controller/follow_joint_trajectory\",\n            self.execute_trajectory_callback,\n            callback_group=self.callback_group,\n        )\n\n        # Action server for gripper control\n        self._gripper_action_server = ActionServer(\n            self,\n            FollowJointTrajectory,\n            \"/hand_controller/follow_joint_trajectory\",\n            self.execute_gripper_callback,\n            callback_group=self.callback_group,\n        )\n        \n        # Joint command subscriber (alternative to action interface)\n        self.joint_command_subscription = self.create_subscription(\n            Float64MultiArray,\n            \"/arm_controller/commands\",\n            self.joint_command_callback,\n            10,\n        )\n\n        # Gripper command subscriber\n        self.gripper_command_subscription = self.create_subscription(\n            Float64MultiArray,\n            \"/hand_controller/commands\",\n            self.gripper_command_callback,\n            10,\n        )\n\n        # Timer for periodic joint state reading and publishing\n        self.timer = self.create_timer(\n            1.0 / self.get_parameter(\"update_rate\").value, self.timer_callback\n        )\n\n        # Hardware access lock to prevent concurrent access\n        self.hw_lock = threading.Lock()\n\n        self.get_logger().info(\"Feetech arm driver node initialized (action servers ready)\")\n\n    def init_hardware(self):\n        \"\"\"Initialize servo controller\"\"\"\n        try:\n            serial_port = self.get_parameter(\"serial_port\").value\n            baud_rate = self.get_parameter(\"baud_rate\").value\n\n            # Add debug log\n            self.get_logger().info(\n                f\"Attempting to connect to servos, port: {serial_port}, baud rate: {baud_rate}\"\n            )\n\n            # Create servo controller instance\n            self.servo_controller = ServoArmController(\n                self,  # Pass current ROS2 node to use its logging system\n                port_name=serial_port,\n                baudrate=baud_rate,\n                servo_count=6,  # 5 joint servos + 1 gripper servo\n                cmd_delay_time=(\n                    self.get_parameter(\"cmd_delay_time\").value\n                    if self.has_parameter(\"cmd_delay_time\")\n                    else 0.02\n                ),  # Default 0.02 seconds\n            )\n\n            # Connect to servos\n            if not self.servo_controller.connect():\n                raise Exception(\"Cannot connect to servo controller\")\n\n            # Enable servo torque\n            self.servo_controller.setup_torque(None, enable_value=1)\n\n            # Initialize state\n            self.hardware_connected = True\n            self.get_logger().info(\"Connected to Feetech servo arm hardware\")\n\n            # Auto-reset to home position\n            if self.auto_reset_home:\n                result = self.reset_to_home_callback()\n                if result:\n                    self.get_logger().info(\"Reset to home position completed\")\n                else:\n                    self.get_logger().error(\"Failed to reset to home position\")\n\n        except Exception as e:\n            self.get_logger().error(f\"Failed to connect to servo controller: {str(e)}\")\n            self.hardware_connected = False\n            self.servo_controller = None\n\n    def servo_initialize_to_center_position(self):\n        \"\"\"Initialize servos to center position\"\"\"\n        try:\n            self.servo_controller.initialize_to_center()\n            self.get_logger().info(\"Servos initialized to center position\")\n        except Exception as e:\n            self.get_logger().error(f\"Failed to initialize servos: {str(e)}\")\n\n    def position_to_radians(self, position, joint_index=0):\n        \"\"\"Convert servo position to radians\"\"\"\n        # Center position 2048 corresponds to 0 radians\n        # Basic conversion\n        rad = (position - self.CENTER_POSITION) / self.POSITION_PER_RAD\n\n        # Define conservative joint limits (within URDF constraints)\n        joint_limits = [\n            (-2.96, 2.96),   # joint1: ~±170deg (10deg margin)\n            (-2.35, 2.35),   # joint2: ~±135deg (10deg margin)\n            (-0.01, 3.01),   # joint3: ~0-172deg\n            (-1.57, 1.57),   # joint4: ~±90deg\n            (-3.14, 3.14),   # joint5: ~±180deg\n            (-1.60, 0.05),   # joint6 (finger_joint1): -91.5° ~ 2.9° gripper protection\n        ]\n\n        # Apply strict limits\n        if 0 <= joint_index < len(joint_limits):\n            min_limit, max_limit = joint_limits[joint_index]\n            rad = max(min_limit, min(max_limit, rad))\n\n            # Log warning if exceeds limits\n            original_rad = (position - self.CENTER_POSITION) / self.POSITION_PER_RAD\n            if original_rad < min_limit or original_rad > max_limit:\n                self.get_logger().warn(\n                    f\"Joint{joint_index+1}exceeds limits: {original_rad:.3f} -> {rad:.3f}\"\n                )\n\n        return rad\n\n    def radians_to_position(self, radians):\n        \"\"\"Convert radians to servo position\"\"\"\n        # Limit to valid servo range\n        position = int(self.CENTER_POSITION + radians * self.POSITION_PER_RAD)\n        return max(0, min(4095, position))  # Limit to 0-4095 range\n\n    def timer_callback(self):\n        \"\"\"Periodically read and publish servo state\"\"\"\n        if not self.hardware_connected:\n            # If hardware disconnected, attempt to reconnect\n            try:\n                self.init_hardware()\n            except Exception:\n                return\n\n        try:\n            with self.hw_lock:\n                # Read current position from servos\n                positions = self.servo_controller.read_position()\n\n                # If read fails\n                if positions is None:\n                    self.get_logger().warn(\"Failed to read servo positions\")\n                    return\n\n                # Convert position to radians and apply joint limits\n                for i in range(1, 6):\n                    if i in positions:\n                        self.joint_positions[i - 1] = self.position_to_radians(\n                            positions[i], i - 1  # Pass joint index\n                        )\n\n                        # Gripper position (if available)\n                        if 6 in positions:\n                            # Use adapter to convert servo position to radians (reverse mapping)\n                            gripper_servo_pos = positions[6]\n                            gripper_rad = self.position_to_radians(gripper_servo_pos, 5)\n                            self.gripper_position = gripper_rad\n\n            # Use sequence number to generate monotonic timestamp\n            # self.sequence_number += 1\n            # timestamp_ns = self.base_time.nanoseconds + (self.sequence_number * 50_000_000)  # Increment by 50ms each time\n\n            # current_time = rclpy.time.Time(nanoseconds=timestamp_ns)\n            # Check if all joint values are in reasonable range\n            valid_state = True\n            for i, pos in enumerate(self.joint_positions):\n                if abs(pos) > 3.14:  # Exceeds 180 degrees\n                    self.get_logger().error(f\"Joint{i+1}position abnormal: {pos:.3f} rad\")\n                    valid_state = False\n\n            if not valid_state:\n                self.get_logger().error(\"Detected abnormal joint state, skipping publish\")\n                return\n            # Use actual current time instead of sequence time\n            current_time = self.get_clock().now()\n            # Publish joint state\n            joint_state = JointState()\n            joint_state.header.stamp = current_time.to_msg()\n            joint_state.header.frame_id = \"\"  # Empty frame_id\n            joint_state.name = self.joint_names + [self.finger_joint_name]\n            joint_state.position = self.joint_positions + [self.gripper_position]\n            joint_state.velocity = [0.0] * len(joint_state.name)\n            joint_state.effort = [0.0] * len(joint_state.name)\n\n            self.joint_state_publisher.publish(joint_state)\n\n            self.get_logger().debug(\n                f\"Published servo state: {joint_state.name} - position: {joint_state.position}\"\n            )\n        except Exception as e:\n            self.get_logger().error(f\"Failed to read servo state: {str(e)}\")\n            self.hardware_connected = False\n\n    def joint_command_callback(self, msg):\n        \"\"\"Handle joint commands from MoveIt/controller\"\"\"\n        if not self.hardware_connected:\n            return\n\n        try:\n            with self.hw_lock:\n                # Convert radian commands to servo positions\n                positions = {}\n                for i, rad in enumerate(msg.data):\n                    if i < 5:  # 5 joint servos\n                        servo_id = i + 1\n                        position = self.radians_to_position(rad)\n                        positions[servo_id] = position\n\n                # Set servo positions\n                if positions:\n                    if self.servo_controller.set_all_positions(positions):\n                        # Execute movement\n                        self.servo_controller.execute_movement()\n                        self.get_logger().debug(f\"Sent joint command: {positions}\")\n                    else:\n                        self.get_logger().warn(\"Failed to set servo positions\")\n\n        except Exception as e:\n            self.get_logger().error(f\"Failed to send joint command: {str(e)}\")\n\n    def gripper_command_callback(self, msg):\n        \"\"\"Handle gripper commands\"\"\"\n        if not self.hardware_connected or not msg.data:\n            return\n\n        try:\n            with self.hw_lock:\n                # Compatible with multiple inputs: angle (rad), legacy width (m), or list\n                rad = normalize_gripper_input(msg.data, max_width_m=0.04)\n                gripper_position = angle_to_servo_position(rad)\n\n                # Set gripper servo position\n                if self.servo_controller.set_position(6, gripper_position):\n                    # Execute movement\n                    self.servo_controller.execute_movement()\n                    self.get_logger().debug(f\"Sent gripper command: {gripper_position} (rad={rad:.3f})\")\n                else:\n                    self.get_logger().warn(\"Failed to set gripper position\")\n\n        except Exception as e:\n            self.get_logger().error(f\"Failed to send gripper command: {str(e)}\")\n\n    def execute_trajectory_callback(self, goal_handle):\n        \"\"\"Handle FollowJointTrajectory action request\"\"\"\n        trajectory = goal_handle.request.trajectory\n        self.get_logger().info(f\"Received trajectory execution request: {len(trajectory.points)} waypoints\")\n\n        # Create result object\n        result = FollowJointTrajectory.Result()\n\n        try:\n            total_points = len(trajectory.points)\n            # Decide which waypoints to execute\n            if self.use_fast_mode and total_points > self.fast_threshold:\n                self.get_logger().info(\n                    f\"Using fast execution mode: executing only first and last waypoints (skipped {total_points-2} intermediate waypoints)\"\n                )\n                points_to_execute = [trajectory.points[0], trajectory.points[-1]]\n            else:\n                self.get_logger().info(\n                    f\"Using full execution mode: executing all {total_points} waypoints\"\n                )\n                points_to_execute = trajectory.points\n\n            # Process each point in trajectory\n            for i, point in enumerate(points_to_execute):\n\n                # Index of current point in original trajectory (for logging)\n                point_idx = (\n                    0\n                    if i == 0\n                    else total_points - 1 if i == len(points_to_execute) - 1 else i\n                )\n\n                # Check cancel request (reduced frequency)\n                if i % self.POINTS_BATCH_SIZE == 0 and goal_handle.is_cancel_requested:\n                    goal_handle.canceled()\n                    result.error_code = (\n                        FollowJointTrajectory.Result.GOAL_TOLERANCE_VIOLATED\n                    )\n                    result.error_string = \"Trajectory execution canceled\"\n                    return result\n\n                # Send feedback (reduced frequency)\n                if i % self.POINTS_BATCH_SIZE == 0:\n                    feedback_msg = FollowJointTrajectory.Feedback()\n                    feedback_msg.joint_names = trajectory.joint_names\n                    feedback_msg.actual.positions = self.joint_positions\n                    feedback_msg.desired.positions = list(point.positions)\n                    feedback_msg.error.positions = [\n                        d - a for d, a in zip(point.positions, self.joint_positions)\n                    ]\n                    goal_handle.publish_feedback(feedback_msg)\n\n                # Prepare position data\n                positions = {}\n                for j, joint_name in enumerate(trajectory.joint_names):\n                    if joint_name in self.joint_names:\n                        joint_index = self.joint_names.index(joint_name)\n                        servo_id = joint_index + 1\n                        target_rad = point.positions[j]\n                        position = self.radians_to_position(target_rad)\n                        positions[servo_id] = position\n\n                # Set servo positions - critical fix\n                with self.hw_lock:\n                    success = True\n                    # Fallback to original method\n                    success = self.servo_controller.set_all_positions(positions)\n                    if not success:\n                        result.error_code = FollowJointTrajectory.Result.INVALID_JOINTS\n                        result.error_string = f\"Failed to set servo positions at waypoint {point_idx+1}\"\n                        goal_handle.abort()\n                        return result\n\n                    # Step 2: Execute movement command (critical!)\n                    self.get_logger().debug(\"Executing servo movement command...\")\n                    if not self.servo_controller.execute_movement():\n                        self.get_logger().error(\"Failed to execute servo movement command\")\n                        result.error_code = FollowJointTrajectory.Result.INVALID_JOINTS\n                        result.error_string = f\"Failed to execute movement at waypoint{point_idx+1}\"\n                        goal_handle.abort()\n                        return result\n\n                # Reduce log output\n                if i % self.POINTS_BATCH_SIZE == 0 or i == total_points - 1:\n                    self.get_logger().info(\n                        f\"Trajectory progress: {point_idx+1}/{total_points}\"\n                    )\n                # # Wait for movement completion - adjust based on trajectory time\n                # expected_duration = point.time_from_start.sec + point.time_from_start.nanosec / 1e9\n                # if i == 0:\n                #     wait_time = max(1.0, expected_duration)\n                # else:\n                #     prev_duration = trajectory.points[i-1].time_from_start.sec + trajectory.points[i-1].time_from_start.nanosec / 1e9\n                #     wait_time = max(0.5, expected_duration - prev_duration)\n\n                # self.get_logger().info(f'Waiting {wait_time:.2f} seconds for movement completion...')\n                # time.sleep(wait_time)\n\n            # Trajectory execution successful\n            result.error_code = FollowJointTrajectory.Result.SUCCESSFUL\n            result.error_string = \"Trajectory execution successful\"\n            goal_handle.succeed()\n            self.get_logger().info(\"Trajectory execution completed!\")\n            return result\n\n        except Exception as e:\n            self.get_logger().error(f\"Trajectory execution failed: {str(e)}\")\n            result.error_code = FollowJointTrajectory.Result.INVALID_GOAL\n            result.error_string = f\"Trajectory execution exception: {str(e)}\"\n            goal_handle.abort()\n            return result\n\n    def execute_gripper_callback(self, goal_handle):\n        \"\"\"Handle gripper FollowJointTrajectory action request\"\"\"\n        trajectory = goal_handle.request.trajectory\n        self.get_logger().info(\"Received gripper trajectory execution request\")\n\n        # Create result object\n        result = FollowJointTrajectory.Result()\n\n        try:\n            # Take only the last waypoint position\n            if not trajectory.points:\n                result.error_code = FollowJointTrajectory.Result.INVALID_GOAL\n                result.error_string = \"Trajectory is empty\"\n                goal_handle.abort()\n                return result\n\n            # Get final position point\n            final_point = trajectory.points[-1]\n\n            # Assume gripper joint is the first joint\n            gripper_rad = normalize_gripper_input(final_point.positions[0], max_width_m=0.04)\n\n            # Map to servo position\n            gripper_position = angle_to_servo_position(gripper_rad)\n\n            self.get_logger().info(\n                f\"Gripper target: {gripper_rad:.3f}rad -> position{gripper_position}\"\n            )\n\n            # Set gripper servo position\n            with self.hw_lock:\n                # Step 1: Set positions\n                if not self.servo_controller.set_position(6, gripper_position):\n                    self.get_logger().warn(\"Failed to set gripper position\")\n                    result.error_code = FollowJointTrajectory.Result.INVALID_JOINTS\n                    result.error_string = \"Failed to set gripper position\"\n                    goal_handle.abort()\n                    return result\n\n                # Step 2: Execute movement (critical!)\n                if not self.servo_controller.execute_movement():\n                    self.get_logger().error(\"Failed to execute gripper movement command\")\n                    result.error_code = FollowJointTrajectory.Result.INVALID_JOINTS\n                    result.error_string = \"Failed to execute gripper movement command\"\n                    goal_handle.abort()\n                    return result\n\n                self.get_logger().debug(f\"Gripper command completed: {gripper_position}\")\n\n                # Wait for movement completion\n                time.sleep(1.0)\n\n                result.error_code = FollowJointTrajectory.Result.SUCCESSFUL\n                result.error_string = \"Gripper command execution successful\"\n                goal_handle.succeed()\n                return result\n\n        except Exception as e:\n            self.get_logger().error(f\"Failed to execute gripper command: {str(e)}\")\n            result.error_code = FollowJointTrajectory.Result.INVALID_GOAL\n            result.error_string = f\"Gripper command execution exception: {str(e)}\"\n            goal_handle.abort()\n            return result\n\n    def calibration_callback(self, request, response):\n        \"\"\"Calibrate joints to safe position\"\"\"\n        try:\n            self.get_logger().info(\"Starting calibration to safe position...\")\n\n            # Set all joints to center position\n            safe_positions = {}\n            for i in range(1, 7):\n                safe_positions[i] = self.CENTER_POSITION  # 2048 is center position\n\n            # Send to hardware\n            with self.hw_lock:\n                result = self.servo_controller.set_all_positions(safe_positions)\n\n            if result and self.servo_controller.execute_movement():\n                # Update internal state\n                self.joint_positions = [0.0] * 5\n                self.gripper_position = 0.0\n\n                response.success = True\n                response.message = \"Calibration completed, arm moved to safe position\"\n                self.get_logger().info(\"Calibration completed\")\n            else:\n                response.success = False\n                response.message = \"Calibration failed：cannot control servos\"\n\n        except Exception as e:\n            response.success = False\n            response.message = f\"Calibration failed：{str(e)}\"\n            self.get_logger().error(f\"Calibration failed：{str(e)}\")\n\n        return response\n\n    def reset_to_home_callback(self):\n        \"\"\"Reset to home position\"\"\"\n        try:\n            self.get_logger().info(\"Resetting to home position...\")\n\n            # Define home position (adjust for your arm)\n            home_positions = {\n                1: 2048,  # joint1: 0deg\n                2: 2048,  # joint2: 0deg\n                3: 2048,  # joint3: 0deg\n                4: 2048,  # joint4: 0deg\n                5: 2048,  # joint5: 0deg\n                6: 2048,  # Gripper: Open\n            }\n\n            positions = {}\n            positions = self.servo_controller.read_position()\n            # Get servo ID and position together\n            for servo_id, position in positions.items():\n                rad_value = self.position_to_radians(position, servo_id - 1)\n                self.get_logger().info(\n                    f\"Servo {servo_id}: position {position}，radians {rad_value}\"\n                )\n\n            # with self.hw_lock:\n            result = self.servo_controller.set_all_positions(home_positions)\n\n            if result and self.servo_controller.execute_movement():\n                return True\n\n            else:\n                return False\n\n        except Exception as e:\n            # Print detailedStack trace\n            stack_trace = traceback.format_exc()\n            self.get_logger().error(f\"Reset failed：{str(e)}\\nStack trace:\\n{stack_trace}\")\n            return False\n\n    def cleanup(self):\n        \"\"\"Cleanup resources\"\"\"\n        if hasattr(self, \"servo_controller\") and self.servo_controller:\n            try:\n                # Disable servo torque\n                self.servo_controller.setup_torque(None, enable_value=0)\n                # Disconnect\n                self.servo_controller.disconnect()\n                self.get_logger().info(\"Disconnected from servo controller\")\n            except Exception as e:\n                self.get_logger().error(f\"Failed to disconnect from servos: {str(e)}\")\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = ArmDriverNode()\n\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        node.cleanup()\n        node.destroy_node()\n        rclpy.shutdown()\n\n\nif __name__ == \"__main__\":\n    main()\n"}\n{"instruction": "Write a ROS2 Python node named pose_requester.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "import rclpy\nfrom rclpy.action import ActionClient\nfrom rclpy.node import Node\nfrom rclpy.task import Future\nfrom rosidl_runtime_py import set_message_fields\nimport yaml\nfrom ament_index_python.packages import get_package_share_directory\n\nfrom moveit_msgs.action import MoveGroup\nfrom moveit_msgs.msg import Constraints, JointConstraint, MoveItErrorCodes\nfrom example_interfaces.msg import Empty\nfrom kalman_interfaces.msg import ArmPoseSelect, ArmGoalStatus, ArmState\nfrom collections import namedtuple\nfrom std_msgs.msg import UInt8\n\nMAX_DISTANCE_RAD = 0.35  # about 20\n\nPose = namedtuple(\n    \"Pose\",\n    [\n        \"name\",\n        \"path\",\n        \"joints_set\",\n        \"joints_checked\",\n        \"joints_reversed\",\n        \"safe_previous_poses\",\n    ],\n)\n\narm_config = get_package_share_directory(\"kalman_arm\")\n\nPREDEFINED_POSES: dict[int, Pose] = {}\ntry:\n    with open(f\"{arm_config}/config/predefined_poses.yaml\", \"r\") as f:\n        predefined_poses = yaml.safe_load(f)\n        MAX_DISTANCE_RAD = predefined_poses[\"max_distance_rad\"]\n        STOP_TRAJECTORY_TIMEOUT = predefined_poses[\"stop_trajectory_timeout\"]\n        for pose in predefined_poses[\"poses\"]:\n            PREDEFINED_POSES[int(pose[\"id\"])] = Pose(\n                pose[\"name\"],\n                f\"{arm_config}/{pose['path']}\",\n                pose[\"joints_set\"],\n                pose[\"joints_checked\"],\n                pose[\"joints_reversed\"],\n                pose[\"safe_previous_poses\"],\n            )\nexcept:\n    print(\"Error loading predefined poses configuration\")\n\n\nclass PoseRequestSender(Node):\n\n    def __init__(self):\n        super().__init__(\"pose_request_sender\")\n        self._action_client = ActionClient(self, MoveGroup, \"/arm_controllers/move_action\")\n\n        self.joints: dict[str, float] = {}\n        self._send_goal_future = None\n        self._timer = None\n        self._goal_handle = None\n        self._cancel_future: None | Future = None\n        self._goal_sent = False\n\n        self.joint_states_sub = self.create_subscription(\n            ArmState, \"/arm_state\", self.update_state, 10\n        )\n\n        self._change_control_pub = self.create_publisher(\n            UInt8, \"/change_control_type\", 10\n        )\n\n        self._execute_sub = self.create_subscription(\n            ArmPoseSelect,\n            \"/pose_request/execute\",\n            self.send_goal,\n            10,\n        )\n\n        self._status_pub = self.create_publisher(\n            ArmGoalStatus, \"/pose_request/status\", 10\n        )\n        self._status_pub.publish(ArmGoalStatus(status=ArmGoalStatus.IDLE))\n\n        self._keep_alive_sub = self.create_subscription(\n            Empty, \"/pose_request/keep_alive\", self.keep_alive, 10\n        )\n\n        self._abort_sub = self.create_subscription(\n            Empty, \"/pose_request/abort\", self.abort, 10\n        )\n\n    def update_state(self, msg: ArmState):\n        self.joints = {\n            \"arm_joint_1\": msg.joint_1,\n            \"arm_joint_2\": msg.joint_2,\n            \"arm_joint_3\": msg.joint_3,\n            \"arm_joint_4\": msg.joint_4,\n            \"arm_joint_5\": msg.joint_5,\n            \"arm_joint_6\": msg.joint_6,\n        }\n\n    def keep_alive(self, msg: Empty):\n        if self._timer:\n            self._timer.reset()\n\n    def abort(self, msg: Empty):\n        self._status_pub.publish(ArmGoalStatus(status=ArmGoalStatus.ABORT_RECEIVED))\n        self.timer_callback()\n\n    def send_goal(self, msg: ArmPoseSelect):\n        if msg.pose_id not in PREDEFINED_POSES:\n            self.get_logger().error(\"Invalid pose ID\")\n            self._status_pub.publish(ArmGoalStatus(status=ArmGoalStatus.INVALID_ID))\n            return\n\n        pose = PREDEFINED_POSES[msg.pose_id]\n        while len(self.joints.keys()) == 0:\n            rclpy.spin_once(self)\n\n        if self._goal_handle:\n            self.get_logger().info(\"Canceling previous goal\")\n            self._status_pub.publish(ArmGoalStatus(status=ArmGoalStatus.PREEMPTING))\n            self.timer_callback()\n            self._cancel_future.add_done_callback(\n                lambda x: self.publish_pose_goal(pose)\n            )\n        else:\n            self.publish_pose_goal(pose)\n\n    def publish_pose_goal(self, pose: Pose):\n        request = self.get_request_from_file(pose.path)\n        self.reset_not_set_joints(request, pose.joints_set)\n        self.reverse_joints(request, pose.joints_reversed)\n\n        if self.check_joints_too_far(\n            request, pose.joints_checked\n        ) or self.check_is_from_safe_previous_poses(pose):\n            self.get_logger().info(\"Sending pose goal...\")\n            self._status_pub.publish(ArmGoalStatus(status=ArmGoalStatus.GOAL_SENDING))\n            self.send_request(request)\n        else:\n            self.get_logger().warn(\"Too far away for pose...\")\n            self._status_pub.publish(ArmGoalStatus(status=ArmGoalStatus.TOO_FAR))\n\n    def get_request_from_file(self, filename: str) -> MoveGroup.Goal:\n        try:\n            predefined_pose = None\n            with open(filename, \"r\") as f:\n                predefined_pose = yaml.safe_load(f)\n\n            request = MoveGroup.Goal()\n\n            set_message_fields(request, predefined_pose)\n\n            return request\n\n        except FileNotFoundError:\n            self.get_logger().error(f\"Error loading predefined pose from {filename}\")\n            self._status_pub.publish(ArmGoalStatus(status=ArmGoalStatus.EXCEPTION))\n\n            return None\n\n    def reset_not_set_joints(self, request: MoveGroup.Goal, joints_to_set: list[str]):\n        goal_constraint: Constraints = request.request.goal_constraints[0]\n        joint_constraints: list[JointConstraint] = sorted(\n            goal_constraint.joint_constraints, key=lambda x: x.joint_name\n        )\n\n        for i in range(6):\n            if joint_constraints[i].joint_name not in joints_to_set:\n                joint_constraints[i].position = self.joints[\n                    joint_constraints[i].joint_name\n                ]\n\n        goal_constraint.joint_constraints = joint_constraints\n        request.request.goal_constraints = [goal_constraint]\n\n    def reverse_joints(self, request: MoveGroup.Goal, joints_to_reverse: list[str]):\n        goal_constraint: Constraints = request.request.goal_constraints[0]\n        joint_constraints: list[JointConstraint] = sorted(\n            goal_constraint.joint_constraints, key=lambda x: x.joint_name\n        )\n\n        for i in range(6):\n            if joint_constraints[i].joint_name in joints_to_reverse:\n                joint_constraints[i].position = -self.joints[\n                    joint_constraints[i].joint_name\n                ]\n\n        goal_constraint.joint_constraints = joint_constraints\n        request.request.goal_constraints = [goal_constraint]\n\n    def check_joints_too_far(\n        self, request: MoveGroup.Goal, joints_to_check: list[str]\n    ) -> bool:\n        goal_constraint: Constraints = request.request.goal_constraints[0]\n        joint_constraints: list[JointConstraint] = sorted(\n            goal_constraint.joint_constraints, key=lambda x: x.joint_name\n        )\n\n        close_enough = True\n        for i in range(6):\n            if (joint_constraints[i].joint_name in joints_to_check) and (\n                abs(\n                    self.joints[joint_constraints[i].joint_name]\n                    - joint_constraints[i].position\n                )\n                > MAX_DISTANCE_RAD\n            ):\n                close_enough = False\n\n        return close_enough\n\n    def check_is_from_safe_previous_poses(self, pose: Pose) -> bool:\n        for safe_pose in pose.safe_previous_poses:\n            if safe_pose in PREDEFINED_POSES:\n                safe_pose = PREDEFINED_POSES[safe_pose]\n                if self.check_joints_too_far(\n                    self.get_request_from_file(safe_pose.path), safe_pose.joints_checked\n                ):\n                    return True\n        return False\n\n    def send_request(self, request, check=True):\n\n        self._action_client.wait_for_server()\n\n        if self._goal_sent:\n            self.get_logger().info(\"Goal already being sent\")\n            return\n\n        self._goal_sent = True\n        self._send_goal_future = self._action_client.send_goal_async(request)\n        self._send_goal_future.add_done_callback(self.goal_response_callback)\n\n    def goal_response_callback(self, future):\n        self._goal_sent = False\n        goal_handle = future.result()\n        if not goal_handle.accepted:\n            self.get_logger().info(\"Goal rejected :(\")\n            self._status_pub.publish(ArmGoalStatus(status=ArmGoalStatus.GOAL_REJECTED))\n            return\n\n        self._goal_handle = goal_handle\n\n        self.get_logger().info(\"Goal accepted :)\")\n        self._status_pub.publish(ArmGoalStatus(status=ArmGoalStatus.GOAL_ACCEPTED))\n        self._change_control_pub.publish(UInt8(data=0))\n\n        # Start abort timer\n        if not self._timer:\n            self._timer = self.create_timer(\n                STOP_TRAJECTORY_TIMEOUT, self.timer_callback\n            )\n        else:\n            self._timer.reset()\n\n        self._result_handle = goal_handle.get_result_async()\n        self._result_handle.add_done_callback(self.get_result_callback)\n\n    def get_result_callback(self, future):\n        result: MoveGroup.Result = future.result().result\n        status: MoveItErrorCodes = result.error_code\n\n        if status.val == MoveItErrorCodes.SUCCESS:\n            self.get_logger().info(\"Goal succeeded!\")\n            self._status_pub.publish(ArmGoalStatus(status=ArmGoalStatus.SUCCESS))\n        else:\n            self.get_logger().warn(f\"Goal did not succeed with error code: {status}\")\n            self._status_pub.publish(ArmGoalStatus(status=ArmGoalStatus.FAILED))\n        self._goal_handle = None\n\n    def timer_callback(self):\n        self._change_control_pub.publish(UInt8(data=1))\n\n        # Cancel the timer\n        if self._timer:\n            self._timer.cancel()\n\n        if self._goal_handle:\n            self.get_logger().info(\"Canceling goal\")\n            self._status_pub.publish(ArmGoalStatus(status=ArmGoalStatus.CANCELLING))\n            # Cancel the goal\n            self._cancel_future = self._goal_handle.cancel_goal_async()\n            self._cancel_future.add_done_callback(self.cancel_done)\n\n    def cancel_done(self, future):\n        cancel_response = future.result()\n        if len(cancel_response.goals_canceling) > 0:\n            self.get_logger().info(\"Goal successfully canceled\")\n            self._status_pub.publish(ArmGoalStatus(status=ArmGoalStatus.CANCEL_SUCCESS))\n        else:\n            self.get_logger().info(\"Goal failed to cancel\")\n            self._status_pub.publish(ArmGoalStatus(status=ArmGoalStatus.CANCEL_FAILED))\n        self._goal_handle = None\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    action_client = PoseRequestSender()\n\n    rclpy.spin(action_client)\n\n\nif __name__ == \"__main__\":\n    main()\n"}\n{"instruction": "Write a ROS2 Python node named motion_planning_python_api_tutorial.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "#!/usr/bin/env python3\n\"\"\"\nA script to outline the fundamentals of the moveit_py motion planning API.\n\"\"\"\n\nimport time\n\n# generic ros libraries\nfrom ament_index_python import get_package_share_directory\nfrom moveit_configs_utils.moveit_configs_builder import MoveItConfigsBuilder\nimport rclpy\nfrom rclpy.logging import get_logger\n\n# moveit python library\nfrom moveit.core.robot_state import RobotState\nfrom moveit.planning import (\n    MoveItPy,\n    MultiPipelinePlanRequestParameters,\n)\n\n\ndef plan_and_execute(\n    robot,\n    planning_component,\n    logger,\n    single_plan_parameters=None,\n    multi_plan_parameters=None,\n    sleep_time=0.0,\n):\n    \"\"\"Helper function to plan and execute a motion.\"\"\"\n    # plan to goal\n    logger.info(\"Planning trajectory\")\n    if multi_plan_parameters is not None:\n        plan_result = planning_component.plan(\n            multi_plan_parameters=multi_plan_parameters\n        )\n    elif single_plan_parameters is not None:\n        plan_result = planning_component.plan(\n            single_plan_parameters=single_plan_parameters\n        )\n    else:\n        plan_result = planning_component.plan()\n\n    # execute the plan\n    if plan_result:\n        logger.info(\"成功规划\")\n        robot_trajectory = plan_result.trajectory\n        robot.execute(robot_trajectory, controllers=[])\n    else:\n        logger.error(\"规划失败\")\n\n    time.sleep(sleep_time)\n\n\ndef main():\n\n    ###################################################################\n    # MoveItPy Setup\n    ###################################################################\n    rclpy.init()\n    logger = get_logger(\"moveit_py.pose_goal\")\n\n    # instantiate MoveItPy instance and get planning component\n    aubo = MoveItPy(node_name=\"moveit_py\")\n    aubo_arm = aubo.get_planning_component(\"aubo_arm\")\n    logger.warn(\"MoveItPy instance created\")\n    time.sleep(3)\n\n    ###########################################################################\n    # Plan 1 - set states with predefined string\n    ###########################################################################\n\n    # # set plan start state using predefined state\n    # aubo_arm.set_start_state(configuration_name=\"zero\")\n    # aubo_arm.set_start_state_to_current_state()\n    # # set pose goal using predefined state\n    # aubo_arm.set_goal_state(configuration_name=\"home\")\n\n    # # plan to goal\n    # plan_and_execute(aubo, aubo_arm, logger, sleep_time=3.0)\n\n    # ###########################################################################\n    # # Plan 2 - set goal state with RobotState object\n    # ###########################################################################\n\n    # # instantiate a RobotState instance using the current robot model\n    # robot_model = aubo.get_robot_model()\n    # robot_state = RobotState(robot_model)\n\n    # # randomize the robot state\n    # robot_state.set_to_random_positions()\n\n    # # set plan start state to current state\n    # aubo_arm.set_start_state_to_current_state()\n\n    # # set goal state to the initialized robot state\n    # logger.info(\"Set goal state to the initialized robot state\")\n    # aubo_arm.set_goal_state(robot_state=robot_state)\n\n    # # plan to goal\n    # plan_and_execute(aubo, aubo_arm, logger, sleep_time=3.0)\n\n    # ###########################################################################\n    # # Plan 3 - set goal state with PoseStamped message\n    # ###########################################################################\n\n    # set plan start state to current state\n    aubo_arm.set_start_state_to_current_state()\n\n    # set pose goal with PoseStamped message\n    from geometry_msgs.msg import PoseStamped,Quaternion\n    #         /*\n\n    # 看物品: Translation: [0.655, -0.003, 0.677]\n    #              Quaternion [0.711, 0.703, 0.011, 0.016]\n\n    # 运货-前: Translation: [0.341, 0.109, 0.592]\n    #               Quaternion [0.704, 0.691, 0.118, 0.115]\n\n    # 运货-后: Translation: [-0.086, 0.029, 0.561]\n    #               Quaternion [-0.450, 0.878, 0.145, -0.078\n                \n    # 放置物品: Translation: [0.731, -0.025, 0.354]\n    #                 Quaternion [0.719, 0.673, 0.131, 0.115]\n\n    # */\n\n\n    pose_goal = PoseStamped()\n    pose_goal.header.frame_id = \"aubo_base\"\n    # pose_goal.pose.orientation.w = 1.0\n    # pose_goal.pose.position.x = 0.18\n    # pose_goal.pose.position.y = -0.15\n    # pose_goal.pose.position.z = 0.35\n    pose_goal.pose.orientation.x = 0.711\n    pose_goal.pose.orientation.y = 0.703\n    pose_goal.pose.orientation.z = 0.011\n    pose_goal.pose.orientation.w = 0.016\n    pose_goal.pose.position.x = 0.712912\n    pose_goal.pose.position.y = -0.007153\n    pose_goal.pose.position.z = 0.465334\n    aubo_arm.set_goal_state(pose_stamped_msg=pose_goal, pose_link=\"wrist3_Link\")\n\n    aubo_arm.set_start_state_to_current_state()\n        # plan to goal\n    plan_and_execute(aubo, aubo_arm, logger, sleep_time=5.0)\n\n\n    # from scipy.spatial.transform import Rotation\n    # pose_goal = PoseStamped()\n    # rot = Rotation.from_euler('xyz', [3.14, 0., 1.4], degrees=False)\n    # rot_quat = rot.as_quat()\n    # pose_goal.header.frame_id = \"aubo_base\"\n    # pose_goal.pose.orientation.x = rot_quat[0]\n    # pose_goal.pose.orientation.y = rot_quat[1]\n    # pose_goal.pose.orientation.z = rot_quat[2]\n    # pose_goal.pose.orientation.w = rot_quat[3]\n    # pose_goal.pose.position.x = -0.41\n    # pose_goal.pose.position.y = -0.153\n    # pose_goal.pose.position.z = 0.352\n    # aubo_arm.set_goal_state(pose_stamped_msg = pose_goal, pose_link = \"wrist3_Link\")\n\n    # multi_pipeline_plan_request_params = MultiPipelinePlanRequestParameters(\n    #         aubo, [\"ompl_rrtc\", \"pilz_lin\"]\n    #     )\n    # # plan to goal\n    # plan_and_execute(aubo, aubo_arm, logger, multi_plan_parameters=multi_pipeline_plan_request_params,\n    #                 sleep_time=3.0)\n\n\n\n    # ###########################################################################\n    # # Plan 4 - set goal state with constraints\n    # ###########################################################################\n    '''\n    robot_model = aubo.get_robot_model()\n    robot_state = RobotState(robot_model)\n    # set plan start state to current state\n    aubo_arm.set_start_state_to_current_state()\n\n    # set constraints message\n    from moveit.core.kinematic_constraints import construct_joint_constraint\n\n    # 初始姿态\n    first_values = {\n        \"foreArm_joint\": -2.4108334358394976,\n        \"wrist1_joint\": 0.19090251921361948,\n        \"upperArm_joint\": -1.034534295735007,\n        \"wrist2_joint\": -1.5654776861404676,\n        \"wrist3_joint\": -0.10093312750890894,\n        \"shoulder_joint\": 1.5002197993246449,\n    }\n    # 抓取前姿态\n    grasp_values = {\n        \"foreArm_joint\": -0.9656377251059474,\n        \"wrist1_joint\": 0.26844829995519176,\n        \"upperArm_joint\": 0.33847095519177534,\n        \"wrist2_joint\": -1.5632255169254201,\n        \"wrist3_joint\": -0.30126247877899875,\n        \"shoulder_joint\": 1.2959143056618647,\n    }\n    # 抓取后（前）姿态\n    front_values = {\n        \"foreArm_joint\": -1.9574101499793466,\n        \"wrist1_joint\": 0.2739686821516851,\n        \"upperArm_joint\": -0.6628273384951079,\n        \"wrist2_joint\": -1.55778949937379,\n        \"wrist3_joint\": -0.05559996899298767,\n        \"shoulder_joint\": 1.5361444659242836,\n    }\n    # 抓取后（后）姿态\n    back_values = {\n        \"foreArm_joint\": 2.1753790480819526,\n        \"wrist1_joint\": -1.7941755662528698,\n        \"upperArm_joint\": 0.953665281591426,\n        \"wrist2_joint\": -1.6257140425729024,\n        \"wrist3_joint\": -3.079727692708692,\n        \"shoulder_joint\": 1.5436565873451593,\n    }\n    # 放置物体姿态\n    set_values = {\n        \"foreArm_joint\": -0.965094856956392,\n        \"wrist1_joint\": -0.35666070622992196,\n        \"upperArm_joint\": 0.9411279617591244,\n        \"wrist2_joint\": -1.624441236843877,\n        \"wrist3_joint\": -0.18545916560591436,\n        \"shoulder_joint\": 1.3522111999819844,\n    }\n    \n    for i in [first_values, grasp_values, front_values, back_values, set_values]:\n        \n        robot_state.joint_positions = i\n        joint_constraint = construct_joint_constraint(\n            robot_state=robot_state,\n            joint_model_group=aubo.get_robot_model().get_joint_model_group(\"aubo_arm\"),\n        )\n        aubo_arm.set_goal_state(motion_plan_constraints=[joint_constraint])\n\n        # plan to goal\n        plan_and_execute(aubo, aubo_arm, logger, sleep_time=3.0)\n    '''\n    # ###########################################################################\n    # # Plan 5 - Planning with Multiple Pipelines simultaneously\n    # ###########################################################################\n\n    # # set plan start state to current state\n    # aubo_arm.set_start_state_to_current_state()\n\n    # # set pose goal with PoseStamped message\n    # aubo_arm.set_goal_state(configuration_name=\"ready\")\n\n    # # initialise multi-pipeline plan request parameters\n\n    # multi_pipeline_plan_request_params = MultiPipelinePlanRequestParameters(\n    #     aubo, [\"ompl_rrtc\", \"pilz_lin\"]\n    # )\n\n    # # plan to goal\n    # plan_and_execute(\n    #     aubo,\n    #     aubo_arm,\n    #     logger,\n    #     multi_plan_parameters=multi_pipeline_plan_request_params,\n    #     sleep_time=3.0,\n    # )\n\n\nif __name__ == \"__main__\":\n    main()\n"}\n{"instruction": "Write a ROS2 Python node named aruco_pose_transformer.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "#!/usr/bin/env python\nimport rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import Pose\nfrom geometry_msgs.msg import PoseStamped\nimport tf2_ros\nimport tf2_geometry_msgs\n\nclass PoseTransformer(Node):\n\n    def __init__(self):\n        super().__init__('aruco_pose_transformer')\n        self.publisher_ = self.create_publisher(Pose, 'lbr/moveit_goal', 10)\n        self.subscription = self.create_subscription(\n            PoseStamped,\n            'aruco_single/pose',\n            self.listener_callback,\n            10)\n        self.tf_buffer = tf2_ros.Buffer()\n        self.tf_listener = tf2_ros.TransformListener(self.tf_buffer, self)\n\n    def listener_callback(self, msg):\n        pose = Pose()\n        pose.position = msg.pose.position\n        pose.orientation = msg.pose.orientation\n        # self.publisher_.publish(pose)\n        # try:\n        frames = self.tf_buffer.all_frames_as_string()\n        print(frames)\n        # transform = self.tf_buffer.lookup_transform('lbr/link_0', 'camera_depth_optical_frame', rclpy.time.Time())\n        transform = self.tf_buffer.lookup_transform('lbr/link_0', msg.header.frame_id, rclpy.time.Time())\n        print(\"transofmr\", transform)\n        transformed_pose = tf2_geometry_msgs.do_transform_pose(pose, transform)\n        print(\"transformed_pose\", transformed_pose)\n        transformed_pose.orientation.x = 0.0\n        transformed_pose.orientation.y = 1.0\n        transformed_pose.orientation.z = 0.0\n        transformed_pose.orientation.w = 0.0\n\n\n        print(\"after\", transformed_pose)\n        # Convert PoseStamped to Pose before publishing\n        inp = input(\"publish?\")\n        if inp == 'Y' or inp=='y':\n            self.publisher_.publish(transformed_pose)\n\n        \n        # except (tf2_ros.LookupException, tf2_ros.ConnectivityException, tf2_ros.ExtrapolationException):\n        #     self.get_logger().info('Transform error')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    pose_transformer = PoseTransformer()\n    rclpy.spin(pose_transformer)\n    pose_transformer.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n# #!/usr/bin/env python\n# import rclpy\n# from rclpy.node import Node\n# from sensor_msgs.msg import JointState\n\n# class JointStatePublisher(Node):\n\n#     def __init__(self):\n#         super().__init__('playground_joint_state_publisher')\n#         self.publisher_ = self.create_publisher(JointState, 'joint_states', 1)\n#         self.subscription = self.create_subscription(\n#             JointState,\n#             '/lbr/joint_states',\n#             self.listener_callback,\n#             1)\n#         self.subscription  # prevent unused variable warning\n\n#     def listener_callback(self, msg):\n#         self.publisher_.publish(msg)\n\n# def main(args=None):\n#     rclpy.init(args=args)\n#     joint_state_publisher = JointStatePublisher()\n#     rclpy.spin(joint_state_publisher)\n#     joint_state_publisher.destroy_node()\n#     rclpy.shutdown()\n\n# if __name__ == '__main__':\n#     main()\n# import rclpy\n# from rclpy.node import Node\n# from geometry_msgs.msg import Pose\n\n# class GoalPublisher(Node):\n\n#     def __init__(self):\n#         super().__init__('goal_publisher')\n#         self.publisher_ = self.create_publisher(Pose, 'lbr/moveit_goal', 10)\n#         msg = Pose()\n#         msg.position.x = -0.4\n#         msg.position.y = -0.08\n#         msg.position.z = 0.4\n#         msg.orientation.x = 0.9063\n#         msg.orientation.y = 0.0\n#         msg.orientation.z = 0.0\n#         msg.orientation.w = 0.4226\n#         self.publisher_.publish(msg)\n\n# def main(args=None):\n#     rclpy.init(args=args)\n#     goal_publisher = GoalPublisher()\n#     # rclpy.spin(goal_publisher)\n#     goal_publisher.destroy_node()\n#     rclpy.shutdown()\n\n# if __name__ == '__main__':\n#     main()"}\n{"instruction": "Write a ROS2 Python node named data_collection_keyboard.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "#!/usr/bin/python3\n\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import Joy, Image\nfrom geometry_msgs.msg import TwistStamped\nfrom trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint\nimport threading\nimport copy\nimport time\nimport cv2\nimport os\nfrom tf2_msgs.msg import TFMessage\nfrom scipy.spatial.transform import Rotation as R\nimport numpy as np\nfrom cv_bridge import CvBridge\nfrom math import sin, cos, pi\nimport pandas as pd\nimport pyarrow as pa\nimport pyarrow.parquet as pq\nfrom pynput import keyboard\n\nbridge = CvBridge()\n\nrecord_data = False\ntool_pose_xy = [0.0, 0.0] # tool(end effector) pose\ntbar_pose_xyw = [0.0, 0.0, 0.0]\nvid_H = 360\nvid_W = 640\nwrist_camera_image = np.zeros((vid_H, vid_W, 3), np.uint8)\ntop_camera_image = np.zeros((vid_H, vid_W, 3), np.uint8)\naction = np.array([0.0, 0.0], float)\n\n\nclass Get_Poses_Subscriber(Node):\n\n    def __init__(self):\n        super().__init__('get_modelstate')\n        self.subscription = self.create_subscription(\n            TFMessage,\n            '/isaac_tf',\n            self.listener_callback,\n            10)\n        self.subscription\n\n        self.euler_angles = np.array([0.0, 0.0, 0.0], float)\n\n    def listener_callback(self, data):\n        global tool_pose_xy, tbar_pose_xyw\n\n        # 0:tool\n        tool_pose = data.transforms[0].transform.translation\n        tool_pose_xy[0] = tool_pose.y\n        tool_pose_xy[1] = tool_pose.x\n\n        # 1:tbar\n        tbar_translation  = data.transforms[1].transform.translation       \n        tbar_rotation = data.transforms[1].transform.rotation \n        tbar_pose_xyw[0] = tbar_translation.y\n        tbar_pose_xyw[1] = tbar_translation.x\n        self.euler_angles[:] = R.from_quat([tbar_rotation.x, tbar_rotation.y, tbar_rotation.z, tbar_rotation.w]).as_euler('xyz', degrees=False)\n        tbar_pose_xyw[2] = self.euler_angles[2]\n\nclass Robot_Keyboard_Controller(Node):\n\n    def __init__(self):\n        super().__init__('robot_keyboard_controller')\n        \n        # Robot control publishers\n        # Send Twist commands to MoveIt Servo for real-time control\n        self.twist_pub = self.create_publisher(\n            TwistStamped, \n            '/servo_node/delta_twist_cmds', \n            10\n        )\n        \n        # Send Joint Trajectory commands for position control (reset to home)\n        self.joint_trajectory_pub = self.create_publisher(\n            JointTrajectory,\n            '/arm_controller/joint_trajectory',\n            10\n        )\n        \n        # Keyboard state tracking\n        self.keys_pressed = set()\n        self.push_time = 0\n        self.prev_push_time = 0\n        \n        # Start keyboard listener in separate thread\n        self.listener = keyboard.Listener(\n            on_press=self.on_key_press,\n            on_release=self.on_key_release\n        )\n        self.listener.start()\n        \n        # Timer to update robot commands and action values\n        self.timer = self.create_timer(0.1, self.update_robot_commands)  # 10Hz control rate (dt = 0.1 s)\n        \n        print(\"🤖 Robot Keyboard Control Started!\")\n        print(\"Controls:\")\n        print(\"  W/S: Move Forward/Backward\")\n        print(\"  A/D: Move Left/Right\") \n        print(\"  Q/E: Move Up/Down\")\n        print(\"  R: Reset Robot to Home Position\")\n        print(\"  Space: Start/Stop Recording\")\n        print(\"  ESC: Exit\")\n        print(\"  Note: Robot should now move in Isaac Sim!\")\n        \n        # Auto-reset robot to home position when script starts\n        self.initial_reset_done = False\n        self.create_timer(1.0, self.initial_reset_to_home)\n\n    def on_key_press(self, key):\n        global record_data\n        \n        try:\n            # Handle character keys\n            if hasattr(key, 'char') and key.char:\n                # Special handling for reset key\n                if key.char.lower() == 'r':\n                    print(\"\\n🔧 R key detected! Calling reset function...\")\n                    self.reset_robot_to_home()\n                    return\n                self.keys_pressed.add(key.char.lower())\n                \n            # Handle special keys\n            elif key == keyboard.Key.space:\n                self.push_time = time.time()\n                dif = self.push_time - self.prev_push_time\n                if(dif > 1):  # Debounce - same logic as joystick\n                    if(record_data == False):\n                        record_data = True\n                        print('\\033[32m'+'🔴 START RECORDING'+'\\033[0m')\n                    elif(record_data):\n                        record_data = False\n                        print('\\033[31m'+'⏹️  END RECORDING'+'\\033[0m')\n                self.prev_push_time = self.push_time\n                \n            elif key == keyboard.Key.esc:\n                print(\"\\n👋 Exiting robot keyboard controller...\")\n                rclpy.shutdown()\n                return False\n                \n        except AttributeError:\n            # Handle special keys that don't have .char\n            pass\n\n    def on_key_release(self, key):\n        try:\n            if hasattr(key, 'char') and key.char:\n                self.keys_pressed.discard(key.char.lower())\n        except AttributeError:\n            pass\n\n    def update_robot_commands(self):\n        global action\n        \n        # Create Twist message for robot control\n        twist_msg = TwistStamped()\n        twist_msg.header.stamp = self.get_clock().now().to_msg()\n        twist_msg.header.frame_id = \"base_link\"\n        \n        # Reset action values\n        action[0] = 0.0  # X-axis (left/right)\n        action[1] = 0.0  # Y-axis (forward/backward)\n        \n        # Movement speed for robot (in m/s and rad/s)\n        linear_speed = 0.4  # 35cm/s - slightly faster\n        vertical_speed = 0.20  # 18cm/s for up/down - slightly faster\n        \n        # Update robot commands and action based on currently pressed keys\n        if 'w' in self.keys_pressed:\n            twist_msg.twist.linear.x = linear_speed  # Forward\n            action[1] = 1.0\n        if 's' in self.keys_pressed:\n            twist_msg.twist.linear.x = -linear_speed  # Backward\n            action[1] = -1.0\n        if 'a' in self.keys_pressed:\n            twist_msg.twist.linear.y = linear_speed  # Left\n            action[0] = -1.0\n        if 'd' in self.keys_pressed:\n            twist_msg.twist.linear.y = -linear_speed  # Right\n            action[0] = 1.0\n        if 'q' in self.keys_pressed:\n            twist_msg.twist.linear.z = vertical_speed  # Up\n        if 'e' in self.keys_pressed:\n            twist_msg.twist.linear.z = -vertical_speed  # Down\n            \n        # Publish the twist command to move the robot\n        self.twist_pub.publish(twist_msg)\n        \n        # Display current status only when not recording (to avoid cluttering recording output)\n        global record_data\n        if self.keys_pressed and not record_data:\n            keys_str = ', '.join(sorted(self.keys_pressed))\n            print(f\"\\r🎮 Keys: {keys_str:<10} | Action: [{action[0]:+.1f}, {action[1]:+.1f}] | Robot Moving!\", end=\"\", flush=True)\n\n    def reset_robot_to_home(self):\n        \"\"\"Reset robot to home position by temporarily restarting arm controller\"\"\"\n        print(\"\\n🏠 Resetting robot to home position...\")\n        \n        # Clear any pressed keys to stop current servo movements\n        self.keys_pressed.clear()\n        \n        import subprocess\n        import time\n        \n        try:\n            print(\"🔄 Restarting arm controller to bypass servo...\")\n            \n            # Step 1: Deactivate arm controller\n            result = subprocess.run([\n                'ros2', 'control', 'switch_controllers', \n                '--deactivate', 'arm_controller'\n            ], capture_output=True, text=True, timeout=5)\n            \n            if result.returncode == 0:\n                print(\"✅ Arm controller deactivated\")\n                time.sleep(0.5)  # Wait a bit\n                \n                # Step 2: Send joint trajectory command\n                traj_msg = JointTrajectory()\n                traj_msg.header.stamp = self.get_clock().now().to_msg()\n                traj_msg.joint_names = [\n                    'shoulder_pan_joint',\n                    'shoulder_lift_joint', \n                    'elbow_joint',\n                    'wrist_1_joint',\n                    'wrist_2_joint',\n                    'wrist_3_joint'\n                ]\n                \n                # Create trajectory point for home position\n                point = JointTrajectoryPoint()\n                point.positions = [0.0, -1.57, 0.0, -1.57, 0.0, 0.0]  # Home position for UR5\n                point.velocities = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n                point.time_from_start.sec = 3  # Take 3 seconds to reach home\n                \n                traj_msg.points = [point]\n                \n                # Step 3: Reactivate arm controller\n                result2 = subprocess.run([\n                    'ros2', 'control', 'switch_controllers',\n                    '--activate', 'arm_controller'\n                ], capture_output=True, text=True, timeout=5)\n                \n                if result2.returncode == 0:\n                    print(\"✅ Arm controller reactivated\")\n                    time.sleep(0.2)  # Wait a bit more\n                    \n                    # Step 4: Now send joint trajectory (should work now)\n                    for i in range(3):\n                        self.joint_trajectory_pub.publish(traj_msg)\n                        time.sleep(0.1)\n                    \n                    print(\"✅ Robot reset command sent! Moving to home position...\")\n                    print(\"⏳ Please wait 3 seconds for movement to complete...\")\n                else:\n                    print(\"❌ Failed to reactivate arm controller\")\n            else:\n                print(\"❌ Failed to deactivate arm controller\")\n                \n        except subprocess.TimeoutExpired:\n            print(\"❌ Controller switch timeout\")\n        except Exception as e:\n            print(f\"❌ Controller switch error: {e}\")\n\n    def initial_reset_to_home(self):\n        \"\"\"Reset robot to home position when script starts (runs once)\"\"\"\n        if self.initial_reset_done:\n            return\n            \n        print(\"\\n🏠 Initializing robot to home position...\")\n        \n        # Create joint trajectory message\n        traj_msg = JointTrajectory()\n        traj_msg.header.stamp = self.get_clock().now().to_msg()\n        traj_msg.joint_names = [\n            'shoulder_pan_joint',\n            'shoulder_lift_joint', \n            'elbow_joint',\n            'wrist_1_joint',\n            'wrist_2_joint',\n            'wrist_3_joint'\n        ]\n        \n        # Create trajectory point for home position\n        point = JointTrajectoryPoint()\n        point.positions = [0.0, -1.57, 0.0, -1.57, 0.0, 0.0]  # Home position for UR5\n        point.velocities = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n        point.time_from_start.sec = 2  # Quick reset at startup\n        \n        traj_msg.points = [point]\n        \n        # Publish the trajectory\n        self.joint_trajectory_pub.publish(traj_msg)\n        print(\"✅ Robot initialized to home position!\")\n        \n        # Mark as done so it doesn't run again\n        self.initial_reset_done = True\n\nclass Wrist_Camera_Subscriber(Node):\n\n    def __init__(self):\n        super().__init__('wrist_camera_subscriber')\n        self.subscription = self.create_subscription(\n            Image,\n            '/rgb_wrist',\n            self.camera_callback,\n            10)\n        self.subscription \n\n    def camera_callback(self, data):\n        global wrist_camera_image\n        wrist_camera_image = cv2.resize(bridge.imgmsg_to_cv2(data, \"bgr8\"), (vid_W, vid_H), cv2.INTER_LINEAR)\n\nclass Top_Camera_Subscriber(Node):\n\n    def __init__(self):\n        super().__init__('top_camera_subscriber')\n        self.subscription = self.create_subscription(\n            Image,\n            '/rgb_top',\n            self.camera_callback,\n            10)\n        self.subscription \n\n    def camera_callback(self, data):\n        global top_camera_image\n        top_camera_image = cv2.resize(bridge.imgmsg_to_cv2(data, \"bgr8\"), (vid_W, vid_H), cv2.INTER_LINEAR)\n\nclass Data_Recorder(Node):\n\n    def __init__(self):\n        super().__init__('Data_Recorder')\n        self.Hz = 10 # bridge data frequency (dt = 0.1 s)\n        self.prev_ee_pose = np.array([0, 0, 0], float)\n        self.timer = self.create_timer(1/self.Hz, self.timer_callback)\n        self.start_recording = False\n        self.data_recorded = False\n\n        #### log files for multiple runs are NOT overwritten\n        base_dir = os.environ[\"HOME\"] + \"/ur5_simulation/src/data_collection/scripts/my_pusht/\"\n        self.log_dir = base_dir + \"data/chunk_000/\"\n        if not os.path.exists(self.log_dir):\n            os.makedirs(self.log_dir)\n\n        base_vid_dir = base_dir + 'videos/chunk_000/observation.images.'\n        self.wrist_vid_dir = base_vid_dir + 'wrist/'\n        if not os.path.exists(self.wrist_vid_dir):\n            os.makedirs(self.wrist_vid_dir)\n\n        self.top_vid_dir = base_vid_dir + 'top/'\n        if not os.path.exists(self.top_vid_dir):\n            os.makedirs(self.top_vid_dir)\n\n        self.state_vid_dir = base_vid_dir + 'state/'\n        if not os.path.exists(self.state_vid_dir):\n            os.makedirs(self.state_vid_dir)\n\n        # image of a T shape on the table\n        self.initial_image = cv2.imread(os.environ['HOME'] + \"/ur5_simulation/images/stand_top_plane.png\")\n        self.initial_image = cv2.rotate(self.initial_image, cv2.ROTATE_90_COUNTERCLOCKWISE)\n \n        # for reward calculation\n        self.Tbar_region = np.zeros((self.initial_image.shape[0], self.initial_image.shape[1]), np.uint8)\n\n        # filled image of T shape on the table\n        self.T_image = cv2.imread(os.environ['HOME'] + \"/ur5_simulation/images/stand_top_plane_filled.png\")\n        self.T_image = cv2.rotate(self.T_image, cv2.ROTATE_90_COUNTERCLOCKWISE)\n\n        img_gray = cv2.cvtColor(self.T_image, cv2.COLOR_BGR2GRAY)\n        thr, img_th = cv2.threshold(img_gray, 100, 255, cv2.THRESH_BINARY)\n        self.blue_region = cv2.bitwise_not(img_th)\n        self.blue_region_sum = cv2.countNonZero(self.blue_region)\n        \n        self.pub_img = self.create_publisher(Image, '/pushT_image', 10)\n        self.tool_radius = 10 # millimeters\n        self.scale = 1.639344 # mm/pix\n        self.C_W = 182 # pix\n        self.C_H = 152 # pix\n        self.OBL1 = int(150/self.scale)\n        self.OBL2 = int(120/self.scale)\n        self.OBW = int(30/self.scale)\n        # radius of the tool\n        self.radius = int(10/self.scale)\n\n        self.df = pd.DataFrame(columns=['observation.state', 'action', 'episode_index', 'frame_index', 'timestamp', 'next.reward', 'next.done', 'next.success', 'index', 'task_index'])\n        self.index = 296 # 1 + the last index in the last episode\n        self.episode_index = 1 # 1 + the last episode number\n        self.frame_index = 0\n        self.time_stamp = 0.0\n        self.success = False\n        self.done = False\n        self.column_index = 0\n        self.prev_sum = 0.0\n\n        self.wrist_camera_array = []\n        self.top_camera_array = []\n        self.state_image_array = []\n\n    def timer_callback(self):\n        global tool_pose_xy, tbar_pose_xyw, action, wrist_camera_image, top_camera_image, record_data\n        \n        image = copy.copy(self.initial_image)\n        self.Tbar_region[:] = 0\n\n        x = int((tool_pose_xy[0]*1000 + 300)/self.scale)\n        y = int((tool_pose_xy[1]*1000 - 320)/self.scale)\n\n        cv2.circle(image, center=(x, y), radius=self.radius, color=(100, 100, 100), thickness=cv2.FILLED)        \n        \n        # horizontal part of T\n        x1 = tbar_pose_xyw[0]\n        y1 = tbar_pose_xyw[1]\n        th1 = -tbar_pose_xyw[2] - pi/2\n        dx1 = -self.OBW/2*cos(th1 - pi/2)\n        dy1 = -self.OBW/2*sin(th1 - pi/2)\n        self.tbar1_ob = [[int(cos(th1)*self.OBL1/2     - sin(th1)*self.OBW/2   + dx1 + self.C_W + 1000*x1/self.scale), int(sin(th1)*self.OBL1/2    + cos(th1)*self.OBW/2   + dy1 + (1000*y1-320)/self.scale)],\n                          [int(cos(th1)*self.OBL1/2    - sin(th1)*(-self.OBW/2)+ dx1 + self.C_W + 1000*x1/self.scale), int(sin(th1)*self.OBL1/2    + cos(th1)*(-self.OBW/2)+ dy1 + (1000*y1-320)/self.scale)],\n                          [int(cos(th1)*(-self.OBL1/2) - sin(th1)*(-self.OBW/2)+ dx1 + self.C_W + 1000*x1/self.scale), int(sin(th1)*(-self.OBL1/2) + cos(th1)*(-self.OBW/2)+ dy1 + (1000*y1-320)/self.scale)],\n                          [int(cos(th1)*(-self.OBL1/2) - sin(th1)*self.OBW/2   + dx1 + self.C_W + 1000*x1/self.scale), int(sin(th1)*(-self.OBL1/2) + cos(th1)*self.OBW/2   + dy1 + (1000*y1-320)/self.scale)]]  \n        pts1_ob = np.array(self.tbar1_ob, np.int32)\n        cv2.fillPoly(image, [pts1_ob], (0, 0, 180))\n        cv2.fillPoly(self.Tbar_region, [pts1_ob], 255)\n        \n        #vertical part of T\n        th2 = -tbar_pose_xyw[2] - pi\n        dx2 = self.OBL2/2*cos(th2)\n        dy2 = self.OBL2/2*sin(th2)\n        self.tbar2_ob = [[int(cos(th2)*self.OBL2/2    - sin(th2)*self.OBW/2    + dx2 + self.C_W + 1000*x1/self.scale), int(sin(th2)*self.OBL2/2    + cos(th2)*self.OBW/2   + dy2 + (1000*y1-320)/self.scale)],\n                          [int(cos(th2)*self.OBL2/2    - sin(th2)*(-self.OBW/2)+ dx2 + self.C_W + 1000*x1/self.scale), int(sin(th2)*self.OBL2/2    + cos(th2)*(-self.OBW/2)+ dy2 + (1000*y1-320)/self.scale)],\n                          [int(cos(th2)*(-self.OBL2/2) - sin(th2)*(-self.OBW/2)+ dx2 + self.C_W + 1000*x1/self.scale), int(sin(th2)*(-self.OBL2/2) + cos(th2)*(-self.OBW/2)+ dy2 + (1000*y1-320)/self.scale)],\n                          [int(cos(th2)*(-self.OBL2/2) - sin(th2)*self.OBW/2   + dx2 + self.C_W + 1000*x1/self.scale), int(sin(th2)*(-self.OBL2/2) + cos(th2)*self.OBW/2   + dy2 + (1000*y1-320)/self.scale)]]  \n        pts2_ob = np.array(self.tbar2_ob, np.int32)\n        cv2.fillPoly(image, [pts2_ob], (0, 0, 180))\n        cv2.fillPoly(self.Tbar_region, [pts2_ob], 255)\n\n        common_part = cv2.bitwise_and(self.blue_region, self.Tbar_region)\n        common_part_sum = cv2.countNonZero(common_part)\n        sum = common_part_sum/self.blue_region_sum\n        sum_dif = sum - self.prev_sum\n        self.prev_sum = sum\n\n        cv2.circle(image, center=(int(self.C_W + 1000*x1/self.scale), int((1000*y1-320)/self.scale)), radius=2, color=(0, 200, 0), thickness=cv2.FILLED)  \n\n        img_msg = bridge.cv2_to_imgmsg(image)  \n        self.pub_img.publish(img_msg) \n\n        if record_data:\n            print('\\033[32m'+f'RECORDING episode:{self.episode_index}, index:{self.index} sum:{sum}'+'\\033[0m')\n\n            if sum >= 0.90:\n                self.success = True\n                self.done = True\n                record_data = False\n                print('\\033[31m'+'SUCCESS!'+f': {sum}'+'\\033[0m')\n            else:\n                self.success = False\n\n            self.df.loc[self.column_index] = [copy.copy(tool_pose_xy), copy.copy(action), self.episode_index, self.frame_index, self.time_stamp, sum, self.done, self.success, self.index, 0]\n            self.column_index += 1\n            self.frame_index += 1\n            self.time_stamp += 1/self.Hz\n            self.index += 1\n\n            self.start_recording = True\n\n            self.wrist_camera_array.append(wrist_camera_image)\n            self.top_camera_array.append(top_camera_image)\n            self.state_image_array.append(image)\n\n        else:\n            if(self.start_recording and self.data_recorded == False):\n                print('\\033[31m'+'WRITING A PARQUET FILE'+'\\033[0m')\n\n                if self.episode_index <= 9:\n                    data_file_name = 'episode_00000' + str(self.episode_index) + '.parquet'\n                    video_file_name = 'episode_00000' + str(self.episode_index) + '.mp4'\n                elif 9 < self.episode_index <= 99:\n                    data_file_name = 'episode_0000' + str(self.episode_index) + '.parquet'\n                    video_file_name = 'episode_0000' + str(self.episode_index) + '.mp4'\n                elif 99 < self.episode_index <= 999:\n                    data_file_name = 'episode_000' + str(self.episode_index) + '.parquet'\n                    video_file_name = 'episode_000' + str(self.episode_index) + '.mp4'\n                elif 999 < self.episode_index <= 9999:\n                    data_file_name = 'episode_00' + str(self.episode_index) + '.parquet'\n                    video_file_name = 'episode_00' + str(self.episode_index) + '.mp4'\n                else:\n                    data_file_name = 'episode_0' + str(self.episode_index) + '.parquet'\n                    video_file_name = 'episode_0' + str(self.episode_index) + '.mp4'\n\n                table = pa.Table.from_pandas(self.df)\n                pq.write_table(table, self.log_dir + data_file_name)\n                print(\"The parquet file is generated!\")\n\n                \n                fourcc = cv2.VideoWriter_fourcc('m', 'p', '4', 'v')\n                out1 = cv2.VideoWriter(self.wrist_vid_dir + video_file_name, fourcc, self.Hz, (vid_W, vid_H))\n                for frame1 in self.wrist_camera_array:\n                    out1.write(frame1)\n                out1.release()\n                print(\"The wrist video is generated!\")\n                out2 = cv2.VideoWriter(self.top_vid_dir + video_file_name, fourcc, self.Hz, (vid_W, vid_H))\n                for frame2 in self.top_camera_array:\n                    out2.write(frame2)\n                out2.release()\n                print(\"The top video is generated!\")\n                out3 = cv2.VideoWriter(self.state_vid_dir + video_file_name, fourcc, self.Hz, (self.initial_image.shape[1], self.initial_image.shape[0]))\n                for frame3 in self.state_image_array:\n                    out3.write(frame3)\n                out3.release()\n                print(\"The state video is generated!\")\n\n                # Reset for next episode - exactly like original\n                self.data_recorded = True\n                self.episode_index += 1  # Increment episode for next recording\n                self.frame_index = 0\n                self.time_stamp = 0.0\n                self.column_index = 0\n                self.start_recording = False\n                self.success = False\n                self.done = False\n                \n                # Clear arrays for next episode\n                self.wrist_camera_array.clear()\n                self.top_camera_array.clear()\n                self.state_image_array.clear()\n                \n                # Reset dataframe for next episode\n                self.df = self.df.iloc[0:0]  # Clear dataframe\n                \n                # AUTO RESET ROBOT TO HOME POSITION after episode completion\n                self.reset_robot_after_episode()\n                \n                print(f\"🔄 Ready for episode {self.episode_index}\")\n                self.data_recorded = False\n\n    def reset_robot_after_episode(self):\n        \"\"\"Reset robot to home position after episode completion\"\"\"\n        print(\"🤖 Episode completed! Resetting robot to home position...\")\n        \n        # Create joint trajectory message  \n        traj_msg = JointTrajectory()\n        traj_msg.header.stamp = self.get_clock().now().to_msg()\n        traj_msg.joint_names = [\n            'shoulder_pan_joint',\n            'shoulder_lift_joint', \n            'elbow_joint',\n            'wrist_1_joint',\n            'wrist_2_joint',\n            'wrist_3_joint'\n        ]\n        \n        # Create trajectory point for home position\n        point = JointTrajectoryPoint()\n        point.positions = [0.0, -1.57, 0.0, -1.57, 0.0, 0.0]  # Home position for UR5\n        point.velocities = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n        point.time_from_start.sec = 4  # Take 4 seconds to reach home (a bit slower after episode)\n        \n        traj_msg.points = [point]\n        \n        # Publish the trajectory\n        joint_trajectory_pub = self.create_publisher(JointTrajectory, '/arm_controller/joint_trajectory', 10)\n        joint_trajectory_pub.publish(traj_msg)\n        print(\"✅ Robot returning to home position for next episode!\")\n\n\nif __name__ == '__main__':\n    rclpy.init(args=None)\n\n    get_poses_subscriber = Get_Poses_Subscriber()\n    robot_keyboard_controller = Robot_Keyboard_Controller()  # NEW: Robot control!\n    wrist_camera_subscriber = Wrist_Camera_Subscriber()\n    top_camera_subscriber = Top_Camera_Subscriber()\n    data_recorder = Data_Recorder()\n\n    executor = rclpy.executors.MultiThreadedExecutor()\n    executor.add_node(get_poses_subscriber)\n    executor.add_node(robot_keyboard_controller)  # NEW: Robot control!\n    executor.add_node(wrist_camera_subscriber)\n    executor.add_node(top_camera_subscriber)\n    executor.add_node(data_recorder)\n\n    executor_thread = threading.Thread(target=executor.spin, daemon=True)\n    executor_thread.start()\n\n    rate = get_poses_subscriber.create_rate(2)\n    try:\n        while rclpy.ok():\n            rate.sleep()\n    except KeyboardInterrupt:\n        pass\n\n    rclpy.shutdown()\n    executor_thread.join() "}\n{"instruction": "Write a ROS2 Python node named demo_peg_in_hole.py that uses rclpy and MoveIt2 for robotic manipulation.", "response": "#!/usr/bin/env python3\n\"\"\"\nNote: !! This file does not contain the full solution. Your task is to implement the missing parts. !!\n\nDemo script for peg-in-hole task sequence. Compatible with fake, simulated and real robot.\n- ros2 run phantomx_pincher_demos demo_peg_in_hole.py\n\nThis demo is used as a part of Gazebo demo `demo_rover_peg_in_hole.launch.py`.\n- ros2 launch phantomx_pincher_demos demo_rover_peg_in_hole.launch.py\n\"\"\"\n\nfrom copy import deepcopy\nfrom math import atan2, cos, pi, sin\nfrom os import path\nfrom threading import Thread\nfrom typing import Dict\n\nimport geometry_msgs.msg\nimport rclpy\nimport std_msgs.msg\nimport tf2_geometry_msgs\nimport tf2_ros\nfrom pymoveit2 import GripperInterface, MoveIt2\nfrom pymoveit2.robots import phantomx_pincher\nfrom rclpy.callback_groups import ReentrantCallbackGroup\nfrom rclpy.node import Node\n\n\ndef rpy2quat(\n    roll: float = 0.0, pitch: float = 0.0, yaw: float = 0.0\n) -> Dict[str, float]:\n    \"\"\"\n    Helper function for converting rotation represented as roll-pitch-yaw to quaternions (xyzw order).\n    \"\"\"\n\n    r_2 = roll / 2\n    p_2 = pitch / 2\n    y_2 = yaw / 2\n\n    return dict(\n        x=sin(r_2) * cos(p_2) * cos(y_2) - cos(r_2) * sin(p_2) * sin(y_2),\n        y=cos(r_2) * sin(p_2) * cos(y_2) + sin(r_2) * cos(p_2) * sin(y_2),\n        z=cos(r_2) * cos(p_2) * sin(y_2) - sin(r_2) * sin(p_2) * cos(y_2),\n        w=cos(r_2) * cos(p_2) * cos(y_2) + sin(r_2) * sin(p_2) * sin(y_2),\n    )\n\n\n# Scaling factor for the dynamic scene objects - lower value makes it easier to plan when using an inaccurate (cheap) robot\n# The default value of 0.75 was tested with the real robot\nOBJECT_SCALE = 0.75\n# List of dynamic scene objects\n# Note: You are allowed to change these\nDYNAMIC_SCENE_OBJECTS = [\n    {\n        \"name\": \"peg1\",\n        \"geometry_type\": \"cylinder\",\n        \"initial_pose\": geometry_msgs.msg.PoseStamped(\n            header=std_msgs.msg.Header(\n                frame_id=\"phantomx_pincher_arm_base_link\",\n            ),\n            pose=geometry_msgs.msg.Pose(\n                position=geometry_msgs.msg.Point(x=0.12, y=0.05, z=-0.044),\n                orientation=geometry_msgs.msg.Quaternion(x=0.0, y=0.0, z=0.0, w=1.0),\n            ),\n        ),\n        \"add_object_kwargs\": {\n            \"radius\": OBJECT_SCALE * 0.0125,\n            \"height\": OBJECT_SCALE * 0.04,\n        },\n        \"insert_pose\": geometry_msgs.msg.PoseStamped(\n            header=std_msgs.msg.Header(\n                frame_id=\"phantomx_pincher_base_link\",\n            ),\n            pose=geometry_msgs.msg.Pose(\n                position=geometry_msgs.msg.Point(x=0.05, y=0.0, z=0.053),\n                orientation=geometry_msgs.msg.Quaternion(x=1.0, y=0.0, z=0.0, w=0.0),\n            ),\n        ),\n    },\n    {\n        \"name\": \"peg2\",\n        \"geometry_type\": \"box\",\n        \"initial_pose\": geometry_msgs.msg.PoseStamped(\n            header=std_msgs.msg.Header(\n                frame_id=\"phantomx_pincher_arm_base_link\",\n            ),\n            pose=geometry_msgs.msg.Pose(\n                position=geometry_msgs.msg.Point(x=0.145, y=-0.05, z=-0.038),\n                orientation=geometry_msgs.msg.Quaternion(\n                    **rpy2quat(yaw=atan2(-0.05, 0.145))\n                ),\n            ),\n        ),\n        \"add_object_kwargs\": {\n            \"size\": (\n                OBJECT_SCALE * 0.025,\n                OBJECT_SCALE * 0.025,\n                OBJECT_SCALE * 0.05,\n            )\n        },\n        \"insert_pose\": geometry_msgs.msg.PoseStamped(\n            header=std_msgs.msg.Header(\n                frame_id=\"phantomx_pincher_base_link\",\n            ),\n            pose=geometry_msgs.msg.Pose(\n                position=geometry_msgs.msg.Point(x=0.1, y=0.0, z=0.057),\n                orientation=geometry_msgs.msg.Quaternion(x=1.0, y=0.0, z=0.0, w=0.0),\n            ),\n        ),\n    },\n]\n# List of static scene objects\nSTATIC_SCENE_OBJECTS = [\n    {\n        \"name\": \"module_with_holes\",\n        \"geometry_type\": \"mesh\",\n        \"pose\": geometry_msgs.msg.PoseStamped(\n            header=std_msgs.msg.Header(\n                frame_id=\"phantomx_pincher_task_board_module_link\",\n            ),\n        ),\n        \"add_object_kwargs\": {\n            \"filepath\": path.join(\n                path.dirname(path.realpath(__file__)), \"assets\", \"module_holes.stl\"\n            )\n        },\n    },\n]\n\n\ndef main():\n    rclpy.init()\n\n    # Create node for this demo\n    node = Node(\"demo_peg_in_hole\")\n\n    # Create callback group that allows execution of callbacks in parallel without restrictions\n    callback_group = ReentrantCallbackGroup()\n\n    # Create MoveIt 2 interfaces\n    moveit2 = MoveIt2(\n        node=node,\n        joint_names=phantomx_pincher.joint_names(),\n        base_link_name=phantomx_pincher.base_link_name(),\n        end_effector_name=phantomx_pincher.end_effector_name(),\n        group_name=phantomx_pincher.MOVE_GROUP_ARM,\n        callback_group=callback_group,\n        execute_via_moveit=True,\n    )\n    gripper = GripperInterface(\n        node=node,\n        gripper_joint_names=phantomx_pincher.gripper_joint_names(),\n        open_gripper_joint_positions=phantomx_pincher.OPEN_GRIPPER_JOINT_POSITIONS,\n        closed_gripper_joint_positions=phantomx_pincher.CLOSED_GRIPPER_JOINT_POSITIONS,\n        gripper_group_name=phantomx_pincher.MOVE_GROUP_GRIPPER,\n        callback_group=callback_group,\n        execute_via_moveit=True,\n    )\n\n    # Instantiate tf2 buffer and listener for looking up transforms\n    tf2_buffer = tf2_ros.Buffer(node=node)\n    tf2_listener = tf2_ros.TransformListener(buffer=tf2_buffer, node=node)\n\n    # Spin the node in background thread(s) and wait a bit for initialization\n    executor = rclpy.executors.MultiThreadedExecutor(2)\n    executor.add_node(node)\n    executor_thread = Thread(target=executor.spin, daemon=True, args=())\n    executor_thread.start()\n    node.create_rate(1.0).sleep()\n\n    # Scale down velocity and acceleration of joints (percentage of maximum)\n    moveit2.max_velocity = 0.5\n    moveit2.max_acceleration = 0.5\n\n    # Wait until the simulated robot is ready to be controlled\n    rate = node.create_rate(1.0)\n    while rclpy.ok() and moveit2.joint_state is None:\n        rate.sleep()\n    rate.destroy()\n\n    ### Setup the Planning Scene ###\n    # Clean the previous scene\n    reset_planning_scene(moveit2=moveit2)\n    # Move to initial joint configuration\n    moveit2.move_to_configuration(\n        joint_positions=[\n            0.0,\n            0.0,\n            pi / 2,\n            pi / 2,\n        ],\n    )\n    moveit2.wait_until_executed()\n    # Setup the new scene\n    setup_planning_scene(\n        moveit2=moveit2,\n        # Note: Planning can be simplified by disabling the dynamic scene objects\n        add_dynamic_scene_objects=True,\n    )\n\n    ##\n    # TODO: Make your changes here (pick and insert the pegs)\n    ##\n\n    rclpy.shutdown()\n    executor_thread.join()\n    exit(0)\n\n\ndef setup_planning_scene(\n    moveit2: MoveIt2,\n    add_dynamic_scene_objects: bool = True,\n):\n    \"\"\"\n    Setup the planning scene of MoveIt for collision checking.\n    With `add_dynamic_scene_objects` disabled, only static scene objects are added.\n    \"\"\"\n\n    ## Add static objects to the planning scene\n    for scene_object in STATIC_SCENE_OBJECTS:\n        getattr(moveit2, f'add_collision_{scene_object[\"geometry_type\"]}')(\n            id=scene_object[\"name\"],\n            pose=scene_object[\"pose\"],\n            **scene_object[\"add_object_kwargs\"],\n        )\n\n    ## Add dynamic objects to the planning scene (if desired)\n    if add_dynamic_scene_objects:\n        for scene_object in DYNAMIC_SCENE_OBJECTS:\n            getattr(moveit2, f'add_collision_{scene_object[\"geometry_type\"]}')(\n                id=scene_object[\"name\"],\n                pose=scene_object[\"initial_pose\"],\n                **scene_object[\"add_object_kwargs\"],\n            )\n\n\ndef reset_planning_scene(\n    moveit2: MoveIt2,\n):\n    \"\"\"\n    Remove all scene objects from previous run.\n    \"\"\"\n\n    moveit2.detach_all_collision_objects()\n    for scene_object in STATIC_SCENE_OBJECTS:\n        moveit2.remove_collision_object(scene_object[\"name\"])\n    for scene_object in DYNAMIC_SCENE_OBJECTS:\n        moveit2.remove_collision_object(scene_object[\"name\"])\n\n\nif __name__ == \"__main__\":\n    main()\n"}\n